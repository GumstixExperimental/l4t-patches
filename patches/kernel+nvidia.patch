From 60a3ac42f1e8877a0056424fcf0610e5df47068b Mon Sep 17 00:00:00 2001
From: Keith Lee <keith.lee@gumstix.com>
Date: Mon, 13 Jan 2020 22:41:01 -0800
Subject: [PATCH] Add Gumstix cameras

---
 drivers/media/i2c/Kconfig                          |   29 +
 drivers/media/i2c/Makefile                         |    3 +
 drivers/media/i2c/imx214.c                         |  752 ++---
 drivers/media/i2c/imx214_mode_tbls.h               | 2886 +++++++++++++++++++
 drivers/media/i2c/ov5640.c                         | 1557 +++++++++++
 drivers/media/i2c/ov5640_mode_tbls.h               |  376 +++
 drivers/media/i2c/ov5670.c                         | 1498 ++++++++++
 drivers/media/i2c/ov5670_mode_tbls.h               | 2954 ++++++++++++++++++++
 .../media/platform/tegra/camera/camera_common.c    |   18 +
 .../media/platform/tegra/camera/sensor_common.c    |    7 +
 include/media/imx214.h                             |  174 ++
 include/media/ov5640.h                             |  176 ++
 include/media/ov5670.h                             |  185 ++
 13 files changed, 10296 insertions(+), 319 deletions(-)
 create mode 100644 drivers/media/i2c/imx214_mode_tbls.h
 create mode 100644 drivers/media/i2c/ov5640.c
 create mode 100644 drivers/media/i2c/ov5640_mode_tbls.h
 create mode 100644 drivers/media/i2c/ov5670.c
 create mode 100644 drivers/media/i2c/ov5670_mode_tbls.h
 create mode 100644 include/media/imx214.h
 create mode 100644 include/media/ov5640.h
 create mode 100644 include/media/ov5670.h

diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index abfb5f5..b9499cd 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -13,6 +13,15 @@ config VIDEO_IMX185
 	To compile this driver as a module, choose M here: the module
 	will be called imx185.
 
+config VIDEO_IMX214
+        tristate "IMX214 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	---help---
+	  This driver supports IMX214 camera sensor from Sony
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called imx214.
+
 config VIDEO_IMX219
         tristate "IMX219 camera sensor support"
 	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
@@ -61,6 +70,26 @@ config VIDEO_LC898212
 	  To compile this driver as a module, choose M here: the module
 	  will be called lc898212.
 
+config VIDEO_OV5640
+	tristate "OV5640 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the OmniVision
+	  OV5640 camera.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called ov5640.
+
+config VIDEO_OV5670
+	tristate "OV5670 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the OmniVision
+	  OV5670 camera.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called ov5670.
+
 config VIDEO_OV5693
 	tristate "OV5693 camera sensor support"
 	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index 3e808e1..a2fea94 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -5,12 +5,15 @@ ccflags-y += -I$(srctree)/drivers/video/tegra/camera
 
 obj-$(CONFIG_VIDEO_IMX185) += imx185.o
 obj-$(CONFIG_VIDEO_IMX185) += imx185_v1.o
+obj-$(CONFIG_VIDEO_IMX214) += imx214.o
 obj-$(CONFIG_VIDEO_IMX219) += imx219.o
 obj-$(CONFIG_VIDEO_IMX268) += imx268.o
 obj-$(CONFIG_VIDEO_IMX274) += imx274.o
 obj-$(CONFIG_VIDEO_IMX318) += imx318.o
 obj-$(CONFIG_VIDEO_LC898212) += lc898212.o
 obj-$(CONFIG_VIDEO_OV5693) += ov5693.o
+obj-$(CONFIG_VIDEO_OV5670) += ov5670.o
+obj-$(CONFIG_VIDEO_OV5640) += ov5640.o
 obj-$(CONFIG_VIDEO_OV9281) += ov9281.o
 obj-$(CONFIG_VIDEO_OV10823) += ov10823.o
 obj-$(CONFIG_VIDEO_OV23850) += ov23850.o
diff --git a/drivers/media/i2c/imx214.c b/drivers/media/i2c/imx214.c
index 20cf20a..fd20192 100644
--- a/drivers/media/i2c/imx214.c
+++ b/drivers/media/i2c/imx214.c
@@ -16,6 +16,8 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#define DEBUG
+
 #include <linux/slab.h>
 #include <linux/uaccess.h>
 #include <linux/gpio.h>
@@ -30,29 +32,33 @@
 #include <media/camera_common.h>
 #include <media/imx214.h>
 
+#include "../platform/tegra/camera/camera_gpio.h"
 #include "imx214_mode_tbls.h"
 
-#define IMX214_MAX_COARSE_DIFF		10
+#define IMX214_MAX_COARSE_DIFF		6
 
 #define IMX214_GAIN_SHIFT		8
 #define IMX214_MIN_GAIN		(1 << IMX214_GAIN_SHIFT)
 #define IMX214_MAX_GAIN		(16 << IMX214_GAIN_SHIFT)
+#define IMX214_MAX_UNREAL_GAIN	(0x0F80)
+
 #define IMX214_MIN_FRAME_LENGTH	(0x0)
-#define IMX214_MAX_FRAME_LENGTH	(0xffff)
-#define IMX214_MIN_EXPOSURE_COARSE	(0x0001)
+#define IMX214_MAX_FRAME_LENGTH	(0x7fff)
+#define IMX214_MIN_EXPOSURE_COARSE	(0x0002)
 #define IMX214_MAX_EXPOSURE_COARSE	\
 	(IMX214_MAX_FRAME_LENGTH-IMX214_MAX_COARSE_DIFF)
+#define IMX214_DEFAULT_LINE_LENGTH	(0x10CC)
+#define IMX214_DEFAULT_PIXEL_CLOCK	(480)
 
 #define IMX214_DEFAULT_GAIN		IMX214_MIN_GAIN
-#define IMX214_DEFAULT_FRAME_LENGTH	(0x0C7A)
+#define IMX214_DEFAULT_FRAME_LENGTH	(0x07C0)
 #define IMX214_DEFAULT_EXPOSURE_COARSE	\
 	(IMX214_DEFAULT_FRAME_LENGTH-IMX214_MAX_COARSE_DIFF)
 
-#define IMX214_DEFAULT_MODE	IMX214_MODE_4096X3072
-#define IMX214_DEFAULT_HDR_MODE	IMX214_MODE_4096X3072_HDR
-#define IMX214_DEFAULT_WIDTH	4096
-#define IMX214_DEFAULT_HEIGHT	3072
-#define IMX214_DEFAULT_DATAFMT	V4L2_MBUS_FMT_SRGGB10_1X10
+#define IMX214_DEFAULT_MODE	IMX214_MODE_4208X3120
+#define IMX214_DEFAULT_WIDTH	4208
+#define IMX214_DEFAULT_HEIGHT	3120
+#define IMX214_DEFAULT_DATAFMT	MEDIA_BUS_FMT_SBGGR10_1X10
 #define IMX214_DEFAULT_CLK_FREQ	24000000
 
 struct imx214 {
@@ -66,6 +72,7 @@ struct imx214 {
 	struct media_pad		pad;
 
 	s32				group_hold_prev;
+	u32				frame_length;
 	bool				group_hold_en;
 	struct regmap			*regmap;
 	struct camera_common_data	*s_data;
@@ -73,14 +80,14 @@ struct imx214 {
 	struct v4l2_ctrl		*ctrls[];
 };
 
-static const struct regmap_config sensor_regmap_config = {
+static struct regmap_config imx214_regmap_config = {
 	.reg_bits = 16,
 	.val_bits = 8,
-	.cache_type = REGCACHE_RBTREE,
 };
 
 static int imx214_g_volatile_ctrl(struct v4l2_ctrl *ctrl);
 static int imx214_s_ctrl(struct v4l2_ctrl *ctrl);
+static void imx214_update_ctrl_range(struct imx214 *priv, s32 frame_length);
 
 static const struct v4l2_ctrl_ops imx214_ctrl_ops = {
 	.g_volatile_ctrl = imx214_g_volatile_ctrl,
@@ -175,20 +182,10 @@ static struct v4l2_ctrl_config ctrl_config_list[] = {
 		.max = IMX214_OTP_STR_SIZE,
 		.step = 2,
 	},
-	{
-		.ops = &imx214_ctrl_ops,
-		.id = TEGRA_CAMERA_CID_FUSE_ID,
-		.name = "Fuse ID",
-		.type = V4L2_CTRL_TYPE_STRING,
-		.flags = V4L2_CTRL_FLAG_READ_ONLY,
-		.min = 0,
-		.max = IMX214_FUSE_ID_STR_SIZE,
-		.step = 2,
-	},
 };
 
 static inline void imx214_get_frame_length_regs(imx214_reg *regs,
-				u16 frame_length)
+				u32 frame_length)
 {
 	regs->addr = IMX214_FRAME_LENGTH_ADDR_MSB;
 	regs->val = (frame_length >> 8) & 0xff;
@@ -197,20 +194,20 @@ static inline void imx214_get_frame_length_regs(imx214_reg *regs,
 }
 
 static inline void imx214_get_coarse_time_regs(imx214_reg *regs,
-				u16 coarse_time)
+				u32 coarse_time)
 {
-	regs->addr = IMX214_COARSE_TIME_ADDR_MSB;
+	regs->addr = IMX214_COARSE_TIME_ADDR_1;
 	regs->val = (coarse_time >> 8) & 0xff;
-	(regs + 1)->addr = IMX214_COARSE_TIME_ADDR_LSB;
+	(regs + 1)->addr = IMX214_COARSE_TIME_ADDR_2;
 	(regs + 1)->val = (coarse_time) & 0xff;
 }
 
 static inline void imx214_get_coarse_time_short_regs(imx214_reg *regs,
-				u16 coarse_time)
+				u32 coarse_time)
 {
-	regs->addr = IMX214_COARSE_TIME_SHORT_ADDR_MSB;
+	regs->addr = IMX214_COARSE_TIME_SHORT_ADDR_1;
 	regs->val = (coarse_time >> 8) & 0xff;
-	(regs + 1)->addr = IMX214_COARSE_TIME_SHORT_ADDR_LSB;
+	(regs + 1)->addr = IMX214_COARSE_TIME_SHORT_ADDR_2;
 	(regs + 1)->val = (coarse_time) & 0xff;
 }
 
@@ -223,15 +220,6 @@ static inline void imx214_get_gain_regs(imx214_reg *regs,
 	(regs + 1)->val = (gain) & 0xff;
 }
 
-static inline void imx214_get_gain_short_reg(imx214_reg *regs,
-				u16 gain)
-{
-	regs->addr = IMX214_GAIN_SHORT_ADDR_MSB;
-	regs->val = (gain >> 8) & 0xff;
-	(regs + 1)->addr = IMX214_GAIN_SHORT_ADDR_LSB;
-	(regs + 1)->val = (gain) & 0xff;
-}
-
 static int test_mode;
 module_param(test_mode, int, 0644);
 
@@ -239,8 +227,12 @@ static inline int imx214_read_reg(struct camera_common_data *s_data,
 				u16 addr, u8 *val)
 {
 	struct imx214 *priv = (struct imx214 *)s_data->priv;
+	int err = 0;
+	u32 reg_val = 0;
 
-	return regmap_read(priv->regmap, addr, (unsigned int *) val);
+	err = regmap_read(priv->regmap, addr, &reg_val);
+	*val = reg_val & 0xFF;
+	return err;
 }
 
 static int imx214_write_reg(struct camera_common_data *s_data, u16 addr, u8 val)
@@ -267,12 +259,27 @@ static int imx214_write_table(struct imx214 *priv,
 					 IMX214_TABLE_END);
 }
 
+static void imx214_gpio_set(struct imx214 *priv,
+			    unsigned int gpio, int val)
+{
+	if (priv->pdata && priv->pdata->use_cam_gpio)
+		cam_gpio_ctrl(&priv->i2c_client->dev, gpio, val, 1);
+	else {
+		if (gpio_cansleep(gpio))
+			gpio_set_value_cansleep(gpio, val);
+		else
+			gpio_set_value(gpio, val);
+	}
+}
+
+
 static int imx214_power_on(struct camera_common_data *s_data)
 {
+	struct imx214 *priv = (struct imx214 *)s_data->priv;
 	struct device *dev = &priv->i2c_client->dev;
 	int err = 0;
-	struct imx214 *priv = (struct imx214 *)s_data->priv;
 	struct camera_common_power_rail *pw = &priv->power;
+	u32 frame_time;
 
 	dev_dbg(dev, "%s: power on\n", __func__);
 
@@ -288,42 +295,48 @@ static int imx214_power_on(struct camera_common_data *s_data)
 	/* sleep calls in the sequence below are for internal device
 	 * signal propagation as specified by sensor vendor */
 
-	if (pw->reset_gpio)
-		gpio_set_value(pw->reset_gpio, 0);
-	if (pw->af_gpio)
-		gpio_set_value(pw->af_gpio, 1);
-	if (pw->pwdn_gpio)
-		gpio_set_value(pw->pwdn_gpio, 0);
-	usleep_range(10, 20);
-
 	if (pw->avdd)
 		err = regulator_enable(pw->avdd);
 	if (err)
 		goto imx214_avdd_fail;
 
-	if (pw->iovdd)
-		err = regulator_enable(pw->iovdd);
+	if (pw->dvdd)
+		err = regulator_enable(pw->dvdd);
 	if (err)
-		goto imx214_iovdd_fail;
+		goto imx214_dvdd_fail;
+/*
+* datasheet 2.9: reset requires ~2ms settling time
+* a power on reset is generated after core power becomes stable
+*/
+	usleep_range(2000, 2010);
 
-	udelay(1);
 	if (pw->reset_gpio)
-		gpio_set_value(pw->reset_gpio, 1);
+		imx214_gpio_set(priv, pw->reset_gpio, 1);
 	if (pw->pwdn_gpio)
-		gpio_set_value(pw->pwdn_gpio, 1);
-
-	usleep_range(300, 310);
+		imx214_gpio_set(priv, pw->pwdn_gpio, 1);
 
+/* datasheet fig 18: t7 */
 	pw->state = SWITCH_ON;
+
+	/* need SW standby LP11 for mipical.
+	 * sensor default is LP00, this will transition to LP11
+	 */
+
+	/*
+	 * Sleep to allow SW reset to settle into LP11. After writing
+	 * 0x1, according to the datasheet, it could take the remainder
+	 * of the frame time to settle.  Streaming too soon after this
+	 * may have unintended consequences.
+	 */
+	frame_time = IMX214_DEFAULT_FRAME_LENGTH *
+				IMX214_DEFAULT_LINE_LENGTH / IMX214_DEFAULT_PIXEL_CLOCK;
+	usleep_range(300, 310);
 	return 0;
 
-imx214_iovdd_fail:
+imx214_dvdd_fail:
 	regulator_disable(pw->avdd);
 
 imx214_avdd_fail:
-	if (pw->af_gpio)
-		gpio_set_value(pw->af_gpio, 0);
-
 	dev_err(dev, "%s failed.\n", __func__);
 	return -ENODEV;
 }
@@ -337,30 +350,31 @@ static int imx214_power_off(struct camera_common_data *s_data)
 
 	dev_dbg(dev, "%s: power off\n", __func__);
 
-	if (priv->pdata && priv->pdata->power_on) {
+	if (priv->pdata && priv->pdata->power_off) {
 		err = priv->pdata->power_off(pw);
-		if (err) {
+		if (!err) {
+			goto power_off_done;
+		} else {
 			dev_err(dev, "%s failed.\n", __func__);
 			return err;
-		} else {
-			goto power_off_done;
 		}
 	}
 
 	/* sleeps calls in the sequence below are for internal device
 	 * signal propagation as specified by sensor vendor */
 
-	usleep_range(1, 2);
+	usleep_range(21, 25);
 	if (pw->reset_gpio)
-		gpio_set_value(pw->reset_gpio, 0);
-	if (pw->af_gpio)
-		gpio_set_value(pw->af_gpio, 0);
+		imx214_gpio_set(priv, pw->reset_gpio, 0);
+	usleep_range(1000, 2000);
 	if (pw->pwdn_gpio)
-		gpio_set_value(pw->pwdn_gpio, 0);
-	usleep_range(1, 2);
+		imx214_gpio_set(priv, pw->pwdn_gpio, 0);
 
-	if (pw->iovdd)
-		regulator_disable(pw->iovdd);
+		/* datasheet 2.9: reset requires ~2ms settling time*/
+	usleep_range(2000, 2010);
+
+	if (pw->dvdd)
+		regulator_disable(pw->dvdd);
 	if (pw->avdd)
 		regulator_disable(pw->avdd);
 
@@ -368,39 +382,99 @@ power_off_done:
 	pw->state = SWITCH_OFF;
 	return 0;
 }
+/*
+static int imx214_power_put(struct imx214 *priv)
+{
+	struct camera_common_power_rail *pw = &priv->power;
+
+	if (unlikely(!pw))
+		return -EFAULT;
 
+	if (likely(pw->avdd))
+		regulator_put(pw->avdd);
+
+	if (likely(pw->dvdd))
+		regulator_put(pw->dvdd);
+
+	pw->avdd = NULL;
+	pw->dvdd = NULL;
+
+	if (priv->pdata && priv->pdata->use_cam_gpio)
+		cam_gpio_deregister(&priv->i2c_client->dev, pw->pwdn_gpio);
+	else {
+		gpio_free(pw->pwdn_gpio);
+		gpio_free(pw->reset_gpio);
+	}
+
+	return 0;
+}
+*/
 static int imx214_power_get(struct imx214 *priv)
 {
 	struct camera_common_power_rail *pw = &priv->power;
 	struct camera_common_pdata *pdata = priv->pdata;
 	struct device *dev = &priv->i2c_client->dev;
 	const char *mclk_name;
-	int err = 0;
+	const char *parentclk_name;
+	struct clk *parent;
+	int err = 0, ret = 0;
 
-	mclk_name = priv->pdata->mclk_name ?
-		    priv->pdata->mclk_name : "cam_mclk1";
+	if (!pdata) {
+		dev_err(&priv->i2c_client->dev, "pdata missing\n");
+		return -EFAULT;
+	}
+	mclk_name = pdata->mclk_name ?
+		    pdata->mclk_name : "cam_mclk1";
 	pw->mclk = devm_clk_get(dev, mclk_name);
 	if (IS_ERR(pw->mclk)) {
 		dev_err(dev, "unable to get clock %s\n", mclk_name);
 		return PTR_ERR(pw->mclk);
 	}
 
-	/* analog 2.7v */
-	err |= camera_common_regulator_get(priv->i2c_client,
-			&pw->avdd, pdata->regulators.avdd);
-	/* digital 1.2v */
-	err |= camera_common_regulator_get(priv->i2c_client,
+	parentclk_name = pdata->parentclk_name;
+	if (parentclk_name) {
+		parent = devm_clk_get(&priv->i2c_client->dev, parentclk_name);
+		if (IS_ERR(parent)) {
+			dev_err(&priv->i2c_client->dev,
+				"unable to get parent clcok %s",
+				parentclk_name);
+		} else
+			clk_set_parent(pw->mclk, parent);
+	}
+
+
+	/* analog 2.8v */
+	err |= camera_common_regulator_get(&priv->i2c_client->dev,
+	 			&pw->avdd, pdata->regulators.avdd);
+
+	/* IO 1.2v */
+	err |= camera_common_regulator_get(&priv->i2c_client->dev,
 			&pw->dvdd, pdata->regulators.dvdd);
-	/* IO 1.8v */
-	err |= camera_common_regulator_get(priv->i2c_client,
-			&pw->iovdd, pdata->regulators.iovdd);
 
 	if (!err) {
 		pw->reset_gpio = pdata->reset_gpio;
-		pw->af_gpio = pdata->af_gpio;
 		pw->pwdn_gpio = pdata->pwdn_gpio;
 	}
 
+	if (pdata->use_cam_gpio) {
+		err = cam_gpio_register(&priv->i2c_client->dev, pw->pwdn_gpio);
+		if (err)
+			dev_err(&priv->i2c_client->dev,
+				"%s ERR can't register cam gpio %u!\n",
+				 __func__, pw->pwdn_gpio);
+	} else {
+		ret = gpio_request(pw->pwdn_gpio, "cam_pwdn_gpio");
+		if (ret < 0)
+			dev_dbg(&priv->i2c_client->dev,
+				"%s can't request pwdn_gpio %d\n",
+				__func__, ret);
+		ret = gpio_request(pw->reset_gpio, "cam_reset_gpio");
+		if (ret < 0)
+			dev_dbg(&priv->i2c_client->dev,
+				"%s can't request reset_gpio %d\n",
+				__func__, ret);
+	}
+
 	pw->state = SWITCH_OFF;
 	return err;
 }
@@ -413,17 +487,36 @@ static int imx214_set_coarse_time_short(struct imx214 *priv, s32 val);
 static int imx214_s_stream(struct v4l2_subdev *sd, int enable)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct camera_common_data *s_data = to_camera_common_data(client);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
 	struct imx214 *priv = (struct imx214 *)s_data->priv;
 	struct v4l2_control control;
 	int err;
+	u32 frame_time;
+	u8 val;
+
+	dev_dbg(&client->dev, "%s++\n", __func__);
 
-	dev_dbg(&client->dev, "%s++ enable %d\n", __func__, enable);
-	if (!enable)
-		return imx214_write_table(priv,
+	if (!enable) {
+		imx214_update_ctrl_range(priv, IMX214_MAX_FRAME_LENGTH);
+ 		err = imx214_write_table(priv,
 			mode_table[IMX214_MODE_STOP_STREAM]);
+		if (err)
+			return err;
 
-	err = imx214_write_table(priv, mode_table[IMX214_MODE_COMMON]);
+		/*
+		 * Wait for one frame to make sure sensor is set to
+		 * software standby in V-blank
+		 *
+		 * frame_time = frame length rows * Tline
+		 * Tline = line length / pixel clock (in MHz)
+		 */
+			frame_time = priv->frame_length *
+				IMX214_DEFAULT_LINE_LENGTH / IMX214_DEFAULT_PIXEL_CLOCK;
+			usleep_range(frame_time, frame_time + 1000);
+			return 0;
+		}
+
+	err = imx214_write_table(priv, imx214_pll_1200mbps);
 	if (err)
 		goto exit;
 	err = imx214_write_table(priv, mode_table[s_data->mode]);
@@ -431,8 +524,8 @@ static int imx214_s_stream(struct v4l2_subdev *sd, int enable)
 		goto exit;
 
 	if (s_data->override_enable) {
-		/* write list of override regs for the asking frame length, */
 		/*
+		 * write list of override regs for the asking frame length,
 		 * coarse integration time, and gain. Failures to write
 		 * overrides are non-fatal
 		 */
@@ -448,14 +541,16 @@ static int imx214_s_stream(struct v4l2_subdev *sd, int enable)
 		err |= imx214_set_frame_length(priv, control.value);
 		if (err)
 			dev_dbg(&client->dev,
-				"%s: frame length override failed\n", __func__);
+				"%s: warning frame length override failed\n",
+				__func__);
 
 		control.id = TEGRA_CAMERA_CID_COARSE_TIME;
 		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
 		err |= imx214_set_coarse_time(priv, control.value);
 		if (err)
 			dev_dbg(&client->dev,
-				"%s: coarse time override failed\n", __func__);
+				"%s: warning coarse time override failed\n",
+				__func__);
 
 		control.id = TEGRA_CAMERA_CID_COARSE_TIME_SHORT;
 		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
@@ -470,31 +565,80 @@ static int imx214_s_stream(struct v4l2_subdev *sd, int enable)
 	if (err)
 		goto exit;
 
+	if (priv->pdata->v_flip) {
+		imx214_read_reg(priv->s_data, IMX214_TIMING_REG20, &val);
+		imx214_write_reg(priv->s_data, IMX214_TIMING_REG20,
+				 val | VERTICAL_FLIP);
+	}
+		if (priv->pdata->h_mirror) {
+		imx214_read_reg(priv->s_data, IMX214_TIMING_REG21, &val);
+		imx214_write_reg(priv->s_data, IMX214_TIMING_REG21,
+				 val | HORIZONTAL_MIRROR_MASK);
+	} else {
+		imx214_read_reg(priv->s_data, IMX214_TIMING_REG21, &val);
+		imx214_write_reg(priv->s_data, IMX214_TIMING_REG21,
+				 val & (~HORIZONTAL_MIRROR_MASK));
+	}
+
 	if (test_mode)
 		err = imx214_write_table(priv,
 			mode_table[IMX214_MODE_TEST_PATTERN]);
 
+	dev_dbg(&client->dev, "%s--\n", __func__);
 	return 0;
 exit:
 	dev_dbg(&client->dev, "%s: error setting stream\n", __func__);
 	return err;
 }
 
+static int imx214_g_input_status(struct v4l2_subdev *sd, u32 *status)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct imx214 *priv = (struct imx214 *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+
+	*status = pw->state == SWITCH_ON;
+	return 0;
+}
+
 static struct v4l2_subdev_video_ops imx214_subdev_video_ops = {
 	.s_stream	= imx214_s_stream,
-	.s_mbus_fmt	= camera_common_s_fmt,
-	.g_mbus_fmt	= camera_common_g_fmt,
-	.try_mbus_fmt	= camera_common_try_fmt,
-	.enum_mbus_fmt	= camera_common_enum_fmt,
 	.g_mbus_config	= camera_common_g_mbus_config,
+	.g_input_status = imx214_g_input_status,
 };
 
 static struct v4l2_subdev_core_ops imx214_subdev_core_ops = {
 	.s_power	= camera_common_s_power,
 };
 
+static int imx214_get_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	return camera_common_g_fmt(sd, &format->format);
+}
+
+static int imx214_set_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	int ret;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		ret = camera_common_try_fmt(sd, &format->format);
+	else
+		ret = camera_common_s_fmt(sd, &format->format);
+
+	return ret;
+}
+
 static struct v4l2_subdev_pad_ops imx214_subdev_pad_ops = {
+	.set_fmt = imx214_set_fmt,
+	.get_fmt = imx214_get_fmt,
 	.enum_mbus_code = camera_common_enum_mbus_code,
+	.enum_frame_size	= camera_common_enum_framesizes,
+	.enum_frame_interval	= camera_common_enum_frameintervals,
 };
 
 static struct v4l2_subdev_ops imx214_subdev_ops = {
@@ -504,7 +648,7 @@ static struct v4l2_subdev_ops imx214_subdev_ops = {
 };
 
 static struct of_device_id imx214_of_match[] = {
-	{ .compatible = "nvidia,imx214", },
+	{ .compatible = "sony,imx214", },
 	{ },
 };
 
@@ -522,17 +666,25 @@ static int imx214_set_group_hold(struct imx214 *priv)
 	int gh_prev = switch_ctrl_qmenu[priv->group_hold_prev];
 
 	if (priv->group_hold_en == true && gh_prev == SWITCH_OFF) {
+		/* enter group hold */
+
 		err = imx214_write_reg(priv->s_data,
 				       IMX214_GROUP_HOLD_ADDR, 0x1);
 		if (err)
 			goto fail;
+
 		priv->group_hold_prev = 1;
+
+		dev_dbg(&priv->i2c_client->dev,
+			 "%s: enter group hold\n", __func__);
 	} else if (priv->group_hold_en == false && gh_prev == SWITCH_ON) {
-		err = imx214_write_reg(priv->s_data,
-				       IMX214_GROUP_HOLD_ADDR, 0x0);
-		if (err)
-			goto fail;
+		/* leave group hold */
+
+
 		priv->group_hold_prev = 0;
+
+		dev_dbg(&priv->i2c_client->dev,
+			 "%s: leave group hold\n", __func__);
 	}
 
 	return 0;
@@ -542,21 +694,22 @@ fail:
 	return err;
 }
 
-static int imx214_calculate_gain(u32 rep, int shift)
+static int imx214_to_real_gain(u32 rep, int shift)
 {
-	int gain;
+	u16 gain;
 	int gain_int;
 	int gain_dec;
 	int min_int = (1 << shift);
-	int denom;
 
-	/* shift indicates number of least significant bits
-	 * used for decimal representation of gain */
+	if (rep < IMX214_MIN_GAIN)
+		rep = IMX214_MIN_GAIN;
+	else if (rep > IMX214_MAX_GAIN)
+		rep = IMX214_MAX_GAIN;
+
 	gain_int = (int)(rep >> shift);
 	gain_dec = (int)(rep & ~(0xffff << shift));
 
-	denom = gain_int * min_int + gain_dec;
-	gain = 512 - ((512 * min_int + (denom - 1)) / denom);
+	gain = ((gain_int * min_int + gain_dec) * 32 + min_int) / (2 * min_int);
 
 	return gain;
 }
@@ -565,34 +718,28 @@ static int imx214_set_gain(struct imx214 *priv, s32 val)
 {
 	struct device *dev = &priv->i2c_client->dev;
 	imx214_reg reg_list[2];
-	imx214_reg reg_list_short[2];
 	int err;
 	u16 gain;
-	int i = 0;
+	int i;
+
+	if (!priv->group_hold_prev)
+		imx214_set_group_hold(priv);
 
 	/* translate value */
-	gain = (u16)imx214_calculate_gain(val, IMX214_GAIN_SHIFT);
+	gain = (u16)imx214_to_real_gain((u32)val, IMX214_GAIN_SHIFT);
 
 	dev_dbg(dev, "%s: val: %d\n", __func__, gain);
 
 	imx214_get_gain_regs(reg_list, gain);
-	imx214_get_gain_short_reg(reg_list_short, gain);
-	imx214_set_group_hold(priv);
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: gain %04x val: %04x\n", __func__, val, gain);
 
-	/* writing long gain */
 	for (i = 0; i < 2; i++) {
 		err = imx214_write_reg(priv->s_data, reg_list[i].addr,
 			 reg_list[i].val);
 		if (err)
 			goto fail;
 	}
-	/* writing short gain */
-	for (i = 0; i < 2; i++) {
-		err = imx214_write_reg(priv->s_data, reg_list_short[i].addr,
-			 reg_list_short[i].val);
-		if (err)
-			goto fail;
-	}
 
 	return 0;
 
@@ -601,20 +748,60 @@ fail:
 	return err;
 }
 
+static void imx214_update_ctrl_range(struct imx214 *priv, s32 frame_length)
+{
+	struct v4l2_ctrl *ctrl = NULL;
+	int ctrl_ids[2] = {TEGRA_CAMERA_CID_COARSE_TIME,
+			TEGRA_CAMERA_CID_COARSE_TIME_SHORT};
+	s32 max, min, def;
+	int i, j;
+
+	for (i = 0; i < ARRAY_SIZE(ctrl_ids); i++) {
+		for (j = 0; j < priv->numctrls; j++) {
+			if (priv->ctrls[j]->id == ctrl_ids[i]) {
+				ctrl = priv->ctrls[j];
+				break;
+			}
+		}
+
+		if (j == priv->numctrls) {
+			dev_err(&priv->i2c_client->dev,
+				"could not find ctrl %x\n",
+				ctrl_ids[i]);
+			continue;
+		}
+
+		max = frame_length - IMX214_MAX_COARSE_DIFF;
+		/* clamp the value in case above is negative */
+		max = clamp_val(max, IMX214_MIN_EXPOSURE_COARSE,
+			IMX214_MAX_EXPOSURE_COARSE);
+		min = IMX214_MIN_EXPOSURE_COARSE;
+		def = clamp_val(IMX214_DEFAULT_EXPOSURE_COARSE, min, max);
+		if (__v4l2_ctrl_modify_range(ctrl, min, max, 1, def))
+			dev_err(&priv->i2c_client->dev,
+				"ctrl %x: range update failed\n",
+				ctrl_ids[i]);
+	}
+
+}
+
+
 static int imx214_set_frame_length(struct imx214 *priv, s32 val)
 {
 	struct device *dev = &priv->i2c_client->dev;
 	imx214_reg reg_list[2];
 	int err;
-	u16 frame_length;
-	int i = 0;
+	u32 frame_length;
+	int i;
 
-	frame_length = (u16)val;
+	if (!priv->group_hold_prev)
+			imx214_set_group_hold(priv);
 
-	dev_dbg(dev, "%s: val: %d\n", __func__, frame_length);
+	frame_length = (u32)val;
 
 	imx214_get_frame_length_regs(reg_list, frame_length);
-	imx214_set_group_hold(priv);
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: val: %d\n", __func__, frame_length);
 
 	for (i = 0; i < 2; i++) {
 		err = imx214_write_reg(priv->s_data, reg_list[i].addr,
@@ -623,6 +810,10 @@ static int imx214_set_frame_length(struct imx214 *priv, s32 val)
 			goto fail;
 	}
 
+
+	priv->frame_length = frame_length;
+
+	imx214_update_ctrl_range(priv, val);
 	return 0;
 
 fail:
@@ -633,19 +824,20 @@ fail:
 static int imx214_set_coarse_time(struct imx214 *priv, s32 val)
 {
 	struct device *dev = &priv->i2c_client->dev;
-	imx214_reg reg_list[2];
+	imx214_reg reg_list[3];
 	int err;
-	u16 coarse_time;
-	int i = 0;
-
-	coarse_time = (u16)val;
+	u32 coarse_time;
+	int i;
+	if (!priv->group_hold_prev)
+		imx214_set_group_hold(priv);
+	coarse_time = (u32)val;
 
+	imx214_get_coarse_time_regs(reg_list, coarse_time);
 	dev_dbg(dev, "%s: val: %d\n", __func__, coarse_time);
 
 	imx214_get_coarse_time_regs(reg_list, coarse_time);
-	imx214_set_group_hold(priv);
 
-	for (i = 0; i < 2; i++) {
+	for (i = 0; i < 3; i++) {
 		err = imx214_write_reg(priv->s_data, reg_list[i].addr,
 			 reg_list[i].val);
 		if (err)
@@ -662,12 +854,15 @@ fail:
 static int imx214_set_coarse_time_short(struct imx214 *priv, s32 val)
 {
 	struct device *dev = &priv->i2c_client->dev;
-	imx214_reg reg_list[2];
+	imx214_reg reg_list[3];
 	int err;
 	struct v4l2_control hdr_control;
 	int hdr_en;
-	u16 coarse_time_short;
-	int i = 0;
+	u32 coarse_time_short;
+	int i;
+
+	if (!priv->group_hold_prev)
+			imx214_set_group_hold(priv);
 
 	/* check hdr enable ctrl */
 	hdr_control.id = TEGRA_CAMERA_CID_HDR_EN;
@@ -682,15 +877,13 @@ static int imx214_set_coarse_time_short(struct imx214 *priv, s32 val)
 	if (hdr_en == SWITCH_OFF)
 		return 0;
 
-	coarse_time_short = (u16)val;
-
-	dev_dbg(dev, "%s: val: %d\n", __func__, coarse_time_short);
+	coarse_time_short = (u32)val;
 
 	imx214_get_coarse_time_short_regs(reg_list, coarse_time_short);
-	imx214_set_group_hold(priv);
+	dev_dbg(dev, "%s: val: %d\n", __func__, coarse_time_short);
 
-	for (i = 0; i < 2; i++) {
-		err  = imx214_write_reg(priv->s_data, reg_list[i].addr,
+	for (i = 0; i < 3; i++) {
+		err = imx214_write_reg(priv->s_data, reg_list[i].addr,
 			 reg_list[i].val);
 		if (err)
 			goto fail;
@@ -719,7 +912,6 @@ static int imx214_eeprom_device_release(struct imx214 *priv)
 
 static int imx214_eeprom_device_init(struct imx214 *priv)
 {
-	struct device *dev = &priv->i2c_client->dev;
 	char *dev_name = "eeprom_imx214";
 	static struct regmap_config eeprom_regmap_config = {
 		.reg_bits = 8,
@@ -727,14 +919,8 @@ static int imx214_eeprom_device_init(struct imx214 *priv)
 	};
 	int i;
 	int err;
-	struct v4l2_ctrl *ctrl;
-
-	ctrl = v4l2_ctrl_find(&priv->ctrl_handler,
-			TEGRA_CAMERA_CID_EEPROM_DATA);
-	if (!ctrl) {
-		dev_err(dev, "could not find device ctrl.\n");
+	if (!priv->pdata->has_eeprom)
 		return -EINVAL;
-	}
 
 	for (i = 0; i < IMX214_EEPROM_NUM_BLOCKS; i++) {
 		priv->eeprom[i].adap = i2c_get_adapter(
@@ -751,7 +937,6 @@ static int imx214_eeprom_device_init(struct imx214 *priv)
 		if (IS_ERR(priv->eeprom[i].regmap)) {
 			err = PTR_ERR(priv->eeprom[i].regmap);
 			imx214_eeprom_device_release(priv);
-			ctrl->flags = V4L2_CTRL_FLAG_DISABLED;
 			return err;
 		}
 	}
@@ -773,7 +958,7 @@ static int imx214_read_eeprom(struct imx214 *priv,
 	}
 
 	for (i = 0; i < IMX214_EEPROM_SIZE; i++)
-		sprintf(&ctrl->string[i*2], "%02x",
+		sprintf(&ctrl->p_new.p_char[i*2], "%02x",
 			priv->eeprom_buf[i]);
 	return 0;
 }
@@ -808,116 +993,6 @@ static int imx214_write_eeprom(struct imx214 *priv,
 	return 0;
 }
 
-static int imx214_read_otp_page(struct imx214 *priv,
-				u8 *buf, int page, u16 addr, int size)
-{
-	struct device *dev = &priv->i2c_client->dev;
-	u8 status;
-	int err;
-
-	err = imx214_write_reg(priv->s_data, IMX214_OTP_PAGE_NUM_ADDR, page);
-	if (err)
-		return err;
-	err = imx214_write_reg(priv->s_data, IMX214_OTP_CTRL_ADDR, 0x01);
-	if (err)
-		return err;
-	err = imx214_read_reg(priv->s_data, IMX214_OTP_STATUS_ADDR, &status);
-	if (err)
-		return err;
-	if (status == IMX214_OTP_STATUS_IN_PROGRESS) {
-		dev_err(dev, "another OTP read in progress\n");
-		return err;
-	}
-
-	err = regmap_bulk_read(priv->regmap, addr, buf, size);
-	if (err)
-		return err;
-
-	err = imx214_read_reg(priv->s_data, IMX214_OTP_STATUS_ADDR, &status);
-	if (err)
-		return err;
-	if (status == IMX214_OTP_STATUS_READ_FAIL) {
-		dev_err(dev, "fuse id read error\n");
-		return err;
-	}
-
-	return 0;
-}
-
-static int imx214_otp_setup(struct imx214 *priv)
-{
-	struct device *dev = &priv->i2c_client->dev;
-	int err;
-	int i;
-	struct v4l2_ctrl *ctrl;
-	u8 otp_buf[IMX214_OTP_SIZE];
-
-	err = camera_common_s_power(priv->subdev, true);
-	if (err)
-		return -ENODEV;
-
-	for (i = 0; i < IMX214_OTP_NUM_PAGES; i++) {
-		imx214_read_otp_page(priv,
-				   &otp_buf[i * IMX214_OTP_PAGE_SIZE],
-				   i,
-				   IMX214_OTP_PAGE_START_ADDR,
-				   IMX214_OTP_PAGE_SIZE);
-	}
-
-	ctrl = v4l2_ctrl_find(&priv->ctrl_handler, TEGRA_CAMERA_CID_OTP_DATA);
-	if (!ctrl) {
-		dev_err(dev, "could not find device ctrl.\n");
-		return -EINVAL;
-	}
-
-	for (i = 0; i < IMX214_OTP_SIZE; i++)
-		sprintf(&ctrl->string[i*2], "%02x",
-			otp_buf[i]);
-	ctrl->cur.string = ctrl->string;
-
-	err = camera_common_s_power(priv->subdev, false);
-	if (err)
-		return -ENODEV;
-
-	return 0;
-}
-
-static int imx214_fuse_id_setup(struct imx214 *priv)
-{
-	struct device *dev = &priv->i2c_client->dev;
-	int err;
-	int i;
-	struct v4l2_ctrl *ctrl;
-	u8 fuse_id[IMX214_FUSE_ID_SIZE];
-
-	err = camera_common_s_power(priv->subdev, true);
-	if (err)
-		return -ENODEV;
-
-	imx214_read_otp_page(priv,
-			   &fuse_id[0],
-			   IMX214_FUSE_ID_OTP_PAGE,
-			   IMX214_FUSE_ID_OTP_ROW_ADDR,
-			   IMX214_FUSE_ID_SIZE);
-
-	ctrl = v4l2_ctrl_find(&priv->ctrl_handler, TEGRA_CAMERA_CID_FUSE_ID);
-	if (!ctrl) {
-		dev_err(dev, "could not find device ctrl.\n");
-		return -EINVAL;
-	}
-
-	for (i = 0; i < IMX214_FUSE_ID_SIZE; i++)
-		sprintf(&ctrl->string[i*2], "%02x",
-			fuse_id[i]);
-	ctrl->cur.string = ctrl->string;
-
-	err = camera_common_s_power(priv->subdev, false);
-	if (err)
-		return -ENODEV;
-
-	return 0;
-}
-
 static int imx214_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct imx214 *priv =
@@ -974,9 +1049,9 @@ static int imx214_s_ctrl(struct v4l2_ctrl *ctrl)
 		}
 		break;
 	case TEGRA_CAMERA_CID_EEPROM_DATA:
-		if (!ctrl->string[0])
+		if (!ctrl->p_new.p_char[0])
 			break;
-		err = imx214_write_eeprom(priv, ctrl->string);
+		err = imx214_write_eeprom(priv, ctrl->p_new.p_char);
 		if (err)
 			return err;
 		break;
@@ -990,9 +1065,10 @@ static int imx214_s_ctrl(struct v4l2_ctrl *ctrl)
 	return err;
 }
 
-static int imx214_ctrls_init(struct imx214 *priv)
+static int imx214_ctrls_init(struct imx214 *priv, bool eeprom_ctrl)
 {
 	struct i2c_client *client = priv->i2c_client;
+	struct camera_common_data *common_data = priv->s_data;
 	struct device *dev = &client->dev;
 	struct v4l2_ctrl *ctrl;
 	int numctrls;
@@ -1005,7 +1081,18 @@ static int imx214_ctrls_init(struct imx214 *priv)
 	v4l2_ctrl_handler_init(&priv->ctrl_handler, numctrls);
 
 	for (i = 0; i < numctrls; i++) {
-		ctrl = v4l2_ctrl_new_custom(&priv->ctrl_handler,
+		/*
+		 * Skip control 'TEGRA_CAMERA_CID_EEPROM_DATA'
+		 * if eeprom inint err
+		 */
+		if (ctrl_config_list[i].id == TEGRA_CAMERA_CID_EEPROM_DATA) {
+			if (!eeprom_ctrl) {
+				common_data->numctrls -= 1;
+				continue;
+			}
+		}
+
+			ctrl = v4l2_ctrl_new_custom(&priv->ctrl_handler,
 			&ctrl_config_list[i], NULL);
 		if (ctrl == NULL) {
 			dev_err(dev, "Failed to init %s ctrl\n",
@@ -1015,12 +1102,10 @@ static int imx214_ctrls_init(struct imx214 *priv)
 
 		if (ctrl_config_list[i].type == V4L2_CTRL_TYPE_STRING &&
 			ctrl_config_list[i].flags & V4L2_CTRL_FLAG_READ_ONLY) {
-			ctrl->string = devm_kzalloc(&client->dev,
+			ctrl->p_new.p_char = devm_kzalloc(&client->dev,
 				ctrl_config_list[i].max + 1, GFP_KERNEL);
-			if (!ctrl->string) {
-				dev_err(dev, "Failed to allocate otp data\n");
+			if (!ctrl->p_new.p_char)
 				return -ENOMEM;
-			}
 		}
 		priv->ctrls[i] = ctrl;
 	}
@@ -1040,18 +1125,6 @@ static int imx214_ctrls_init(struct imx214 *priv)
 		goto error;
 	}
 
-	err = imx214_otp_setup(priv);
-	if (err) {
-		dev_err(dev, "Error %d reading otp data\n", err);
-		goto error;
-	}
-
-	err = imx214_fuse_id_setup(priv);
-	if (err) {
-		dev_err(dev, "Error %d reading fuse id data\n", err);
-		goto error;
-	}
-
 	return 0;
 
 error:
@@ -1063,9 +1136,15 @@ MODULE_DEVICE_TABLE(of, imx214_of_match);
 
 static struct camera_common_pdata *imx214_parse_dt(struct i2c_client *client)
 {
-	struct device_node *np = client->dev.of_node;
+	struct device_node *node = client->dev.of_node;
 	struct camera_common_pdata *board_priv_pdata;
 	const struct of_device_id *match;
+	int gpio;
+	int err;
+	struct camera_common_pdata *ret = NULL;
+
+	if (!node)
+		return NULL;
 
 	match = of_match_device(imx214_of_match, &client->dev);
 	if (!match) {
@@ -1075,24 +1154,62 @@ static struct camera_common_pdata *imx214_parse_dt(struct i2c_client *client)
 
 	board_priv_pdata = devm_kzalloc(&client->dev,
 			   sizeof(*board_priv_pdata), GFP_KERNEL);
-	if (!board_priv_pdata) {
-		dev_err(&client->dev, "Failed to allocate pdata\n");
+	if (!board_priv_pdata)
 		return NULL;
+
+	err = camera_common_parse_clocks(&client->dev, board_priv_pdata);
+	if (err) {
+		dev_err(&client->dev, "Failed to find clocks\n");
+		goto error;
 	}
 
-	of_property_read_string(np, "mclk", &board_priv_pdata->mclk_name);
-	board_priv_pdata->pwdn_gpio = of_get_named_gpio(np, "pwdn-gpios", 0);
-	board_priv_pdata->reset_gpio = of_get_named_gpio(np, "reset-gpios", 0);
-	board_priv_pdata->af_gpio = of_get_named_gpio(np, "af-gpios", 0);
+	gpio = of_get_named_gpio(node, "pwdn-gpios", 0);
+	if (gpio < 0) {
+		if (gpio == -EPROBE_DEFER) {
+			ret = ERR_PTR(-EPROBE_DEFER);
+			goto error;
+		}
+		dev_err(&client->dev, "pwdn gpios not in DT\n");
+		goto error;
+	}
+	board_priv_pdata->pwdn_gpio = (unsigned int)gpio;
+
+	gpio = of_get_named_gpio(node, "reset-gpios", 0);
+	if (gpio < 0) {
+		/* reset-gpio is not absolutely needed */
+		if (gpio == -EPROBE_DEFER) {
+			ret = ERR_PTR(-EPROBE_DEFER);
+			goto error;
+		}
+		dev_dbg(&client->dev, "reset gpios not in DT\n");
+		gpio = 0;
+	}
+	board_priv_pdata->reset_gpio = (unsigned int)gpio;
+	board_priv_pdata->use_cam_gpio =
+			of_property_read_bool(node, "cam,use-cam-gpio");
 
-	of_property_read_string(np, "avdd-reg",
+	err = of_property_read_string(node, "avdd-reg",
 			&board_priv_pdata->regulators.avdd);
-	of_property_read_string(np, "dvdd-reg",
+	if (err) {
+		dev_err(&client->dev, "avdd-reg not in DT\n");
+		goto error;
+	}
+	err = of_property_read_string(node, "dvdd-reg",
 			&board_priv_pdata->regulators.dvdd);
-	of_property_read_string(np, "iovdd-reg",
-			&board_priv_pdata->regulators.iovdd);
-
+	if (err) {
+			dev_err(&client->dev, "dvdd-reg not in DT\n");
+			goto error;
+		}
+	board_priv_pdata->has_eeprom =
+		of_property_read_bool(node, "has-eeprom");
+	board_priv_pdata->v_flip = of_property_read_bool(node, "vertical-flip");
+	board_priv_pdata->h_mirror = of_property_read_bool(node,
+							 "horizontal-mirror");
 	return board_priv_pdata;
+
+error:
+	devm_kfree(&client->dev, board_priv_pdata);
+	return ret;
 }
 
 static int imx214_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
@@ -1100,7 +1217,6 @@ static int imx214_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	dev_dbg(&client->dev, "%s:\n", __func__);
 
-
 	return 0;
 }
 
@@ -1134,12 +1250,11 @@ static int imx214_probe(struct i2c_client *client,
 			    sizeof(struct imx214) + sizeof(struct v4l2_ctrl *) *
 			    ARRAY_SIZE(ctrl_config_list),
 			    GFP_KERNEL);
-	if (!priv) {
-		dev_err(dev, "unable to allocate memory!\n");
+	if (!priv)
 		return -ENOMEM;
-	}
 
-	priv->regmap = devm_regmap_init_i2c(client, &sensor_regmap_config);
+
+	priv->regmap = devm_regmap_init_i2c(client, &imx214_regmap_config);
 	if (IS_ERR(priv->regmap)) {
 		dev_err(dev, "regmap init failed %ld\n", PTR_ERR(priv->regmap));
 		return -ENODEV;
@@ -1153,8 +1268,8 @@ static int imx214_probe(struct i2c_client *client,
 
 	common_data->ops		= &imx214_common_ops;
 	common_data->ctrl_handler	= &priv->ctrl_handler;
-	common_data->i2c_client		= client;
-	common_data->frmfmt		= &imx214_frmfmt[0];
+	common_data->dev		= &client->dev;
+	common_data->frmfmt		= imx214_frmfmt;
 	common_data->colorfmt		= camera_common_find_datafmt(
 					  IMX214_DEFAULT_DATAFMT);
 	common_data->ctrls		= priv->ctrls;
@@ -1187,30 +1302,29 @@ static int imx214_probe(struct i2c_client *client,
 
 	v4l2_i2c_subdev_init(priv->subdev, client, &imx214_subdev_ops);
 
-	err = imx214_ctrls_init(priv);
-	if (err)
-		return err;
-
 	/* eeprom interface */
 	err = imx214_eeprom_device_init(priv);
-	if (err)
+	if (err && priv->pdata->has_eeprom)
 		dev_err(dev, "Failed to alloc eeprom register map: %d\n", err);
+	err = imx214_ctrls_init(priv, !err);
+	if (err)
+		return err;
 
 	priv->subdev->internal_ops = &imx214_subdev_internal_ops;
 	priv->subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
 		     V4L2_SUBDEV_FL_HAS_EVENTS;
-
-#if defined(CONFIG_MEDIA_CONTROLLER)
-	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
-	priv->subdev->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
-	priv->subdev->entity.ops = &imx214_media_ops;
-	err = media_entity_init(&priv->subdev->entity, 1, &priv->pad, 0);
-	if (err < 0) {
-		dev_err(&client->dev, "unable to init media entity\n");
-		return err;
-	}
-#endif
-
+/*
+ * #if defined(CONFIG_MEDIA_CONTROLLER)
+ *	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+ *	priv->subdev->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+ *	priv->subdev->entity.ops = &imx214_media_ops;
+ *	err = media_entity_init(&priv->subdev->entity, 1, &priv->pad, 0);
+ *	if (err < 0) {
+ *		dev_err(&client->dev, "unable to init media entity\n");
+ *		return err;
+ *	}
+ * #endif
+ */
 	err = v4l2_async_register_subdev(priv->subdev);
 	if (err)
 		return err;
@@ -1223,13 +1337,14 @@ static int imx214_probe(struct i2c_client *client,
 static int
 imx214_remove(struct i2c_client *client)
 {
-	struct camera_common_data *s_data = to_camera_common_data(client);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
 	struct imx214 *priv = (struct imx214 *)s_data->priv;
 
 	v4l2_async_unregister_subdev(priv->subdev);
 #if defined(CONFIG_MEDIA_CONTROLLER)
 	media_entity_cleanup(&priv->subdev->entity);
 #endif
+
 	v4l2_ctrl_handler_free(&priv->ctrl_handler);
 	camera_common_cleanup(s_data);
 
@@ -1259,4 +1374,3 @@ module_i2c_driver(imx214_i2c_driver);
 MODULE_DESCRIPTION("SoC Camera driver for Sony IMX214");
 MODULE_AUTHOR("David Wang <davidw@nvidia.com>");
 MODULE_LICENSE("GPL v2");
-
diff --git a/drivers/media/i2c/imx214_mode_tbls.h b/drivers/media/i2c/imx214_mode_tbls.h
new file mode 100644
index 0000000..e8450e9
--- /dev/null
+++ b/drivers/media/i2c/imx214_mode_tbls.h
@@ -0,0 +1,2886 @@
+/*
+ * imx214_mode_tbls.h - imx214 sensor mode tables
+ *
+ * Copyright (c) 2015-2017, NVIDIA CORPORATION, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __IMX214_TABLES__
+#define __IMX214_TABLES__
+
+#include <media/camera_common.h>
+
+#define IMX214_TABLE_WAIT_MS	0
+#define IMX214_TABLE_END	1
+#define IMX214_MAX_RETRIES	3
+#define IMX214_WAIT_MS		100
+
+#define imx214_reg struct reg_8
+
+static const imx214_reg imx214_start[] = {
+	{0x0100, 0x01}, /* mode select streaming on */
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg imx214_stop[] = {
+	{0x0100, 0x00}, /* mode select streaming on */
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg tp_colorbars[] = {
+	{0x0600, 0xff},
+	{0x0601, 0xff},
+
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg mode_table_common[] = {
+	/* software reset */
+
+	/* software standby settings */
+	{0x0100, 0x00},
+
+	/* ATR setting */
+	{0x9300, 0x02},
+
+	/* external clock setting */
+	{0x0136, 0x18},
+	{0x0137, 0x00},
+
+	/* global setting */
+	/* basic config */
+	{0x0101, 0x00},
+	{0x0105, 0x01},
+	{0x0106, 0x01},
+	{0x4550, 0x02},
+	{0x4601, 0x00},
+	{0x4642, 0x05},
+	{0x6227, 0x11},
+	{0x6276, 0x00},
+	{0x900E, 0x06},
+	{0xA802, 0x90},
+	{0xA803, 0x11},
+	{0xA804, 0x62},
+	{0xA805, 0x77},
+	{0xA806, 0xAE},
+	{0xA807, 0x34},
+	{0xA808, 0xAE},
+	{0xA809, 0x35},
+	{0xA80A, 0x62},
+	{0xA80B, 0x83},
+	{0xAE33, 0x00},
+
+  /* analog setting */
+	{0x4174, 0x00},
+	{0x4175, 0x11},
+	{0x4612, 0x29},
+	{0x461B, 0x12},
+	{0x461F, 0x06},
+	{0x4635, 0x07},
+	{0x4637, 0x30},
+	{0x463F, 0x18},
+	{0x4641, 0x0D},
+	{0x465B, 0x12},
+	{0x465F, 0x11},
+	{0x4663, 0x11},
+	{0x4667, 0x0F},
+	{0x466F, 0x0F},
+	{0x470E, 0x09},
+	{0x4909, 0xAB},
+	{0x490B, 0x95},
+	{0x4915, 0x5D},
+	{0x4A5F, 0xFF},
+	{0x4A61, 0xFF},
+	{0x4A73, 0x62},
+	{0x4A85, 0x00},
+	{0x4A87, 0xFF},
+
+	/* embedded data */
+	{0x5041, 0x04},
+	{0x583C, 0x04},
+	{0x620E, 0x04},
+	{0x6EB2, 0x01},
+	{0x6EB3, 0x00},
+	{0x9300, 0x02},
+
+	/* imagequality */
+	/* HDR setting */
+	{0x3001, 0x07},
+	{0x6D12, 0x3F},
+	{0x6D13, 0xFF},
+	{0x9344, 0x03},
+	{0x9706, 0x10},
+	{0x9707, 0x03},
+	{0x9708, 0x03},
+	{0x9E04, 0x01},
+	{0x9E05, 0x00},
+	{0x9E0C, 0x01},
+	{0x9E0D, 0x02},
+	{0x9E24, 0x00},
+	{0x9E25, 0x8C},
+	{0x9E26, 0x00},
+	{0x9E27, 0x94},
+	{0x9E28, 0x00},
+	{0x9E29, 0x96},
+
+	/* CNR parameter setting */
+	{0x69DB, 0x01},
+
+	/* Moire reduction */
+	{0x6957, 0x01},
+
+	/* image enhancment */
+	{0x6987, 0x17},
+	{0x698A, 0x03},
+	{0x698B, 0x03},
+
+	/* white balanace */
+	{0x0B8E, 0x01},
+	{0x0B8F, 0x00},
+	{0x0B90, 0x01},
+	{0x0B91, 0x00},
+	{0x0B92, 0x01},
+	{0x0B93, 0x00},
+	{0x0B94, 0x01},
+	{0x0B95, 0x00},
+
+	/* ATR setting */
+	{0x6E50, 0x00},
+	{0x6E51, 0x32},
+	{0x9340, 0x00},
+	{0x9341, 0x3C},
+	{0x9342, 0x03},
+	{0x9343, 0xFF},
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg imx214_pll_1080mbps[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{ 0x0301, 0x05 }, // vt pixel clock divider = 5
+	{ 0x0303, 0x02 }, // vt system clock divider = 2
+	{ 0x0305, 0x03 }, // pre pll clock divider = 3
+	{ 0x0306, 0x00 }, // pll mult 10:8 = 0
+	{ 0x0307, 0x87 }, // pll mult 0:7 = 135
+	{ 0x0309, 0x0a }, // output pixel clock divider = 10
+	{ 0x030B, 0x01 }, // output system clock div = 1 .. OPCLK = 24 / 3(pre_vt) * 135(mpy_vt) / 1(op_sys_div) / 10(op_x_div) = 108MHz
+	{ 0x0310, 0x00 }, // PLL multiple driver = 0 -> 1 PLL control
+	{ 0x0820, 0x10 }, // target freq 31:24 = 16
+	{ 0x0821, 0xe0 }, // 23:16 = 224
+	{ 0x0822, 0x66 }, // 15:8 = 102
+	{ 0x0823, 0x66 }, // 7:0 = 102 ... target freq = 283141734
+	{ 0x3A03, 0x09 },
+	{ 0x3A04, 0x40 },
+	{ 0x3A05, 0x01 },
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg imx214_pll_1200mbps[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{ 0x0301, 0x05 }, // vt pixel clock divider = 5
+	{ 0x0303, 0x02 }, // vt system clock divider = 2
+	{ 0x0305, 0x03 }, // pre pll clock divider = 3
+	{ 0x0306, 0x00 }, // pll mult 10:8 = 0
+	{ 0x0307, 0x96 }, // pll mult 0:7 = 150
+	{ 0x0309, 0x0a }, // output pixel clock divider = 10
+	{ 0x030B, 0x01 }, // output system clock div = 1 .. OPCLK = 24 / 3(pre_vt) * 150(mpy_vt) / 1(op_sys_div) / 10(op_x_div) = 120MHz
+	{ 0x0310, 0x00 }, // PLL multiple driver = 0 -> 1 PLL control
+	{ 0x0820, 0x12 }, // target freq 31:24 = 18
+	{ 0x0821, 0xc0 }, // 23:16 = 192
+	{ 0x0822, 0x66 }, // 15:8 = 102
+	{ 0x0823, 0x66 }, // 7:0 = 102 ... target freq = 314599014
+	{ 0x3A03, 0x09 },
+	{ 0x3A04, 0x40 },
+	{ 0x3A05, 0x01 },
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg mode_4096x2304[] = {
+	{0x0114, 0x03},
+	{0x0220, 0x00},
+	{0x0221, 0x11},
+	{0x0222, 0x01},
+	{0x0340, 0x0C},
+	{0x0341, 0x7A},
+	{0x0342, 0x13},
+	{0x0343, 0x90},
+	{0x0344, 0x00},
+	{0x0345, 0x38},
+	{0x0346, 0x01},
+	{0x0347, 0x98},
+	{0x0348, 0x10},
+	{0x0349, 0x37},
+	{0x034A, 0x0A},
+	{0x034B, 0x97},
+	{0x0381, 0x01},
+	{0x0383, 0x01},
+	{0x0385, 0x01},
+	{0x0387, 0x01},
+	{0x0900, 0x00},
+	{0x0901, 0x00},
+	{0x0902, 0x00},
+	{0x3000, 0x35},
+	{0x3054, 0x01},
+	{0x305C, 0x11},
+
+	{0x0112, 0x0A},
+	{0x0113, 0x0A},
+	{0x034C, 0x10},
+	{0x034D, 0x00},
+	{0x034E, 0x09},
+	{0x034F, 0x00},
+	{0x0401, 0x00},
+	{0x0404, 0x00},
+	{0x0405, 0x10},
+	{0x0408, 0x00},
+	{0x0409, 0x00},
+	{0x040A, 0x00},
+	{0x040B, 0x00},
+	{0x040C, 0x10},
+	{0x040D, 0x00},
+	{0x040E, 0x09},
+	{0x040F, 0x00},
+
+	{0x0301, 0x05},
+	{0x0303, 0x02},
+	{0x0305, 0x03},
+	{0x0306, 0x00},
+	{0x0307, 0x96},
+	{0x0309, 0x0A},
+	{0x030B, 0x01},
+	{0x0310, 0x00},
+
+	{0x0820, 0x12},
+	{0x0821, 0xC0},
+	{0x0822, 0x00},
+	{0x0823, 0x00},
+
+	{0x3A03, 0x09},
+	{0x3A04, 0x50},
+	{0x3A05, 0x01},
+
+	{0x0B06, 0x01},
+	{0x30A2, 0x00},
+
+	{0x30B4, 0x00},
+
+	{0x3A02, 0xFF},
+
+	{0x3011, 0x00},
+	{0x3013, 0x01},
+
+	{0x0202, 0x0C},
+	{0x0203, 0x70},
+	{0x0224, 0x01},
+	{0x0225, 0xF4},
+
+	{0x0204, 0x00},
+	{0x0205, 0x00},
+	{0x020E, 0x01},
+	{0x020F, 0x00},
+	{0x0210, 0x01},
+	{0x0211, 0x00},
+	{0x0212, 0x01},
+	{0x0213, 0x00},
+	{0x0214, 0x01},
+	{0x0215, 0x00},
+	{0x0216, 0x00},
+	{0x0217, 0x00},
+
+	{0x4170, 0x00},
+	{0x4171, 0x10},
+	{0x4176, 0x00},
+	{0x4177, 0x3C},
+	{0xAE20, 0x04},
+	{0xAE21, 0x5C},
+
+	{IMX214_TABLE_WAIT_MS, 10},
+	{0x0138, 0x01},
+
+	/* stream on */
+	{0x0100, 0x01},
+	{IMX214_TABLE_END, 0x00}
+};
+
+//	{ 0x0103, 0x01 },
+static const imx214_reg mode_4208x3120[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{ 0x0100, 0x00 },
+	{ 0x0136, 0x18 }, /*24Mhz*/
+	{ 0x0137, 0x00 },
+	{ 0x0101, 0x00 },
+	{ 0x0105, 0x01 }, // switched from 0x01 to 0x00
+	{ 0x5041, 0x04 }, // no EMD
+	{ 0x0138, 0x01 },
+	{ 0x0106, 0x01 },
+	{ 0x4550, 0x02 },
+	{ 0x4601, 0x00 },
+	{ 0x4642, 0x05 },
+	{ 0x6227, 0x11 },
+	{ 0x6276, 0x00 },
+	{ 0x900E, 0x06 },
+	{ 0xA802, 0x90 },
+	{ 0xA803, 0x11 },
+	{ 0xA804, 0x62 },
+	{ 0xA805, 0x77 },
+	{ 0xA806, 0xAE },
+	{ 0xA807, 0x34 },
+	{ 0xA808, 0xAE },
+	{ 0xA809, 0x35 },
+	{ 0xA80A, 0x62 },
+	{ 0xA80B, 0x83 },
+	{ 0xAE33, 0x00 },
+	{ 0x4174, 0x00 },
+	{ 0x4175, 0x11 },
+	{ 0x4612, 0x29 },
+	{ 0x461B, 0x12 },
+	{ 0x461F, 0x06 },
+	{ 0x4635, 0x07 },
+	{ 0x4637, 0x30 },
+	{ 0x463F, 0x18 },
+	{ 0x4641, 0x0D },
+	{ 0x465B, 0x12 },
+	{ 0x465F, 0x11 },
+	{ 0x4663, 0x11 },
+	{ 0x4667, 0x0F },
+	{ 0x466F, 0x0F },
+	{ 0x470E, 0x09 },
+	{ 0x4909, 0xAB },
+	{ 0x490B, 0x95 },
+	{ 0x4915, 0x5D },
+	{ 0x4A5F, 0xFF },
+	{ 0x4A61, 0xFF },
+	{ 0x4A73, 0x62 },
+	{ 0x4A85, 0x00 },
+	{ 0x4A87, 0xFF },
+	{ 0x583C, 0x04 },
+	{ 0x620E, 0x04 },
+	{ 0x6EB2, 0x01 },
+	{ 0x6EB3, 0x00 },
+	{ 0x9300, 0x02 }, // end of power up
+	{ 0x0114, 0x03 },
+	{ 0x0220, 0x00 },
+	{ 0x0221, 0x11 },
+	{ 0x0222, 0x01 },
+	{ 0x0344, 0x00 },
+	{ 0x0345, 0x00 },
+	{ 0x0346, 0x00 },
+	{ 0x0347, 0x00 },
+	{ 0x0348, 0x10 },
+	{ 0x0349, 0x6F },
+	{ 0x034A, 0x0C },
+	{ 0x034B, 0x2F },
+	{ 0x0381, 0x01 },
+	{ 0x0383, 0x01 },
+	{ 0x0385, 0x01 },
+	{ 0x0387, 0x01 },
+	{ 0x0900, 0x00 },
+	{ 0x0901, 0x00 },
+	{ 0x0902, 0x00 },
+	{ 0x3000, 0x35 },
+	{ 0x3054, 0x01 },
+	{ 0x305C, 0x11 },
+	{ 0x034C, 0x10 },
+	{ 0x034D, 0x70 },
+	{ 0x034E, 0x0C },
+	{ 0x034F, 0x30 },
+	{ 0x0401, 0x00 },
+	{ 0x0404, 0x00 },
+	{ 0x0405, 0x10 },
+	{ 0x0408, 0x00 },
+	{ 0x0409, 0x00 },
+	{ 0x040A, 0x00 },
+	{ 0x040B, 0x00 },
+	{ 0x040C, 0x10 },
+	{ 0x040D, 0x70 },
+	{ 0x040E, 0x0C },
+	{ 0x040F, 0x30 },
+	{ 0x3A03, 0x09 },
+	{ 0x3A04, 0x40 },
+	{ 0x3A05, 0x01 },
+	{ 0x0B06, 0x01 },
+	{ 0x30A2, 0x00 },
+	{ 0x30B4, 0x00 },
+	{ 0x3A02, 0xFF },
+	{ 0x3011, 0x00 },
+	{ 0x3013, 0x01 },
+	{ 0x0224, 0x01 },
+	{ 0x0225, 0xF4 },
+	{ 0x020E, 0x01 },
+	{ 0x020F, 0x00 },
+	{ 0x0210, 0x01 },
+	{ 0x0211, 0x00 },
+	{ 0x0212, 0x01 },
+	{ 0x0213, 0x00 },
+	{ 0x0214, 0x01 },
+	{ 0x0215, 0x00 },
+	{ 0x0216, 0x00 },
+	{ 0x0217, 0x00 },
+	{ 0x4170, 0x00 },
+	{ 0x4171, 0x10 },
+	{ 0x4176, 0x00 },
+	{ 0x4177, 0x3C },
+	{ 0xAE20, 0x04 },
+	{ 0xAE21, 0x5C },
+	{ 0x0138, 0x01 },
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg mode_2104x1560[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{ 0x0100, 0x00 },
+	{ 0x0136, 0x18 }, /*24Mhz*/
+	{ 0x0137, 0x00 },
+	{ 0x0101, 0x00 },
+	{ 0x0105, 0x01 }, // switched from 0x01 to 0x00
+	{ 0x5041, 0x04 }, // no EMD
+	{ 0x0138, 0x01 },
+	{ 0x0106, 0x01 },
+	{ 0x4550, 0x02 },
+	{ 0x4601, 0x00 },
+	{ 0x4642, 0x05 },
+	{ 0x6227, 0x11 },
+	{ 0x6276, 0x00 },
+	{ 0x900E, 0x06 },
+	{ 0xA802, 0x90 },
+	{ 0xA803, 0x11 },
+	{ 0xA804, 0x62 },
+	{ 0xA805, 0x77 },
+	{ 0xA806, 0xAE },
+	{ 0xA807, 0x34 },
+	{ 0xA808, 0xAE },
+	{ 0xA809, 0x35 },
+	{ 0xA80A, 0x62 },
+	{ 0xA80B, 0x83 },
+	{ 0xAE33, 0x00 },
+	{ 0x4174, 0x00 },
+	{ 0x4175, 0x11 },
+	{ 0x4612, 0x29 },
+	{ 0x461B, 0x12 },
+	{ 0x461F, 0x06 },
+	{ 0x4635, 0x07 },
+	{ 0x4637, 0x30 },
+	{ 0x463F, 0x18 },
+	{ 0x4641, 0x0D },
+	{ 0x465B, 0x12 },
+	{ 0x465F, 0x11 },
+	{ 0x4663, 0x11 },
+	{ 0x4667, 0x0F },
+	{ 0x466F, 0x0F },
+	{ 0x470E, 0x09 },
+	{ 0x4909, 0xAB },
+	{ 0x490B, 0x95 },
+	{ 0x4915, 0x5D },
+	{ 0x4A5F, 0xFF },
+	{ 0x4A61, 0xFF },
+	{ 0x4A73, 0x62 },
+	{ 0x4A85, 0x00 },
+	{ 0x4A87, 0xFF },
+	{ 0x583C, 0x04 },
+	{ 0x620E, 0x04 },
+	{ 0x6EB2, 0x01 },
+	{ 0x6EB3, 0x00 },
+	{ 0x9300, 0x02 }, // end of power up
+	{ 0x0114, 0x03 },
+	{ 0x0220, 0x00 },
+	{ 0x0221, 0x11 },
+	{ 0x0222, 0x01 },
+	{ 0x0344, 0x00 },
+	{ 0x0345, 0x00 },
+	{ 0x0346, 0x00 },
+	{ 0x0347, 0x00 },
+	{ 0x0348, 0x10 },
+	{ 0x0349, 0x6F },
+	{ 0x034A, 0x0C },
+	{ 0x034B, 0x2F },
+	{ 0x0381, 0x01 },
+	{ 0x0383, 0x01 },
+	{ 0x0385, 0x01 },
+	{ 0x0387, 0x01 },
+	{ 0x0900, 0x01 },
+	{ 0x0901, 0x22 },
+	{ 0x0902, 0x02 },
+	{ 0x3000, 0x35 },
+	{ 0x3054, 0x01 },
+	{ 0x305C, 0x11 },
+	{ 0x034C, 0x08 },
+	{ 0x034D, 0x38 },
+	{ 0x034E, 0x06 },
+	{ 0x034F, 0x18 },
+	{ 0x0401, 0x00 },
+	{ 0x0404, 0x00 },
+	{ 0x0405, 0x10 },
+	{ 0x0408, 0x00 },
+	{ 0x0409, 0x00 },
+	{ 0x040A, 0x00 },
+	{ 0x040B, 0x00 },
+	{ 0x040C, 0x08 },
+	{ 0x040D, 0x38 },
+	{ 0x040E, 0x06 },
+	{ 0x040F, 0x18 },
+	{ 0x0B06, 0x01 },
+	{ 0x30A2, 0x00 },
+	{ 0x30B4, 0x00 },
+	{ 0x3A02, 0xFF },
+	{ 0x3011, 0x00 },
+	{ 0x3013, 0x01 },
+	{ 0x0224, 0x01 },
+	{ 0x0225, 0xF4 },
+	{ 0x020E, 0x01 },
+	{ 0x020F, 0x00 },
+	{ 0x0210, 0x01 },
+	{ 0x0211, 0x00 },
+	{ 0x0212, 0x01 },
+	{ 0x0213, 0x00 },
+	{ 0x0214, 0x01 },
+	{ 0x0215, 0x00 },
+	{ 0x0216, 0x00 },
+	{ 0x0217, 0x00 },
+	{ 0x4170, 0x00 },
+	{ 0x4171, 0x10 },
+	{ 0x4176, 0x00 },
+	{ 0x4177, 0x3C },
+	{ 0xAE20, 0x04 },
+	{ 0xAE21, 0x5C },
+	{ 0x0138, 0x01 },
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg mode_1920x1080[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{ 0x0100, 0x00 },
+	{ 0x0136, 0x18 }, /*24Mhz*/
+	{ 0x0137, 0x00 },
+	{ 0x0101, 0x00 },
+	{ 0x0105, 0x01 }, // switched from 0x01 to 0x00
+	{ 0x5041, 0x04 }, // no EMD
+	{ 0x0138, 0x01 },
+	{ 0x0106, 0x01 },
+	{ 0x4550, 0x02 },
+	{ 0x4601, 0x00 },
+	{ 0x4642, 0x05 },
+	{ 0x6227, 0x11 },
+	{ 0x6276, 0x00 },
+	{ 0x900E, 0x06 },
+	{ 0xA802, 0x90 },
+	{ 0xA803, 0x11 },
+	{ 0xA804, 0x62 },
+	{ 0xA805, 0x77 },
+	{ 0xA806, 0xAE },
+	{ 0xA807, 0x34 },
+	{ 0xA808, 0xAE },
+	{ 0xA809, 0x35 },
+	{ 0xA80A, 0x62 },
+	{ 0xA80B, 0x83 },
+	{ 0xAE33, 0x00 },
+	{ 0x4174, 0x00 },
+	{ 0x4175, 0x11 },
+	{ 0x4612, 0x29 },
+	{ 0x461B, 0x12 },
+	{ 0x461F, 0x06 },
+	{ 0x4635, 0x07 },
+	{ 0x4637, 0x30 },
+	{ 0x463F, 0x18 },
+	{ 0x4641, 0x0D },
+	{ 0x465B, 0x12 },
+	{ 0x465F, 0x11 },
+	{ 0x4663, 0x11 },
+	{ 0x4667, 0x0F },
+	{ 0x466F, 0x0F },
+	{ 0x470E, 0x09 },
+	{ 0x4909, 0xAB },
+	{ 0x490B, 0x95 },
+	{ 0x4915, 0x5D },
+	{ 0x4A5F, 0xFF },
+	{ 0x4A61, 0xFF },
+	{ 0x4A73, 0x62 },
+	{ 0x4A85, 0x00 },
+	{ 0x4A87, 0xFF },
+	{ 0x583C, 0x04 },
+	{ 0x620E, 0x04 },
+	{ 0x6EB2, 0x01 },
+	{ 0x6EB3, 0x00 },
+	{ 0x9300, 0x02 }, // end of power up
+	{ 0x0114, 0x03 },
+	{ 0x0220, 0x00 },
+	{ 0x0221, 0x11 },
+	{ 0x0222, 0x01 },
+	{ 0x0344, 0x00 }, // image size
+	{ 0x0345, 0xB8 },
+	{ 0x0346, 0x01 },
+	{ 0x0347, 0xE0 },
+	{ 0x0348, 0x0F },
+	{ 0x0349, 0xB7 },
+	{ 0x034A, 0x0A },
+	{ 0x034B, 0x4F },
+	{ 0x0381, 0x01 },
+	{ 0x0383, 0x01 },
+	{ 0x0385, 0x01 },
+	{ 0x0387, 0x01 },
+	{ 0x0900, 0x01 }, // 2x2 binning
+	{ 0x0901, 0x22 },
+	{ 0x0902, 0x02 },
+	{ 0x3000, 0x35 },
+	{ 0x3054, 0x01 },
+	{ 0x305C, 0x11 },
+	{ 0x034C, 0x07 },
+	{ 0x034D, 0x80 },
+	{ 0x034E, 0x04 },
+	{ 0x034F, 0x38 },
+	{ 0x0401, 0x00 },
+	{ 0x0404, 0x00 },
+	{ 0x0405, 0x10 },
+	{ 0x0408, 0x00 },
+	{ 0x0409, 0x00 },
+	{ 0x040A, 0x00 },
+	{ 0x040B, 0x00 },
+	{ 0x040C, 0x07 },
+	{ 0x040D, 0x80 },
+	{ 0x040E, 0x04 },
+	{ 0x040F, 0x38 },
+	{ 0x3A03, 0x08 },
+	{ 0x3A04, 0x68 },
+	{ 0x3A05, 0x01 },
+	{ 0x0B06, 0x01 },
+	{ 0x30A2, 0x00 },
+	{ 0x30B4, 0x00 },
+	{ 0x3A02, 0xFF },
+	{ 0x3011, 0x00 },
+	{ 0x3013, 0x01 },
+	{ 0x0224, 0x01 },
+	{ 0x0225, 0xF4 },
+	{ 0x020E, 0x01 },
+	{ 0x020F, 0x00 },
+	{ 0x0210, 0x01 },
+	{ 0x0211, 0x00 },
+	{ 0x0212, 0x01 },
+	{ 0x0213, 0x00 },
+	{ 0x0214, 0x01 },
+	{ 0x0215, 0x00 },
+	{ 0x0216, 0x00 },
+	{ 0x0217, 0x00 },
+	{ 0x4170, 0x00 },
+	{ 0x4171, 0x10 },
+	{ 0x4176, 0x00 },
+	{ 0x4177, 0x3C },
+	{ 0xAE20, 0x04 },
+	{ 0xAE21, 0x5C },
+	{ 0x0138, 0x01 },
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg mode_1280x720[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{ 0x0100, 0x00 },
+	{ 0x0136, 0x18 }, /*24Mhz*/
+	{ 0x0137, 0x00 },
+	{ 0x0101, 0x00 },
+	{ 0x0105, 0x01 }, // switched from 0x01 to 0x00
+	{ 0x5041, 0x04 }, // no EMD
+	{ 0x0138, 0x01 },
+	{ 0x0106, 0x01 },
+	{ 0x4550, 0x02 },
+	{ 0x4601, 0x00 },
+	{ 0x4642, 0x05 },
+	{ 0x6227, 0x11 },
+	{ 0x6276, 0x00 },
+	{ 0x900E, 0x06 },
+	{ 0xA802, 0x90 },
+	{ 0xA803, 0x11 },
+	{ 0xA804, 0x62 },
+	{ 0xA805, 0x77 },
+	{ 0xA806, 0xAE },
+	{ 0xA807, 0x34 },
+	{ 0xA808, 0xAE },
+	{ 0xA809, 0x35 },
+	{ 0xA80A, 0x62 },
+	{ 0xA80B, 0x83 },
+	{ 0xAE33, 0x00 },
+	{ 0x4174, 0x00 },
+	{ 0x4175, 0x11 },
+	{ 0x4612, 0x29 },
+	{ 0x461B, 0x12 },
+	{ 0x461F, 0x06 },
+	{ 0x4635, 0x07 },
+	{ 0x4637, 0x30 },
+	{ 0x463F, 0x18 },
+	{ 0x4641, 0x0D },
+	{ 0x465B, 0x12 },
+	{ 0x465F, 0x11 },
+	{ 0x4663, 0x11 },
+	{ 0x4667, 0x0F },
+	{ 0x466F, 0x0F },
+	{ 0x470E, 0x09 },
+	{ 0x4909, 0xAB },
+	{ 0x490B, 0x95 },
+	{ 0x4915, 0x5D },
+	{ 0x4A5F, 0xFF },
+	{ 0x4A61, 0xFF },
+	{ 0x4A73, 0x62 },
+	{ 0x4A85, 0x00 },
+	{ 0x4A87, 0xFF },
+	{ 0x583C, 0x04 },
+	{ 0x620E, 0x04 },
+	{ 0x6EB2, 0x01 },
+	{ 0x6EB3, 0x00 },
+	{ 0x9300, 0x02 }, // end of power up
+	{ 0x0114, 0x03 },
+	{ 0x0220, 0x00 },
+	{ 0x0221, 0x11 },
+	{ 0x0222, 0x01 },
+    { 0x0344, 0x05 }, // image size
+	{ 0x0345, 0xB8 },
+	{ 0x0346, 0x04 },
+	{ 0x0347, 0xB0 },
+	{ 0x0348, 0x0A },
+	{ 0x0349, 0xB7 },
+	{ 0x034A, 0x07 },
+	{ 0x034B, 0x7F },
+	{ 0x0381, 0x01 },
+	{ 0x0383, 0x01 },
+	{ 0x0385, 0x01 },
+	{ 0x0387, 0x01 },
+	{ 0x0900, 0x00 }, // no binning
+	{ 0x0901, 0x00 },
+	{ 0x0902, 0x00 },
+	{ 0x3000, 0x35 },
+	{ 0x3054, 0x01 },
+	{ 0x305C, 0x11 },
+	{ 0x034C, 0x05 },
+	{ 0x034D, 0x00 },
+	{ 0x034E, 0x02 },
+	{ 0x034F, 0xD0 },
+	{ 0x0401, 0x00 },
+	{ 0x0404, 0x00 },
+	{ 0x0405, 0x10 },
+	{ 0x0408, 0x00 },
+	{ 0x0409, 0x00 },
+	{ 0x040A, 0x00 },
+	{ 0x040B, 0x00 },
+	{ 0x040C, 0x05 },
+	{ 0x040D, 0x00 },
+	{ 0x040E, 0x02 },
+	{ 0x040F, 0xD0 },
+	{ 0x3A03, 0x02 },
+	{ 0x3A04, 0xF8 },
+	{ 0x3A05, 0x00 },
+	{ 0x0B06, 0x01 },
+	{ 0x30A2, 0x00 },
+	{ 0x30B4, 0x00 },
+	{ 0x3A02, 0xFF },
+	{ 0x3011, 0x00 },
+	{ 0x3013, 0x01 },
+	{ 0x0224, 0x01 },
+	{ 0x0225, 0xF4 },
+	{ 0x020E, 0x01 },
+	{ 0x020F, 0x00 },
+	{ 0x0210, 0x01 },
+	{ 0x0211, 0x00 },
+	{ 0x0212, 0x01 },
+	{ 0x0213, 0x00 },
+	{ 0x0214, 0x01 },
+	{ 0x0215, 0x00 },
+	{ 0x0216, 0x00 },
+	{ 0x0217, 0x00 },
+	{ 0x4170, 0x00 },
+	{ 0x4171, 0x10 },
+	{ 0x4176, 0x00 },
+	{ 0x4177, 0x3C },
+	{ 0xAE20, 0x04 },
+	{ 0xAE21, 0x5C },
+	{ 0x0138, 0x01 },
+	{IMX214_TABLE_END, 0x00},
+};
+
+static const imx214_reg mode_2592x1944[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3090, 0x02},
+	{0x3091, 0x0e},
+	{0x3092, 0x00},
+	{0x3093, 0x00},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x18},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x02},
+	{0x3802, 0x00},
+	{0x3803, 0x02},
+	{0x3804, 0x0a},
+	{0x3805, 0x41},
+	{0x3806, 0x07},
+	{0x3807, 0xa5},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x07},
+	{0x380b, 0x98},
+	{0x380c, 0x0a},
+	{0x380d, 0x80},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x1e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3d00, 0x00},
+	{0x3d01, 0x00},
+	{0x3d02, 0x00},
+	{0x3d03, 0x00},
+	{0x3d04, 0x00},
+	{0x3d05, 0x00},
+	{0x3d06, 0x00},
+	{0x3d07, 0x00},
+	{0x3d08, 0x00},
+	{0x3d09, 0x00},
+	{0x3d0a, 0x00},
+	{0x3d0b, 0x00},
+	{0x3d0c, 0x00},
+	{0x3d0d, 0x00},
+	{0x3d0e, 0x00},
+	{0x3d0f, 0x00},
+	{0x3d80, 0x00},
+	{0x3d81, 0x00},
+	{0x3d84, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{IMX214_TABLE_END, 0x0000}
+};
+
+static const imx214_reg mode_2592x1458[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3400, 0x04},
+	{0x3401, 0x00},
+	{0x3402, 0x04},
+	{0x3403, 0x00},
+	{0x3404, 0x04},
+	{0x3405, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3600, 0xbc},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x44},
+	{0x3621, 0xb5},
+	{0x3622, 0x0c},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0xf4},
+	{0x3804, 0x0a},
+	{0x3805, 0x3f},
+	{0x3806, 0x06},
+	{0x3807, 0xb1},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x05},
+	{0x380b, 0xb2},
+	{0x380c, 0x0a},
+	{0x380d, 0x80},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x10},
+	{0x3812, 0x00},
+	{0x3813, 0x06},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x1e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0xfc},
+	{0x5781, 0x13},
+	{0x5782, 0x03},
+	{0x5786, 0x20},
+	{0x5787, 0x40},
+	{0x5788, 0x08},
+	{0x5789, 0x08},
+	{0x578a, 0x02},
+	{0x578b, 0x01},
+	{0x578c, 0x01},
+	{0x578d, 0x0c},
+	{0x578e, 0x02},
+	{0x578f, 0x01},
+	{0x5790, 0x01},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{IMX214_TABLE_END, 0x0000}
+};
+
+static const imx214_reg mode_1920x1080_old[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{0x0100, 0x00},/*, 0xIncluding, 0xsw, 0xreset, 0x*/
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0xf8},
+	{0x3804, 0x0a},
+	{0x3805, 0x3f},
+	{0x3806, 0x06},
+	{0x3807, 0xab},
+	{0x3808, 0x07},
+	{0x3809, 0x80},
+	{0x380a, 0x04},
+	{0x380b, 0x38},
+	{0x380c, 0x0a},
+	{0x380d, 0x80},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x1e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x80},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{IMX214_TABLE_END, 0x0000}
+};
+
+static const imx214_reg mode_1280x720_120fps[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x2e},
+	{0x3502, 0x80},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe6},
+	{0x3709, 0xc7},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0xf4},
+	{0x3804, 0x0a},
+	{0x3805, 0x3f},
+	{0x3806, 0x06},
+	{0x3807, 0xab},
+	{0x3808, 0x05},
+	{0x3809, 0x00},
+	{0x380a, 0x02},
+	{0x380b, 0xd0},
+	{0x380c, 0x06},
+	{0x380d, 0xd8},
+	{0x380e, 0x02},
+	{0x380f, 0xf8},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x31},
+	{0x3815, 0x31},
+	{0x3820, 0x04},
+	{0x3821, 0x1f},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x00},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{IMX214_TABLE_END, 0x0000}
+};
+
+static const imx214_reg mode_2592x1944_HDR_24fps[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x0103, 0x01},
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x02},
+	{0x3099, 0x16},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30b2, 0x00},
+	{0x30b3, 0x6e},
+	{0x30b4, 0x03},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x80},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x01},
+	{0x3508, 0x80},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x05},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xa8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x0c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x02},
+	{0x3802, 0x00},
+	{0x3803, 0x06},
+	{0x3804, 0x0a},
+	{0x3805, 0x41},
+	{0x3806, 0x07},
+	{0x3807, 0xa1},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x07},
+	{0x380b, 0x98},
+	{0x380c, 0x0e},
+	{0x380d, 0x70},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x10},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x9e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x09},
+	{0x3a05, 0xa9},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{IMX214_TABLE_END, 0x0000}
+};
+
+static const imx214_reg mode_1920x1080_HDR_30fps[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x0103, 0x01},
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x72},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x01},
+	{0x3508, 0x80},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x01},
+	{0x3801, 0x70},
+	{0x3802, 0x01},
+	{0x3803, 0xbc},
+	{0x3804, 0x09},
+	{0x3805, 0x0f},
+	{0x3806, 0x05},
+	{0x3807, 0xff},
+	{0x3808, 0x07},
+	{0x3809, 0x80},
+	{0x380a, 0x04},
+	{0x380b, 0x38},
+	{0x380c, 0x0b},
+	{0x380d, 0x40},
+	{0x380e, 0x07},
+	{0x380f, 0x3a},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x9e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x09},
+	{0x3a05, 0xa9},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{IMX214_TABLE_END, 0x0000}
+};
+
+static const imx214_reg mode_1280x720_HDR_60fps[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x0103, 0x01},
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x39},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x01},
+	{0x3508, 0x80},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x02},
+	{0x3801, 0xa8},
+	{0x3802, 0x02},
+	{0x3803, 0x68},
+	{0x3804, 0x07},
+	{0x3805, 0xb7},
+	{0x3806, 0x05},
+	{0x3807, 0x3b},
+	{0x3808, 0x05},
+	{0x3809, 0x00},
+	{0x380a, 0x02},
+	{0x380b, 0xd0},
+	{0x380c, 0x0b},
+	{0x380d, 0x40},
+	{0x380e, 0x03},
+	{0x380f, 0x9e},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x9e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x09},
+	{0x3a05, 0xa9},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{IMX214_TABLE_END, 0x0000}
+};
+
+static const imx214_reg mode_2592x1944_one_lane_15fps[] = {
+	{0x0100, 0x00},/* Including sw reset */
+	{0x0103, 0x01},
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x11},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x28},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x05},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x64},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3400, 0x04},
+	{0x3401, 0x00},
+	{0x3402, 0x04},
+	{0x3403, 0x00},
+	{0x3404, 0x04},
+	{0x3405, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x20},
+	{0x3600, 0xbc},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x44},
+	{0x3621, 0xb5},
+	{0x3622, 0x0c},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x0a},
+	{0x3805, 0x3f},
+	{0x3806, 0x07},
+	{0x3807, 0xa3},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x07},
+	{0x380b, 0x98},
+	{0x380c, 0x0a},
+	{0x380d, 0x80},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x1e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x2c},
+	{0x4831, 0x64},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0xfc},
+	{0x5781, 0x13},
+	{0x5782, 0x03},
+	{0x5786, 0x20},
+	{0x5787, 0x40},
+	{0x5788, 0x08},
+	{0x5789, 0x08},
+	{0x578a, 0x02},
+	{0x578b, 0x01},
+	{0x578c, 0x01},
+	{0x578d, 0x0c},
+	{0x578e, 0x02},
+	{0x578f, 0x01},
+	{0x5790, 0x01},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{0x0100, 0x01},
+	{0x3810, 0x00},
+	{0x3811, 0x10},
+	{0x3812, 0x00},
+	{0x3813, 0x06},
+	{IMX214_TABLE_END, 0x0000}
+};
+
+enum {
+	IMX214_MODE_4208X3120,
+	IMX214_MODE_2104X1560,
+	IMX214_MODE_1920X1080,
+	IMX214_MODE_1280X720,
+
+	IMX214_MODE_START_STREAM,
+	IMX214_MODE_STOP_STREAM,
+	IMX214_MODE_TEST_PATTERN
+};
+
+static const imx214_reg *mode_table[] = {
+	[IMX214_MODE_4208X3120]			= mode_4208x3120,
+	[IMX214_MODE_2104X1560]			= mode_2104x1560,
+	[IMX214_MODE_1920X1080]			= mode_1920x1080,
+	[IMX214_MODE_1280X720]			= mode_1280x720,
+
+	[IMX214_MODE_START_STREAM]		= imx214_start,
+	[IMX214_MODE_STOP_STREAM]		= imx214_stop,
+	[IMX214_MODE_TEST_PATTERN]		= tp_colorbars,
+};
+
+static const int imx214_15fps[] = {
+	15,
+};
+
+static const int imx214_24fps[] = {
+	24,
+};
+
+static const int imx214_30fps[] = {
+	30,
+};
+
+static const int imx214_60fps[] = {
+	60,
+};
+
+static const int imx214_120fps[] = {
+	120,
+};
+
+static const struct camera_common_frmfmt imx214_frmfmt[] = {
+	{{4208, 3120},	imx214_30fps,	1, 0,	IMX214_MODE_4208X3120},
+	{{2104, 1560},	imx214_30fps,	1, 0,	IMX214_MODE_2104X1560},
+	{{1920, 1080},	imx214_60fps,	1, 0,	IMX214_MODE_1920X1080},
+	{{1280, 720},	imx214_30fps,	1, 0,	IMX214_MODE_1280X720},
+};
+#endif  /* __IMX214_TABLES__ */
diff --git a/drivers/media/i2c/ov5640.c b/drivers/media/i2c/ov5640.c
new file mode 100644
index 0000000..c8cbb15
--- /dev/null
+++ b/drivers/media/i2c/ov5640.c
@@ -0,0 +1,1557 @@
+/*
+ * ov5640_v4l2.c - ov5640 sensor driver
+ *
+ * Copyright (c) 2013-2017, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#define DEBUG
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+
+#include <linux/seq_file.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+
+#include <media/tegra-v4l2-camera.h>
+#include <media/camera_common.h>
+#include <media/ov5640.h>
+
+#include "../platform/tegra/camera/camera_gpio.h"
+
+#include "ov5640_mode_tbls.h"
+
+#define OV5640_MAX_COARSE_DIFF		6
+
+#define OV5640_GAIN_SHIFT		8
+#define OV5640_MIN_GAIN		(1 << OV5640_GAIN_SHIFT)
+#define OV5640_MAX_GAIN		(16 << OV5640_GAIN_SHIFT)
+#define OV5640_MAX_UNREAL_GAIN	(0x0F80)
+#define OV5640_MIN_FRAME_LENGTH	(0x0)
+#define OV5640_MAX_FRAME_LENGTH	(0x7fff)
+#define OV5640_MIN_EXPOSURE_COARSE	(0x0002)
+#define OV5640_MAX_EXPOSURE_COARSE	\
+	(OV5640_MAX_FRAME_LENGTH-OV5640_MAX_COARSE_DIFF)
+
+#define OV5640_DEFAULT_LINE_LENGTH	(0x9c4)
+// #define OV5640_DEFAULT_PIXEL_CLOCK	(168)
+//#define OV5640_DEFAULT_PIXEL_CLOCK	(84)
+#define OV5640_DEFAULT_PIXEL_CLOCK	(420)
+
+#define OV5640_DEFAULT_GAIN		OV5640_MIN_GAIN
+#define OV5640_DEFAULT_FRAME_LENGTH	(0x0460)
+#define OV5640_DEFAULT_EXPOSURE_COARSE	\
+	(OV5640_DEFAULT_FRAME_LENGTH-OV5640_MAX_COARSE_DIFF)
+
+#define OV5640_DEFAULT_MODE	OV5640_MODE_1920X1080
+//#define OV5640_DEFAULT_HDR_MODE	OV5640_MODE_2592X1944_HDR
+#define OV5640_DEFAULT_WIDTH	1920
+#define OV5640_DEFAULT_HEIGHT	1080
+//#define OV5640_DEFAULT_DATAFMT	MEDIA_BUS_FMT_UYVY8_2X8
+#define OV5640_DEFAULT_DATAFMT	MEDIA_BUS_FMT_SBGGR10_1X10
+#define OV5640_DEFAULT_CLK_FREQ	24000000
+
+struct ov5640 {
+	struct camera_common_power_rail	power;
+	int				numctrls;
+	struct v4l2_ctrl_handler	ctrl_handler;
+	struct camera_common_eeprom_data eeprom[OV5640_EEPROM_NUM_BLOCKS];
+	u8				eeprom_buf[OV5640_EEPROM_SIZE];
+	struct i2c_client		*i2c_client;
+	struct v4l2_subdev		*subdev;
+	struct media_pad		pad;
+
+	s32				group_hold_prev;
+	u32				frame_length;
+	bool				group_hold_en;
+	struct regmap			*regmap;
+	struct camera_common_data	*s_data;
+	struct camera_common_pdata	*pdata;
+	struct v4l2_ctrl		*ctrls[];
+};
+
+static struct regmap_config ov5640_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+};
+
+static int ov5640_g_volatile_ctrl(struct v4l2_ctrl *ctrl);
+static int ov5640_s_ctrl(struct v4l2_ctrl *ctrl);
+static void ov5640_update_ctrl_range(struct ov5640 *priv, s32 frame_length);
+
+static const struct v4l2_ctrl_ops ov5640_ctrl_ops = {
+	.g_volatile_ctrl = ov5640_g_volatile_ctrl,
+	.s_ctrl		= ov5640_s_ctrl,
+};
+
+static struct v4l2_ctrl_config ctrl_config_list[] = {
+/* Do not change the name field for the controls! */
+	{
+		.ops = &ov5640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GAIN,
+		.name = "Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = OV5640_MIN_GAIN,
+		.max = OV5640_MAX_GAIN,
+		.def = OV5640_DEFAULT_GAIN,
+		.step = 1,
+	},
+	{
+		.ops = &ov5640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_FRAME_LENGTH,
+		.name = "Frame Length",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = OV5640_MIN_FRAME_LENGTH,
+		.max = OV5640_MAX_FRAME_LENGTH,
+		.def = OV5640_DEFAULT_FRAME_LENGTH,
+		.step = 1,
+	},
+	{
+		.ops = &ov5640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_COARSE_TIME,
+		.name = "Coarse Time",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = OV5640_MIN_EXPOSURE_COARSE,
+		.max = OV5640_MAX_EXPOSURE_COARSE,
+		.def = OV5640_DEFAULT_EXPOSURE_COARSE,
+		.step = 1,
+	},
+	{
+		.ops = &ov5640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_COARSE_TIME_SHORT,
+		.name = "Coarse Time Short",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = OV5640_MIN_EXPOSURE_COARSE,
+		.max = OV5640_MAX_EXPOSURE_COARSE,
+		.def = OV5640_DEFAULT_EXPOSURE_COARSE,
+		.step = 1,
+	},
+	{
+		.ops = &ov5640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GROUP_HOLD,
+		.name = "Group Hold",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &ov5640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_HDR_EN,
+		.name = "HDR enable",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &ov5640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_EEPROM_DATA,
+		.name = "EEPROM Data",
+		.type = V4L2_CTRL_TYPE_STRING,
+		.flags = V4L2_CTRL_FLAG_VOLATILE,
+		.min = 0,
+		.max = OV5640_EEPROM_STR_SIZE,
+		.step = 2,
+	},
+	{
+		.ops = &ov5640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_OTP_DATA,
+		.name = "OTP Data",
+		.type = V4L2_CTRL_TYPE_STRING,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY,
+		.min = 0,
+		.max = OV5640_OTP_STR_SIZE,
+		.step = 2,
+	},
+	{
+		.ops = &ov5640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_FUSE_ID,
+		.name = "Fuse ID",
+		.type = V4L2_CTRL_TYPE_STRING,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY,
+		.min = 0,
+		.max = OV5640_FUSE_ID_STR_SIZE,
+		.step = 2,
+	},
+};
+
+static inline void ov5640_get_frame_length_regs(ov5640_reg *regs,
+				u32 frame_length)
+{
+	regs->addr = OV5640_FRAME_LENGTH_ADDR_MSB;
+	regs->val = (frame_length >> 8) & 0xff;
+	(regs + 1)->addr = OV5640_FRAME_LENGTH_ADDR_LSB;
+	(regs + 1)->val = (frame_length) & 0xff;
+}
+
+
+static inline void ov5640_get_coarse_time_regs(ov5640_reg *regs,
+				u32 coarse_time)
+{
+	regs->addr = OV5640_COARSE_TIME_ADDR_1;
+	regs->val = (coarse_time >> 12) & 0xff;
+	(regs + 1)->addr = OV5640_COARSE_TIME_ADDR_2;
+	(regs + 1)->val = (coarse_time >> 4) & 0xff;
+	(regs + 2)->addr = OV5640_COARSE_TIME_ADDR_3;
+	(regs + 2)->val = (coarse_time & 0xf) << 4;
+}
+
+static inline void ov5640_get_coarse_time_short_regs(ov5640_reg *regs,
+				u32 coarse_time)
+{
+	regs->addr = OV5640_COARSE_TIME_SHORT_ADDR_1;
+	regs->val = (coarse_time >> 12) & 0xff;
+	(regs + 1)->addr = OV5640_COARSE_TIME_SHORT_ADDR_2;
+	(regs + 1)->val = (coarse_time >> 4) & 0xff;
+	(regs + 2)->addr = OV5640_COARSE_TIME_SHORT_ADDR_3;
+	(regs + 2)->val = (coarse_time & 0xf) << 4;
+}
+
+static inline void ov5640_get_gain_regs(ov5640_reg *regs,
+				u16 gain)
+{
+	regs->addr = OV5640_GAIN_ADDR_MSB;
+	regs->val = (gain >> 8) & 0xff;
+
+	(regs + 1)->addr = OV5640_GAIN_ADDR_LSB;
+	(regs + 1)->val = (gain) & 0xff;
+}
+
+static int test_mode;
+module_param(test_mode, int, 0644);
+
+static inline int ov5640_read_reg(struct camera_common_data *s_data,
+				u16 addr, u8 *val)
+{
+	struct ov5640 *priv = (struct ov5640 *)s_data->priv;
+	int err = 0;
+	u32 reg_val = 0;
+
+	err = regmap_read(priv->regmap, addr, &reg_val);
+	*val = reg_val & 0xFF;
+
+	return err;
+}
+
+static int ov5640_write_reg(struct camera_common_data *s_data, u16 addr, u8 val)
+{
+	int err;
+	struct ov5640 *priv = (struct ov5640 *)s_data->priv;
+
+	err = regmap_write(priv->regmap, addr, val);
+	if (err)
+		pr_err("%s:i2c write failed, %x = %x\n",
+			__func__, addr, val);
+
+	return err;
+}
+
+static int ov5640_write_table(struct ov5640 *priv,
+			      const ov5640_reg table[])
+{
+	return regmap_util_write_table_8(priv->regmap,
+					 table,
+					 NULL, 0,
+					 OV5640_TABLE_WAIT_MS,
+					 OV5640_TABLE_END);
+}
+
+static void ov5640_gpio_set(struct ov5640 *priv,
+			    unsigned int gpio, int val)
+{
+	if (priv->pdata && priv->pdata->use_cam_gpio)
+		cam_gpio_ctrl(&priv->i2c_client->dev, gpio, val, 1);
+	else {
+		if (gpio_cansleep(gpio))
+			gpio_set_value_cansleep(gpio, val);
+		else
+			//gpiod_set_value(gpio, val);
+			gpio_set_value(gpio, val);
+	}
+}
+
+static int ov5640_power_on(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct ov5640 *priv = (struct ov5640 *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+	u32 frame_time;
+
+	dev_dbg(&priv->i2c_client->dev, "%s: power on\n", __func__);
+
+	if (priv->pdata && priv->pdata->power_on) {
+		err = priv->pdata->power_on(pw);
+		if (err)
+			pr_err("%s failed.\n", __func__);
+		else
+			pw->state = SWITCH_ON;
+		return err;
+	}
+
+	/* sleeps calls in the sequence below are for internal device
+	 * signal propagation as specified by sensor vendor */
+
+	if (pw->avdd) {
+		err = regulator_enable(pw->avdd);
+		dev_dbg(&priv->i2c_client->dev, "%s: power on - enable avdd\n", __func__);
+	}
+	if (err)
+		goto ov5640_avdd_fail;
+
+	if (pw->dvdd) {
+		err = regulator_enable(pw->dvdd);
+		dev_dbg(&priv->i2c_client->dev, "%s: power on - enable dvdd\n", __func__);
+	}
+	if (err)
+		goto ov5640_dvdd_fail;
+
+	usleep_range(1, 2);
+	if (pw->pwdn_gpio)
+		ov5640_gpio_set(priv, pw->pwdn_gpio, 0);
+		// ov5640_gpio_set(priv, pw->pwdn_gpio, 1);
+
+	/*
+	 * datasheet 2.9: reset requires ~2ms settling time
+	 * a power on reset is generated after core power becomes stable
+	 */
+	usleep_range(2000, 2010);
+
+	if (pw->reset_gpio)
+//		ov5640_gpio_set(priv, pw->reset_gpio, 0);
+		ov5640_gpio_set(priv, pw->reset_gpio, 1);
+
+	/* datasheet fig 2-9: t3 */
+	usleep_range(2000, 2010);
+
+	pw->state = SWITCH_ON;
+
+	/* need SW standby LP11 for mipical.
+	 * sensor default is LP00, this will transition to LP11 */
+	ov5640_write_reg(s_data, 0x3008, 0x02);
+	ov5640_write_reg(s_data, 0x3008, 0x42);
+	/*
+	 * Sleep to allow SW reset to settle into LP11. After writing
+	 * 0x1, according to the datasheet, it could take the remainder
+	 * of the frame time to settle.  Streaming too soon after this
+	 * may have unintended consequences.
+	 */
+	frame_time = OV5640_DEFAULT_FRAME_LENGTH *
+			OV5640_DEFAULT_LINE_LENGTH / OV5640_DEFAULT_PIXEL_CLOCK;
+	usleep_range(frame_time, frame_time + 1000);
+
+	return 0;
+
+ov5640_dvdd_fail:
+	regulator_disable(pw->avdd);
+
+ov5640_avdd_fail:
+	pr_err("%s failed.\n", __func__);
+	return -ENODEV;
+}
+
+static int ov5640_power_off(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct ov5640 *priv = (struct ov5640 *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+
+	dev_dbg(&priv->i2c_client->dev, "%s: power off\n", __func__);
+
+	if (priv->pdata && priv->pdata->power_off) {
+		err = priv->pdata->power_off(pw);
+		if (!err) {
+			goto power_off_done;
+		} else {
+			pr_err("%s failed.\n", __func__);
+			return err;
+		}
+	}
+
+	/* sleeps calls in the sequence below are for internal device
+	 * signal propagation as specified by sensor vendor */
+
+	usleep_range(21, 25);
+	if (pw->pwdn_gpio)
+		ov5640_gpio_set(priv, pw->pwdn_gpio, 1);
+		// ov5640_gpio_set(priv, pw->pwdn_gpio, 0);
+	usleep_range(1, 2);
+	if (pw->reset_gpio)
+//		ov5640_gpio_set(priv, pw->reset_gpio, 1);
+		ov5640_gpio_set(priv, pw->reset_gpio, 0);
+
+	/* datasheet 2.9: reset requires ~2ms settling time*/
+	usleep_range(2000, 2010);
+
+	if (pw->dvdd)
+		regulator_disable(pw->dvdd);
+	if (pw->avdd)
+		regulator_disable(pw->avdd);
+
+power_off_done:
+	pw->state = SWITCH_OFF;
+	return 0;
+}
+
+static int ov5640_power_put(struct ov5640 *priv)
+{
+	struct camera_common_power_rail *pw = &priv->power;
+
+	if (unlikely(!pw))
+		return -EFAULT;
+
+	if (likely(pw->avdd))
+		regulator_put(pw->avdd);
+
+	if (likely(pw->dvdd))
+		regulator_put(pw->dvdd);
+
+	pw->avdd = NULL;
+	pw->dvdd = NULL;
+
+	if (priv->pdata && priv->pdata->use_cam_gpio)
+		cam_gpio_deregister(&priv->i2c_client->dev, pw->pwdn_gpio);
+	else {
+		gpio_free(pw->pwdn_gpio);
+		gpio_free(pw->reset_gpio);
+	}
+
+	return 0;
+}
+
+static int ov5640_power_get(struct ov5640 *priv)
+{
+	struct camera_common_power_rail *pw = &priv->power;
+	struct camera_common_pdata *pdata = priv->pdata;
+	const char *mclk_name;
+	const char *parentclk_name;
+	struct clk *parent;
+	int err = 0, ret = 0;
+
+	if (!pdata) {
+		dev_err(&priv->i2c_client->dev, "pdata missing\n");
+		return -EFAULT;
+	}
+
+	mclk_name = pdata->mclk_name ?
+		    pdata->mclk_name : "cam_mclk1";
+	pw->mclk = devm_clk_get(&priv->i2c_client->dev, mclk_name);
+	if (IS_ERR(pw->mclk)) {
+		dev_err(&priv->i2c_client->dev,
+			"unable to get clock %s\n", mclk_name);
+		return PTR_ERR(pw->mclk);
+	}
+
+	parentclk_name = pdata->parentclk_name;
+	if (parentclk_name) {
+		parent = devm_clk_get(&priv->i2c_client->dev, parentclk_name);
+		if (IS_ERR(parent)) {
+			dev_err(&priv->i2c_client->dev,
+				"unable to get parent clcok %s",
+				parentclk_name);
+		} else
+			clk_set_parent(pw->mclk, parent);
+	}
+
+
+	/* analog 2.8v */
+	err |= camera_common_regulator_get(&priv->i2c_client->dev,
+			&pw->avdd, pdata->regulators.avdd);
+
+	/* DVDD 1.5v */
+	err |= camera_common_regulator_get(&priv->i2c_client->dev,
+			&pw->dvdd, pdata->regulators.dvdd);
+
+	if (!err) {
+		pw->reset_gpio = pdata->reset_gpio;
+		pw->pwdn_gpio = pdata->pwdn_gpio;
+	}
+
+	if (pdata->use_cam_gpio) {
+		err = cam_gpio_register(&priv->i2c_client->dev, pw->pwdn_gpio);
+		if (err)
+			dev_err(&priv->i2c_client->dev,
+				"%s ERR can't register cam gpio %u!\n",
+				 __func__, pw->pwdn_gpio);
+	} else {
+		ret = gpio_request(pw->pwdn_gpio, "cam_pwdn_gpio");
+		if (ret < 0)
+			dev_dbg(&priv->i2c_client->dev,
+				"%s can't request pwdn_gpio %d\n",
+				__func__, ret);
+		ret = gpio_request(pw->reset_gpio, "cam_reset_gpio");
+		if (ret < 0)
+			dev_dbg(&priv->i2c_client->dev,
+				"%s can't request reset_gpio %d\n",
+				__func__, ret);
+	}
+
+
+	pw->state = SWITCH_OFF;
+	return err;
+}
+
+static int ov5640_set_gain(struct ov5640 *priv, s32 val);
+static int ov5640_set_frame_length(struct ov5640 *priv, s32 val);
+static int ov5640_set_coarse_time(struct ov5640 *priv, s32 val);
+static int ov5640_set_coarse_time_short(struct ov5640 *priv, s32 val);
+
+static int ov5640_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct ov5640 *priv = (struct ov5640 *)s_data->priv;
+	struct v4l2_control control;
+	int err;
+	u32 frame_time;
+	u8 val;
+
+	dev_dbg(&client->dev, "%s++\n", __func__);
+
+	if (!enable) {
+		ov5640_update_ctrl_range(priv, OV5640_MAX_FRAME_LENGTH);
+
+		err = ov5640_write_table(priv,
+			mode_table[OV5640_MODE_STOP_STREAM]);
+		if (err)
+			return err;
+
+		/*
+		 * Wait for one frame to make sure sensor is set to
+		 * software standby in V-blank
+		 *
+		 * frame_time = frame length rows * Tline
+		 * Tline = line length / pixel clock (in MHz)
+		 */
+		frame_time = priv->frame_length *
+			OV5640_DEFAULT_LINE_LENGTH / OV5640_DEFAULT_PIXEL_CLOCK;
+
+		usleep_range(frame_time, frame_time + 1000);
+		return 0;
+	}
+
+	err = ov5640_write_table(priv, mode_table[s_data->mode]);
+	if (err)
+		goto exit;
+
+
+	if (s_data->override_enable) {
+		/*
+		 * write list of override regs for the asking frame length,
+		 * coarse integration time, and gain. Failures to write
+		 * overrides are non-fatal
+		 */
+		control.id = TEGRA_CAMERA_CID_GAIN;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		err |= ov5640_set_gain(priv, control.value);
+		if (err)
+			dev_dbg(&client->dev, "%s: warning gain override failed\n",
+				__func__);
+
+		control.id = TEGRA_CAMERA_CID_FRAME_LENGTH;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		err |= ov5640_set_frame_length(priv, control.value);
+		if (err)
+			dev_dbg(&client->dev,
+				"%s: warning frame length override failed\n",
+				__func__);
+
+		control.id = TEGRA_CAMERA_CID_COARSE_TIME;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		err |= ov5640_set_coarse_time(priv, control.value);
+		if (err)
+			dev_dbg(&client->dev,
+				"%s: warning coarse time override failed\n",
+				__func__);
+
+		control.id = TEGRA_CAMERA_CID_COARSE_TIME_SHORT;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		err |= ov5640_set_coarse_time_short(priv, control.value);
+		if (err)
+			dev_dbg(&client->dev,
+				"%s: warning coarse time short override failed\n",
+				__func__);
+	}
+
+	err = ov5640_write_table(priv, mode_table[OV5640_MODE_START_STREAM]);
+	if (err)
+		goto exit;
+	if (priv->pdata->v_flip) {
+		ov5640_read_reg(priv->s_data, OV5640_TIMING_REG20, &val);
+		ov5640_write_reg(priv->s_data, OV5640_TIMING_REG20,
+				 val | VERTICAL_FLIP);
+	}
+	if (priv->pdata->h_mirror) {
+		ov5640_read_reg(priv->s_data, OV5640_TIMING_REG21, &val);
+		ov5640_write_reg(priv->s_data, OV5640_TIMING_REG21,
+				 val | HORIZONTAL_MIRROR_MASK);
+	} else {
+		ov5640_read_reg(priv->s_data, OV5640_TIMING_REG21, &val);
+		ov5640_write_reg(priv->s_data, OV5640_TIMING_REG21,
+				 val & (~HORIZONTAL_MIRROR_MASK));
+	}
+	if (test_mode)
+		err = ov5640_write_table(priv,
+			mode_table[OV5640_MODE_TEST_PATTERN]);
+
+	dev_dbg(&client->dev, "%s--\n", __func__);
+	return 0;
+exit:
+	dev_dbg(&client->dev, "%s: error setting stream\n", __func__);
+	return err;
+}
+
+static int ov5640_g_input_status(struct v4l2_subdev *sd, u32 *status)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct ov5640 *priv = (struct ov5640 *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+
+	*status = pw->state == SWITCH_ON;
+	return 0;
+}
+
+static struct v4l2_subdev_video_ops ov5640_subdev_video_ops = {
+	.s_stream	= ov5640_s_stream,
+	.g_mbus_config	= camera_common_g_mbus_config,
+	.g_input_status = ov5640_g_input_status,
+};
+
+static struct v4l2_subdev_core_ops ov5640_subdev_core_ops = {
+	.s_power	= camera_common_s_power,
+};
+
+static int ov5640_get_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	return camera_common_g_fmt(sd, &format->format);
+}
+
+static int ov5640_set_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	int ret;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		ret = camera_common_try_fmt(sd, &format->format);
+	else
+		ret = camera_common_s_fmt(sd, &format->format);
+
+	return ret;
+}
+
+static struct v4l2_subdev_pad_ops ov5640_subdev_pad_ops = {
+	.set_fmt = ov5640_set_fmt,
+	.get_fmt = ov5640_get_fmt,
+	.enum_mbus_code = camera_common_enum_mbus_code,
+	.enum_frame_size	= camera_common_enum_framesizes,
+	.enum_frame_interval	= camera_common_enum_frameintervals,
+};
+
+static struct v4l2_subdev_ops ov5640_subdev_ops = {
+	.core	= &ov5640_subdev_core_ops,
+	.video	= &ov5640_subdev_video_ops,
+	.pad	= &ov5640_subdev_pad_ops,
+};
+
+static struct of_device_id ov5640_of_match[] = {
+	{ .compatible = "nvidia,ov5640", },
+	{ },
+};
+
+static struct camera_common_sensor_ops ov5640_common_ops = {
+	.power_on = ov5640_power_on,
+	.power_off = ov5640_power_off,
+	.write_reg = ov5640_write_reg,
+	.read_reg = ov5640_read_reg,
+};
+
+static int ov5640_set_group_hold(struct ov5640 *priv)
+{
+	int err;
+	int gh_prev = switch_ctrl_qmenu[priv->group_hold_prev];
+
+	if (priv->group_hold_en == true && gh_prev == SWITCH_OFF) {
+		/* enter group hold */
+		err = ov5640_write_reg(priv->s_data,
+				       OV5640_GROUP_HOLD_ADDR, 0x01);
+		if (err)
+			goto fail;
+
+		priv->group_hold_prev = 1;
+
+		dev_dbg(&priv->i2c_client->dev,
+			 "%s: enter group hold\n", __func__);
+	} else if (priv->group_hold_en == false && gh_prev == SWITCH_ON) {
+		/* leave group hold */
+		err = ov5640_write_reg(priv->s_data,
+				       OV5640_GROUP_HOLD_ADDR, 0x11);
+		if (err)
+			goto fail;
+
+		err = ov5640_write_reg(priv->s_data,
+				       OV5640_GROUP_HOLD_ADDR, 0x61);
+		if (err)
+			goto fail;
+
+		priv->group_hold_prev = 0;
+
+		dev_dbg(&priv->i2c_client->dev,
+			 "%s: leave group hold\n", __func__);
+	}
+
+	return 0;
+
+fail:
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: Group hold control error\n", __func__);
+	return err;
+}
+
+static u16 ov5640_to_real_gain(u32 rep, int shift)
+{
+	u16 gain;
+	int gain_int;
+	int gain_dec;
+	int min_int = (1 << shift);
+
+	if (rep < OV5640_MIN_GAIN)
+		rep = OV5640_MIN_GAIN;
+	else if (rep > OV5640_MAX_GAIN)
+		rep = OV5640_MAX_GAIN;
+
+	gain_int = (int)(rep >> shift);
+	gain_dec = (int)(rep & ~(0xffff << shift));
+
+	/* derived from formulat gain = (x * 16 + 0.5) */
+	gain = ((gain_int * min_int + gain_dec) * 32 + min_int) / (2 * min_int);
+
+	return gain;
+}
+
+static int ov5640_set_gain(struct ov5640 *priv, s32 val)
+{
+	ov5640_reg reg_list[2];
+	int err;
+	u16 gain;
+	int i;
+
+	if (!priv->group_hold_prev)
+		ov5640_set_group_hold(priv);
+
+	/* translate value */
+	gain = ov5640_to_real_gain((u32)val, OV5640_GAIN_SHIFT);
+
+	ov5640_get_gain_regs(reg_list, gain);
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: gain %04x val: %04x\n", __func__, val, gain);
+
+	for (i = 0; i < 2; i++) {
+		err = ov5640_write_reg(priv->s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: GAIN control error\n", __func__);
+	return err;
+}
+
+static void ov5640_update_ctrl_range(struct ov5640 *priv, s32 frame_length)
+{
+	struct v4l2_ctrl *ctrl = NULL;
+	int ctrl_ids[2] = {TEGRA_CAMERA_CID_COARSE_TIME,
+			TEGRA_CAMERA_CID_COARSE_TIME_SHORT};
+	s32 max, min, def;
+	int i, j;
+
+	for (i = 0; i < ARRAY_SIZE(ctrl_ids); i++) {
+		for (j = 0; j < priv->numctrls; j++) {
+			if (priv->ctrls[j]->id == ctrl_ids[i]) {
+				ctrl = priv->ctrls[j];
+				break;
+			}
+		}
+
+		if (j == priv->numctrls) {
+			dev_err(&priv->i2c_client->dev,
+				"could not find ctrl %x\n",
+				ctrl_ids[i]);
+			continue;
+		}
+
+		max = frame_length - OV5640_MAX_COARSE_DIFF;
+		/* clamp the value in case above is negative */
+		max = clamp_val(max, OV5640_MIN_EXPOSURE_COARSE,
+			OV5640_MAX_EXPOSURE_COARSE);
+		min = OV5640_MIN_EXPOSURE_COARSE;
+		def = clamp_val(OV5640_DEFAULT_EXPOSURE_COARSE, min, max);
+		if (__v4l2_ctrl_modify_range(ctrl, min, max, 1, def))
+			dev_err(&priv->i2c_client->dev,
+				"ctrl %x: range update failed\n",
+				ctrl_ids[i]);
+	}
+
+}
+
+static int ov5640_set_frame_length(struct ov5640 *priv, s32 val)
+{
+	ov5640_reg reg_list[2];
+	int err;
+	u32 frame_length;
+	int i;
+
+	if (!priv->group_hold_prev)
+		ov5640_set_group_hold(priv);
+
+	frame_length = (u32)val;
+
+	ov5640_get_frame_length_regs(reg_list, frame_length);
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: val: %d\n", __func__, frame_length);
+
+	for (i = 0; i < 2; i++) {
+		err = ov5640_write_reg(priv->s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+	priv->frame_length = frame_length;
+
+	ov5640_update_ctrl_range(priv, val);
+	return 0;
+
+fail:
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: FRAME_LENGTH control error\n", __func__);
+	return err;
+}
+
+static int ov5640_set_coarse_time(struct ov5640 *priv, s32 val)
+{
+	ov5640_reg reg_list[3];
+	int err;
+	u32 coarse_time;
+	int i;
+
+	if (!priv->group_hold_prev)
+		ov5640_set_group_hold(priv);
+
+	coarse_time = (u32)val;
+
+	ov5640_get_coarse_time_regs(reg_list, coarse_time);
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: val: %d\n", __func__, coarse_time);
+
+	for (i = 0; i < 3; i++) {
+		err = ov5640_write_reg(priv->s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: COARSE_TIME control error\n", __func__);
+	return err;
+}
+
+static int ov5640_set_coarse_time_short(struct ov5640 *priv, s32 val)
+{
+	ov5640_reg reg_list[3];
+	int err;
+	struct v4l2_control hdr_control;
+	int hdr_en;
+	u32 coarse_time_short;
+	int i;
+
+	if (!priv->group_hold_prev)
+		ov5640_set_group_hold(priv);
+
+	/* check hdr enable ctrl */
+	hdr_control.id = TEGRA_CAMERA_CID_HDR_EN;
+
+	err = camera_common_g_ctrl(priv->s_data, &hdr_control);
+	if (err < 0) {
+		dev_err(&priv->i2c_client->dev,
+			"could not find device ctrl.\n");
+		return err;
+	}
+
+	hdr_en = switch_ctrl_qmenu[hdr_control.value];
+	if (hdr_en == SWITCH_OFF)
+		return 0;
+
+	coarse_time_short = (u32)val;
+
+	ov5640_get_coarse_time_short_regs(reg_list, coarse_time_short);
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: val: %d\n", __func__, coarse_time_short);
+
+	for (i = 0; i < 3; i++) {
+		err = ov5640_write_reg(priv->s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: COARSE_TIME_SHORT control error\n", __func__);
+	return err;
+}
+
+static int ov5640_eeprom_device_release(struct ov5640 *priv)
+{
+	int i;
+
+	for (i = 0; i < OV5640_EEPROM_NUM_BLOCKS; i++) {
+		if (priv->eeprom[i].i2c_client != NULL) {
+			i2c_unregister_device(priv->eeprom[i].i2c_client);
+			priv->eeprom[i].i2c_client = NULL;
+		}
+	}
+
+	return 0;
+}
+
+static int ov5640_eeprom_device_init(struct ov5640 *priv)
+{
+	char *dev_name = "eeprom_ov5640";
+	static struct regmap_config eeprom_regmap_config = {
+		.reg_bits = 8,
+		.val_bits = 8,
+	};
+	int i;
+	int err;
+
+	if (!priv->pdata->has_eeprom)
+		return -EINVAL;
+
+	for (i = 0; i < OV5640_EEPROM_NUM_BLOCKS; i++) {
+		priv->eeprom[i].adap = i2c_get_adapter(
+				priv->i2c_client->adapter->nr);
+		memset(&priv->eeprom[i].brd, 0, sizeof(priv->eeprom[i].brd));
+		strncpy(priv->eeprom[i].brd.type, dev_name,
+				sizeof(priv->eeprom[i].brd.type));
+		priv->eeprom[i].brd.addr = OV5640_EEPROM_ADDRESS + i;
+		priv->eeprom[i].i2c_client = i2c_new_device(
+				priv->eeprom[i].adap, &priv->eeprom[i].brd);
+
+		priv->eeprom[i].regmap = devm_regmap_init_i2c(
+			priv->eeprom[i].i2c_client, &eeprom_regmap_config);
+		if (IS_ERR(priv->eeprom[i].regmap)) {
+			err = PTR_ERR(priv->eeprom[i].regmap);
+			ov5640_eeprom_device_release(priv);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static int ov5640_read_eeprom(struct ov5640 *priv,
+				struct v4l2_ctrl *ctrl)
+{
+	int err, i;
+
+	for (i = 0; i < OV5640_EEPROM_NUM_BLOCKS; i++) {
+		err = regmap_bulk_read(priv->eeprom[i].regmap, 0,
+			&priv->eeprom_buf[i * OV5640_EEPROM_BLOCK_SIZE],
+			OV5640_EEPROM_BLOCK_SIZE);
+		if (err)
+			return err;
+	}
+
+	for (i = 0; i < OV5640_EEPROM_SIZE; i++)
+		sprintf(&ctrl->p_new.p_char[i*2], "%02x",
+			priv->eeprom_buf[i]);
+	return 0;
+}
+
+static int ov5640_write_eeprom(struct ov5640 *priv,
+				char *string)
+{
+	int err;
+	int i;
+	u8 curr[3];
+	unsigned long data;
+
+	for (i = 0; i < OV5640_EEPROM_SIZE; i++) {
+		curr[0] = string[i*2];
+		curr[1] = string[i*2+1];
+		curr[2] = '\0';
+
+		err = kstrtol(curr, 16, &data);
+		if (err) {
+			dev_err(&priv->i2c_client->dev,
+				"invalid eeprom string\n");
+			return -EINVAL;
+		}
+
+		priv->eeprom_buf[i] = (u8)data;
+		err = regmap_write(priv->eeprom[i >> 8].regmap,
+				   i & 0xFF, (u8)data);
+		if (err)
+			return err;
+		msleep(20);
+	}
+	return 0;
+}
+
+static int ov5640_read_otp_bank(struct ov5640 *priv,
+				u8 *buf, int bank, u16 addr, int size)
+{
+	int err;
+
+	/* sleeps calls in the sequence below are for internal device
+	 * signal propagation as specified by sensor vendor */
+
+	usleep_range(10000, 11000);
+	err = ov5640_write_table(priv, mode_table[OV5640_MODE_START_STREAM]);
+	if (err)
+		return err;
+
+	err = ov5640_write_reg(priv->s_data, OV5640_OTP_BANK_SELECT_ADDR,
+			       0xC0 | bank);
+	if (err)
+		return err;
+
+	err = ov5640_write_reg(priv->s_data, OV5640_OTP_LOAD_CTRL_ADDR, 0x01);
+	if (err)
+		return err;
+
+	usleep_range(10000, 11000);
+	err = regmap_bulk_read(priv->regmap, addr, buf, size);
+	if (err)
+		return err;
+
+	err = ov5640_write_table(priv,
+			mode_table[OV5640_MODE_STOP_STREAM]);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int ov5640_otp_setup(struct ov5640 *priv)
+{
+	int err;
+	int i;
+	struct v4l2_ctrl *ctrl;
+	u8 otp_buf[OV5640_OTP_SIZE];
+
+	err = camera_common_s_power(priv->subdev, true);
+	if (err)
+		return -ENODEV;
+
+	for (i = 0; i < OV5640_OTP_NUM_BANKS; i++) {
+		err = ov5640_read_otp_bank(priv,
+					&otp_buf[i * OV5640_OTP_BANK_SIZE],
+					i,
+					OV5640_OTP_BANK_START_ADDR,
+					OV5640_OTP_BANK_SIZE);
+		if (err) {
+			dev_err(&priv->i2c_client->dev,
+				"could not read otp bank\n");
+			goto ret;
+		}
+	}
+
+	ctrl = v4l2_ctrl_find(&priv->ctrl_handler, TEGRA_CAMERA_CID_OTP_DATA);
+	if (!ctrl) {
+		dev_err(&priv->i2c_client->dev,
+			"could not find device ctrl.\n");
+		err = -EINVAL;
+		goto ret;
+	}
+
+	for (i = 0; i < OV5640_OTP_SIZE; i++)
+		sprintf(&ctrl->p_new.p_char[i*2], "%02x",
+			otp_buf[i]);
+	ctrl->p_cur.p_char = ctrl->p_new.p_char;
+
+ret:
+	camera_common_s_power(priv->subdev, false);
+
+	return err;
+}
+
+static int ov5640_fuse_id_setup(struct ov5640 *priv)
+{
+	int err;
+	int i;
+	struct v4l2_ctrl *ctrl;
+	u8 fuse_id[OV5640_FUSE_ID_SIZE];
+
+	err = camera_common_s_power(priv->subdev, true);
+	if (err)
+		return -ENODEV;
+
+	err = ov5640_read_otp_bank(priv,
+				&fuse_id[0],
+				OV5640_FUSE_ID_OTP_BANK,
+				OV5640_FUSE_ID_OTP_START_ADDR,
+				OV5640_FUSE_ID_SIZE);
+	if (err) {
+		dev_err(&priv->i2c_client->dev,
+			"could not read otp bank\n");
+		goto ret;
+	}
+
+	ctrl = v4l2_ctrl_find(&priv->ctrl_handler, TEGRA_CAMERA_CID_FUSE_ID);
+	if (!ctrl) {
+		dev_err(&priv->i2c_client->dev,
+			"could not find device ctrl.\n");
+		err = -EINVAL;
+		goto ret;
+	}
+
+	for (i = 0; i < OV5640_FUSE_ID_SIZE; i++)
+		sprintf(&ctrl->p_new.p_char[i*2], "%02x",
+			fuse_id[i]);
+	ctrl->p_cur.p_char = ctrl->p_new.p_char;
+
+ret:
+	camera_common_s_power(priv->subdev, false);
+
+	return err;
+}
+
+static int ov5640_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov5640 *priv =
+		container_of(ctrl->handler, struct ov5640, ctrl_handler);
+	int err = 0;
+
+	if (priv->power.state == SWITCH_OFF)
+		return 0;
+
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_EEPROM_DATA:
+		err = ov5640_read_eeprom(priv, ctrl);
+		if (err)
+			return err;
+		break;
+	default:
+			pr_err("%s: unknown ctrl id.\n", __func__);
+			return -EINVAL;
+	}
+
+	return err;
+}
+
+static int ov5640_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov5640 *priv =
+		container_of(ctrl->handler, struct ov5640, ctrl_handler);
+	int err = 0;
+
+	if (priv->power.state == SWITCH_OFF)
+		return 0;
+
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_GAIN:
+		err = ov5640_set_gain(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_FRAME_LENGTH:
+		err = ov5640_set_frame_length(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_COARSE_TIME:
+		err = ov5640_set_coarse_time(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_COARSE_TIME_SHORT:
+		err = ov5640_set_coarse_time_short(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_GROUP_HOLD:
+		if (switch_ctrl_qmenu[ctrl->val] == SWITCH_ON) {
+			priv->group_hold_en = true;
+		} else {
+			priv->group_hold_en = false;
+			err = ov5640_set_group_hold(priv);
+		}
+		break;
+	case TEGRA_CAMERA_CID_EEPROM_DATA:
+		if (!ctrl->p_new.p_char[0])
+			break;
+		err = ov5640_write_eeprom(priv, ctrl->p_new.p_char);
+		if (err)
+			return err;
+		break;
+	case TEGRA_CAMERA_CID_HDR_EN:
+		break;
+	default:
+		pr_err("%s: unknown ctrl id.\n", __func__);
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static int ov5640_ctrls_init(struct ov5640 *priv, bool eeprom_ctrl)
+{
+	struct i2c_client *client = priv->i2c_client;
+	struct camera_common_data *common_data = priv->s_data;
+	struct v4l2_ctrl *ctrl;
+	int numctrls;
+	int err;
+	int i;
+
+	dev_dbg(&client->dev, "%s++\n", __func__);
+
+	numctrls = ARRAY_SIZE(ctrl_config_list);
+	v4l2_ctrl_handler_init(&priv->ctrl_handler, numctrls);
+
+	for (i = 0; i < numctrls; i++) {
+		/*
+		 * Skip control 'TEGRA_CAMERA_CID_EEPROM_DATA'
+		 * if eeprom inint err
+		 */
+		if (ctrl_config_list[i].id == TEGRA_CAMERA_CID_EEPROM_DATA) {
+			if (!eeprom_ctrl) {
+				common_data->numctrls -= 1;
+				continue;
+			}
+		}
+
+		ctrl = v4l2_ctrl_new_custom(&priv->ctrl_handler,
+			&ctrl_config_list[i], NULL);
+		if (ctrl == NULL) {
+			dev_err(&client->dev, "Failed to init %s ctrl\n",
+				ctrl_config_list[i].name);
+			continue;
+		}
+
+		if (ctrl_config_list[i].type == V4L2_CTRL_TYPE_STRING &&
+			ctrl_config_list[i].flags & V4L2_CTRL_FLAG_READ_ONLY) {
+			ctrl->p_new.p_char = devm_kzalloc(&client->dev,
+				ctrl_config_list[i].max + 1, GFP_KERNEL);
+			if (!ctrl->p_new.p_char)
+				return -ENOMEM;
+		}
+		priv->ctrls[i] = ctrl;
+	}
+
+	priv->numctrls = numctrls;
+	priv->subdev->ctrl_handler = &priv->ctrl_handler;
+	if (priv->ctrl_handler.error) {
+		dev_err(&client->dev, "Error %d adding controls\n",
+			priv->ctrl_handler.error);
+		err = priv->ctrl_handler.error;
+		goto error;
+	}
+
+	err = v4l2_ctrl_handler_setup(&priv->ctrl_handler);
+	if (err) {
+		dev_err(&client->dev,
+			"Error %d setting default controls\n", err);
+		goto error;
+	}
+
+	err = ov5640_otp_setup(priv);
+	if (err) {
+		dev_err(&client->dev,
+			"Error %d reading otp data\n", err);
+		goto error;
+	}
+
+	err = ov5640_fuse_id_setup(priv);
+	if (err) {
+		dev_err(&client->dev,
+			"Error %d reading fuse id data\n", err);
+		goto error;
+	}
+
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	return err;
+}
+
+MODULE_DEVICE_TABLE(of, ov5640_of_match);
+
+static struct camera_common_pdata *ov5640_parse_dt(struct i2c_client *client)
+{
+	struct device_node *node = client->dev.of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	const struct of_device_id *match;
+	int gpio;
+	int err;
+	struct camera_common_pdata *ret = NULL;
+
+	if (!node)
+		return NULL;
+
+	match = of_match_device(ov5640_of_match, &client->dev);
+	if (!match) {
+		dev_err(&client->dev, "Failed to find matching dt id\n");
+		return NULL;
+	}
+
+	board_priv_pdata = devm_kzalloc(&client->dev,
+			   sizeof(*board_priv_pdata), GFP_KERNEL);
+	if (!board_priv_pdata)
+		return NULL;
+
+	err = camera_common_parse_clocks(&client->dev, board_priv_pdata);
+	if (err) {
+		dev_err(&client->dev, "Failed to find clocks\n");
+		goto error;
+	}
+
+	gpio = of_get_named_gpio(node, "pwdn-gpios", 0);
+	if (gpio < 0) {
+		if (gpio == -EPROBE_DEFER) {
+			ret = ERR_PTR(-EPROBE_DEFER);
+			goto error;
+		}
+		dev_err(&client->dev, "pwdn gpios not in DT\n");
+		goto error;
+	}
+	board_priv_pdata->pwdn_gpio = (unsigned int)gpio;
+
+	gpio = of_get_named_gpio(node, "reset-gpios", 0);
+	if (gpio < 0) {
+		/* reset-gpio is not absolutely needed */
+		if (gpio == -EPROBE_DEFER) {
+			ret = ERR_PTR(-EPROBE_DEFER);
+			goto error;
+		}
+		dev_dbg(&client->dev, "reset gpios not in DT\n");
+		gpio = 0;
+	}
+	board_priv_pdata->reset_gpio = (unsigned int)gpio;
+
+	board_priv_pdata->use_cam_gpio =
+		of_property_read_bool(node, "cam,use-cam-gpio");
+
+	err = of_property_read_string(node, "avdd-reg",
+			&board_priv_pdata->regulators.avdd);
+	if (err) {
+		dev_err(&client->dev, "avdd-reg not in DT\n");
+		goto error;
+	}
+
+	err = of_property_read_string(node, "dvdd-reg",
+			&board_priv_pdata->regulators.dvdd);
+	if (err) {
+		dev_err(&client->dev, "dvdd-reg not in DT\n");
+		goto error;
+	}
+
+	board_priv_pdata->has_eeprom =
+		of_property_read_bool(node, "has-eeprom");
+	board_priv_pdata->v_flip = of_property_read_bool(node, "vertical-flip");
+	board_priv_pdata->h_mirror = of_property_read_bool(node,
+							 "horizontal-mirror");
+	return board_priv_pdata;
+
+error:
+	devm_kfree(&client->dev, board_priv_pdata);
+	return ret;
+}
+
+static int ov5640_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev_dbg(&client->dev, "%s:\n", __func__);
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops ov5640_subdev_internal_ops = {
+	.open = ov5640_open,
+};
+
+static const struct media_entity_operations ov5640_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static int ov5640_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct camera_common_data *common_data;
+	struct device_node *node = client->dev.of_node;
+	struct ov5640 *priv;
+	int err;
+
+	pr_info("[OV5640]: probing v4l2 sensor.\n");
+
+	if (!IS_ENABLED(CONFIG_OF) || !node)
+		return -EINVAL;
+
+	common_data = devm_kzalloc(&client->dev,
+			    sizeof(struct camera_common_data), GFP_KERNEL);
+	if (!common_data)
+		return -ENOMEM;
+
+	priv = devm_kzalloc(&client->dev,
+			    sizeof(struct ov5640) + sizeof(struct v4l2_ctrl *) *
+			    ARRAY_SIZE(ctrl_config_list),
+			    GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->regmap = devm_regmap_init_i2c(client, &ov5640_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(&client->dev,
+			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
+		return -ENODEV;
+	}
+
+	priv->pdata = ov5640_parse_dt(client);
+	if (PTR_ERR(priv->pdata) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	if (!priv->pdata) {
+		dev_err(&client->dev, "unable to get platform data\n");
+		return -EFAULT;
+	}
+
+	common_data->ops		= &ov5640_common_ops;
+	common_data->ctrl_handler	= &priv->ctrl_handler;
+	common_data->dev		= &client->dev;
+	common_data->frmfmt		= ov5640_frmfmt;
+	common_data->colorfmt		= camera_common_find_datafmt(
+					  OV5640_DEFAULT_DATAFMT);
+	common_data->power		= &priv->power;
+	common_data->ctrls		= priv->ctrls;
+	common_data->priv		= (void *)priv;
+	common_data->numctrls		= ARRAY_SIZE(ctrl_config_list);
+	common_data->numfmts		= ARRAY_SIZE(ov5640_frmfmt);
+	common_data->def_mode		= OV5640_DEFAULT_MODE;
+	common_data->def_width		= OV5640_DEFAULT_WIDTH;
+	common_data->def_height		= OV5640_DEFAULT_HEIGHT;
+	common_data->fmt_width		= common_data->def_width;
+	common_data->fmt_height		= common_data->def_height;
+	common_data->def_clk_freq	= OV5640_DEFAULT_CLK_FREQ;
+
+	priv->i2c_client = client;
+	priv->s_data			= common_data;
+	priv->subdev			= &common_data->subdev;
+	priv->subdev->dev		= &client->dev;
+	priv->s_data->dev		= &client->dev;
+
+	err = ov5640_power_get(priv);
+	if (err)
+		return err;
+
+	err = camera_common_initialize(common_data, "ov5640");
+	if (err) {
+		dev_err(&client->dev, "Failed to initialize ov5640.\n");
+		return err;
+	}
+
+
+	v4l2_i2c_subdev_init(priv->subdev, client, &ov5640_subdev_ops);
+
+	/* eeprom interface */
+	err = ov5640_eeprom_device_init(priv);
+	if (err && priv->pdata->has_eeprom)
+		dev_err(&client->dev,
+			"Failed to allocate eeprom reg map: %d\n", err);
+
+	err = ov5640_ctrls_init(priv, !err);
+	if (err)
+		return err;
+
+	priv->subdev->internal_ops = &ov5640_subdev_internal_ops;
+	priv->subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+			       V4L2_SUBDEV_FL_HAS_EVENTS;
+
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	priv->subdev->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+	priv->subdev->entity.ops = &ov5640_media_ops;
+	err = media_entity_init(&priv->subdev->entity, 1, &priv->pad, 0);
+	if (err < 0) {
+		dev_err(&client->dev, "unable to init media entity\n");
+		return err;
+	}
+#endif
+
+	err = v4l2_async_register_subdev(priv->subdev);
+	if (err)
+		return err;
+
+	dev_dbg(&client->dev, "Detected ov5640 sensor\n");
+
+
+	return 0;
+}
+
+static int
+ov5640_remove(struct i2c_client *client)
+{
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct ov5640 *priv = (struct ov5640 *)s_data->priv;
+
+	v4l2_async_unregister_subdev(priv->subdev);
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	media_entity_cleanup(&priv->subdev->entity);
+#endif
+
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	ov5640_power_put(priv);
+	camera_common_cleanup(s_data);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov5640_id[] = {
+	{ "ov5640", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, ov5640_id);
+
+static struct i2c_driver ov5640_i2c_driver = {
+	.driver = {
+		.name = "ov5640",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(ov5640_of_match),
+	},
+	.probe = ov5640_probe,
+	.remove = ov5640_remove,
+	.id_table = ov5640_id,
+};
+
+module_i2c_driver(ov5640_i2c_driver);
+
+MODULE_DESCRIPTION("SoC Camera driver for OmniVision OV5640");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/i2c/ov5640_mode_tbls.h b/drivers/media/i2c/ov5640_mode_tbls.h
new file mode 100644
index 0000000..4c52ac1
--- /dev/null
+++ b/drivers/media/i2c/ov5640_mode_tbls.h
@@ -0,0 +1,376 @@
+/*
+ * ov5640_mode_tbls.h - ov5640 sensor mode tables
+ *
+ * Copyright (c) 2015-2017, NVIDIA CORPORATION, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __OV5640_TABLES__
+#define __OV5640_TABLES__
+
+#include <media/camera_common.h>
+
+#define OV5640_TABLE_WAIT_MS	0
+#define OV5640_TABLE_END	1
+#define OV5640_MAX_RETRIES	3
+#define OV5640_WAIT_MS		10
+
+#define ov5640_reg struct reg_8
+
+static const ov5640_reg ov5640_start[] = {
+	{0x3008, 0x02}, /* mode select streaming on */
+	{OV5640_TABLE_END, 0x00}
+};
+
+static const ov5640_reg ov5640_stop[] = {
+	{0x3008, 0x42}, /* mode select streaming on */
+	{OV5640_TABLE_END, 0x00}
+};
+
+static const ov5640_reg tp_colorbars[] = {
+	{0x503d, 0x80},
+
+	{OV5640_TABLE_WAIT_MS, OV5640_WAIT_MS},
+	{OV5640_TABLE_END, 0x00}
+};
+
+static const ov5640_reg mode_1920x1080[] = {
+	{OV5640_TABLE_WAIT_MS, OV5640_WAIT_MS},
+
+	{0x3103, 0x11}, // global settings
+    {0x3103, 0x11},
+    {0x3008, 0x82}, // reset
+    {OV5640_TABLE_WAIT_MS, 0x1e},// delay here of 30ms
+    {0x3008, 0x42}, // power down
+    {0x3103, 0x03},
+    {0x3017, 0x00}, // disable oe
+    {0x3018, 0x00},
+
+    // PLL settings - RAW10, MIPISCLK = 420, SCLK = 84MHz, PCLK=84M
+    // {0x3034, 0x18}, // 8bit
+    {0x3034, 0x1a}, // 10bit - /2.5 of PLL
+    // {0x3035, 0x11},
+    {0x3035, 0x21}, // sys div /2, mipi  div /1 == MIPISCLK = 420MHz
+    // {0x3036, 0x54}, // 0x46 - 30fps,
+    {0x3036, 0x69}, // 0x69 = 105 mult - VCO = 840MHz
+    {0x3037, 0x03}, // div - pre div = /3 -> 8MHz, PLL root divider - /1
+    // {0x3037, 0x08},
+    // {0x3108, 0x01},
+    {0x3108, 0x11}, // PCLK root div /2, SCLK2x div /1, SCLK root div /2 -> PLL = 420MHz,
+    {0x3824, 0x01},
+    {OV5640_TABLE_WAIT_MS,0x05}, // delay 5ms
+
+    {0x3630, 0x36},
+    {0x3631, 0x0e},
+    {0x3632, 0xe2},
+    {0x3633, 0x12},
+    {0x3621, 0xe0},
+    {0x3704, 0xa0},
+    {0x3703, 0x5a},
+    {0x3715, 0x78},
+    {0x3717, 0x01},
+    {0x370b, 0x60},
+    {0x3705, 0x1a},
+    {0x3905, 0x02},
+    {0x3906, 0x10},
+    {0x3901, 0x0a},
+    {0x3731, 0x12},
+    {0x3600, 0x08},
+    {0x3601, 0x33},
+    {0x302d, 0x60},
+    {0x3620, 0x52},
+    {0x371b, 0x20},
+    {0x471c, 0x50},
+    {0x3a13, 0x43},
+    {0x3a18, 0x00},
+    {0x3a19, 0xf8}, // AGC ceiling
+    {0x3635, 0x13},
+    {0x3636, 0x03},
+    {0x3634, 0x40},
+    {0x3622, 0x01},
+    {0x3c01, 0x34}, //Band manual enable
+
+    {0x3c04, 0x28},
+    {0x3c05, 0x98},
+    {0x3c06, 0x00},
+    {0x3c07, 0x07}, // spec light meter threshold
+
+    {0x3c08, 0x00},
+    {0x3c09, 0x1c},
+    {0x3c0a, 0x9c},
+    {0x3c0b, 0x40},
+
+    {0x3820, 0x40}, // timing control
+    {0x3821, 0x06}, // timing control
+
+    {0x3814, 0x11},
+    {0x3815, 0x11},
+
+    {0x3800, 0x01}, // size setup
+    {0x3801, 0x50},
+    {0x3802, 0x01},
+    {0x3803, 0xb2},
+    {0x3804, 0x08},
+    {0x3805, 0xef},
+    {0x3806, 0x05},
+    {0x3807, 0xf1},
+    {0x3808, 0x07},
+    {0x3809, 0x80},
+    {0x380a, 0x04},
+    {0x380b, 0x38},
+    {0x380c, 0x09},
+    {0x380d, 0xc4},
+    {0x380e, 0x04},
+    {0x380f, 0x60},
+
+    {0x3810, 0x00},
+    {0x3811, 0x10},
+    {0x3812, 0x00},
+
+    {0x3813, 0x04},
+    {0x3618, 0x04},
+    {0x3612, 0x2b},
+    {0x3708, 0x64},
+    {0x3709, 0x12},
+    {0x370c, 0x00},
+    {0x3a02, 0x04},
+    {0x3a03, 0x60},
+    {0x3a08, 0x01},
+    {0x3a09, 0x50},
+    {0x3a0b, 0x18},
+    {0x3a0e, 0x03},
+    {0x3a0d, 0x04},
+    {0x3a14, 0x04},
+    {0x3a15, 0x60},
+
+    {0x3503, 0x03}, //AEC Manual mode
+
+    {0x4001, 0x02},
+    {0x4004, 0x06}, // black line control process
+
+    {0x3000, 0x00}, // no resets
+    {0x3002, 0x1c},
+    {0x3004, 0xff},
+    {0x3006, 0xc3},
+
+    {0x300e, 0x45},  //  2 lane MIPI, MIPI enable, DEBUG
+    {0x302e, 0x08},
+
+    // {0x4300, 0x32}, // UYVY
+    {0x4300, 0xf8}, // RAW BGGR
+    {0x501f, 0x03}, // ISP RAW (DPC)
+    {0x4713, 0x02},
+    {0x4407, 0x04},
+    {0x440e, 0x00},
+
+    {0x460c, 0x20},
+    {0x4837, 24},  // PCLK period = 1/PCLK in ns * 2 (depends on # of lanes)
+    {0x5000, 0x06}, //CHANGED ..Gamma enable = bad
+    {0x5001, 0x00},
+    {0x3a0f, 0x30},
+    {0x3a10, 0x28},
+    {0x3a1b, 0x30},
+    {0x3a1e, 0x26},
+    {0x3a11, 0x60},
+    {0x3a1f, 0x14},
+    {0x3008, 0x02},
+
+
+	{OV5640_TABLE_END, 0x0000}
+};
+
+static const ov5640_reg mode_2592x1944[] = {
+    {OV5640_TABLE_WAIT_MS, OV5640_WAIT_MS},
+
+	{0x3103, 0x11}, // global settings
+    {0x3103, 0x11},
+    {0x3008, 0x82}, // reset
+    {OV5640_TABLE_WAIT_MS, 0x1e},// delay here of 30ms
+    {0x3008, 0x42}, // power down
+    {0x3103, 0x03},
+    {0x3017, 0x00}, // disable oe
+    {0x3018, 0x00},
+
+    // PLL settings - RAW10, MIPISCLK = 420, SCLK = 84MHz, PCLK=84M
+    //{0x3034, 0x18}, // 8bit
+    {0x3034, 0x1a}, // 10bit - /2.5 of PLL
+    {0x3035, 0x12},
+    // {0x3035, 0x21}, // sys div /2, mipi  div /1 == MIPISCLK = 420MHz
+    // {0x3036, 0x54}, // 0x46 - 30fps,
+    {0x3036, 0x69}, // 0x69 = 105 mult - VCO = 840MHz
+    {0x3037, 0x13}, // div - pre div = /3 -> 8MHz, PLL root divider - /2
+    // {0x3037, 0x03}, // div - pre div = /3 -> 8MHz, PLL root divider - /1
+
+    {0x3108, 0x11}, // PCLK root div /2, SCLK2x div /1, SCLK root div /2 -> PLL = 420MHz,
+    {0x3824, 0x01},
+    {OV5640_TABLE_WAIT_MS,0x05}, // delay 5ms
+
+    {0x3630, 0x36},
+    {0x3631, 0x0e},
+    {0x3632, 0xe2},
+    {0x3633, 0x12},
+    {0x3621, 0xe0},
+    {0x3704, 0xa0},
+    {0x3703, 0x5a},
+    {0x3715, 0x78},
+    {0x3717, 0x01},
+    {0x370b, 0x60},
+    {0x3705, 0x1a},
+    {0x3905, 0x02},
+    {0x3906, 0x10},
+    {0x3901, 0x0a},
+    {0x3731, 0x12},
+    {0x3600, 0x08},
+    {0x3601, 0x33},
+    {0x302d, 0x60},
+    {0x3620, 0x52},
+    {0x371b, 0x20},
+    {0x471c, 0x50},
+    {0x3a13, 0x43},
+    {0x3a18, 0x00},
+    {0x3a19, 0xf8}, // AGC ceiling
+    {0x3635, 0x13},
+    {0x3636, 0x03},
+    {0x3634, 0x40},
+    {0x3622, 0x01},
+    {0x3c01, 0x34}, //Band manual enable
+
+    {0x3c04, 0x28},
+    {0x3c05, 0x98},
+    {0x3c06, 0x00},
+    {0x3c07, 0x07}, // spec light meter threshold
+
+    {0x3c08, 0x00},
+    {0x3c09, 0x1c},
+    {0x3c0a, 0x9c},
+    {0x3c0b, 0x40},
+
+    {0x3820, 0x40}, // timing control
+    {0x3821, 0x00}, // timing control
+
+    {0x3814, 0x11},
+    {0x3815, 0x11},
+
+    {0x3800, 0x00}, // size setup
+    {0x3801, 0x00},
+    {0x3802, 0x00},
+    {0x3803, 0x00},
+    {0x3804, 0x0a},
+    {0x3805, 0x3f},
+    {0x3806, 0x07},
+    {0x3807, 0x9f},
+    {0x3808, 0x0a},
+    {0x3809, 0x20},
+    {0x380a, 0x07},
+    {0x380b, 0x98},
+    {0x380c, 0x0b},
+    {0x380d, 0x1c},
+    {0x380e, 0x07},
+    {0x380f, 0xb0},
+
+    {0x3810, 0x00},
+    {0x3811, 0x10},
+    {0x3812, 0x00},
+
+    {0x3813, 0x04},
+    {0x3618, 0x04},
+    {0x3612, 0x2b},
+    {0x3708, 0x63},
+    {0x3709, 0x12},
+    {0x370c, 0x00},
+    {0x3a02, 0x07},
+    {0x3a03, 0xb0},
+    {0x3a08, 0x01},
+    {0x3a09, 0x27},
+    {0x3a0a, 0x00},
+    {0x3a0b, 0xf6},
+    {0x3a0e, 0x06},
+    {0x3a0d, 0x08},
+    {0x3a14, 0x07},
+    {0x3a15, 0xb0},
+
+    {0x3503, 0x03}, //AEC Manual mode
+
+    {0x4001, 0x02},
+    {0x4004, 0x06}, // black line control process
+    {0x4050, 0x6e},
+    {0x4051, 0x8f},
+    {0x3000, 0x00}, // no resets
+    {0x3002, 0x1c},
+    {0x3004, 0xff},
+    {0x3006, 0xc3},
+
+    {0x300e, 0x45},  //  2 lane MIPI, MIPI enable, DEBUG
+    {0x302e, 0x08},
+
+    // {0x4300, 0x32}, // UYVY
+    {0x4300, 0xf8}, // RAW BGGR
+    {0x501f, 0x03}, // ISP RAW (DPC)
+    {0x5684, 0x0a},
+    {0x5685, 0x20},
+    {0x5686, 0x07},
+    {0x5687, 0x98},
+    {0x440e, 0x00},
+
+
+    {0x4837, 24},  // PCLK period = 1/PCLK in ns * 2 (depends on # of lanes)
+    {0x5000, 0x06}, //CHANGED ..Gamma enable = bad
+    {0x5001, 0x00},
+    {0x3a0f, 0x36},
+    {0x3a10, 0x2e},
+    {0x3a1b, 0x38},
+    {0x3a1e, 0x2c},
+    {0x3a11, 0x70},
+    {0x3a1f, 0x18},
+    {0x3008, 0x02},
+
+
+	{OV5640_TABLE_END, 0x0000}
+
+};
+
+enum {
+	OV5640_MODE_1920X1080,
+	OV5640_MODE_START_STREAM,
+	OV5640_MODE_STOP_STREAM,
+	OV5640_MODE_TEST_PATTERN
+};
+
+static const ov5640_reg *mode_table[] = {
+	[OV5640_MODE_1920X1080]			= mode_1920x1080,
+    [OV5640_MODE_START_STREAM]		= ov5640_start,
+	[OV5640_MODE_STOP_STREAM]		= ov5640_stop,
+	[OV5640_MODE_TEST_PATTERN]		= tp_colorbars,
+};
+
+static const int ov5640_15fps[] = {
+	15,
+};
+
+static const int ov5640_24fps[] = {
+	24,
+};
+
+static const int ov5640_30fps[] = {
+	30,
+};
+
+static const int ov5640_120fps[] = {
+	120,
+};
+
+static const struct camera_common_frmfmt ov5640_frmfmt[] = {
+	{{1920, 1080},	ov5640_30fps,	1, 0,	OV5640_MODE_1920X1080},
+};
+#endif  /* __OV5640_TABLES__ */
diff --git a/drivers/media/i2c/ov5670.c b/drivers/media/i2c/ov5670.c
new file mode 100644
index 0000000..8da078e
--- /dev/null
+++ b/drivers/media/i2c/ov5670.c
@@ -0,0 +1,1498 @@
+/*
+ * ov5670_v4l2.c - ov5670 sensor driver
+ *
+ * Copyright (c) 2013-2017, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#define DEBUG
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+
+#include <linux/seq_file.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+
+#include <media/tegra-v4l2-camera.h>
+#include <media/camera_common.h>
+#include <media/ov5670.h>
+
+#include "../platform/tegra/camera/camera_gpio.h"
+
+#include "ov5670_mode_tbls.h"
+
+#define OV5670_MAX_COARSE_DIFF		6
+
+#define OV5670_GAIN_SHIFT		8
+#define OV5670_MIN_GAIN		(1 << OV5670_GAIN_SHIFT)
+#define OV5670_MAX_GAIN		(16 << OV5670_GAIN_SHIFT)
+#define OV5670_MAX_UNREAL_GAIN	(0x0F80)
+#define OV5670_MIN_FRAME_LENGTH	(0x0)
+#define OV5670_MAX_FRAME_LENGTH	(0x7fff)
+#define OV5670_MIN_EXPOSURE_COARSE	(0x0002)
+#define OV5670_MAX_EXPOSURE_COARSE	\
+	(OV5670_MAX_FRAME_LENGTH-OV5670_MAX_COARSE_DIFF)
+#define OV5670_DEFAULT_LINE_LENGTH	(0xA80) //2688
+// #define OV5670_DEFAULT_PIXEL_CLOCK	(160)
+#define OV5670_DEFAULT_PIXEL_CLOCK	(240)
+
+#define OV5670_DEFAULT_GAIN		OV5670_MIN_GAIN
+#define OV5670_DEFAULT_FRAME_LENGTH	(0x07C0) //1984
+#define OV5670_DEFAULT_EXPOSURE_COARSE	\
+	(OV5670_DEFAULT_FRAME_LENGTH-OV5670_MAX_COARSE_DIFF)
+
+// #define OV5670_DEFAULT_MODE	OV5670_MODE_2592X1944
+#define OV5670_DEFAULT_MODE	OV5670_MODE_1920X1080
+//#define OV5670_DEFAULT_HDR_MODE	OV5670_MODE_2592X1944_HDR
+// #define OV5670_DEFAULT_WIDTH	2592
+// #define OV5670_DEFAULT_HEIGHT	1944
+#define OV5670_DEFAULT_WIDTH	1920
+#define OV5670_DEFAULT_HEIGHT	1080
+
+// #define OV5670_DEFAULT_DATAFMT	MEDIA_BUS_FMT_SBGGR10_1X10
+#define OV5670_DEFAULT_DATAFMT	MEDIA_BUS_FMT_SGBRG10_1X10
+#define OV5670_DEFAULT_CLK_FREQ	24000000
+
+struct ov5670 {
+	struct camera_common_power_rail	power;
+	int				numctrls;
+	struct v4l2_ctrl_handler	ctrl_handler;
+	struct camera_common_eeprom_data eeprom[OV5670_EEPROM_NUM_BLOCKS];
+	u8				eeprom_buf[OV5670_EEPROM_SIZE];
+	struct i2c_client		*i2c_client;
+	struct v4l2_subdev		*subdev;
+	struct media_pad		pad;
+
+	s32				group_hold_prev;
+	u32				frame_length;
+	bool				group_hold_en;
+	struct regmap			*regmap;
+	struct camera_common_data	*s_data;
+	struct camera_common_pdata	*pdata;
+	struct v4l2_ctrl		*ctrls[];
+};
+
+static struct regmap_config ov5670_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+};
+
+static int ov5670_g_volatile_ctrl(struct v4l2_ctrl *ctrl);
+static int ov5670_s_ctrl(struct v4l2_ctrl *ctrl);
+static void ov5670_update_ctrl_range(struct ov5670 *priv, s32 frame_length);
+
+static const struct v4l2_ctrl_ops ov5670_ctrl_ops = {
+	.g_volatile_ctrl = ov5670_g_volatile_ctrl,
+	.s_ctrl		= ov5670_s_ctrl,
+};
+
+static struct v4l2_ctrl_config ctrl_config_list[] = {
+/* Do not change the name field for the controls! */
+	{
+		.ops = &ov5670_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GAIN,
+		.name = "Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = OV5670_MIN_GAIN,
+		.max = OV5670_MAX_GAIN,
+		.def = OV5670_DEFAULT_GAIN,
+		.step = 1,
+	},
+	{
+		.ops = &ov5670_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_FRAME_LENGTH,
+		.name = "Frame Length",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = OV5670_MIN_FRAME_LENGTH,
+		.max = OV5670_MAX_FRAME_LENGTH,
+		.def = OV5670_DEFAULT_FRAME_LENGTH,
+		.step = 1,
+	},
+	{
+		.ops = &ov5670_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_COARSE_TIME,
+		.name = "Coarse Time",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = OV5670_MIN_EXPOSURE_COARSE,
+		.max = OV5670_MAX_EXPOSURE_COARSE,
+		.def = OV5670_DEFAULT_EXPOSURE_COARSE,
+		.step = 1,
+	},
+	{
+		.ops = &ov5670_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_COARSE_TIME_SHORT,
+		.name = "Coarse Time Short",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = OV5670_MIN_EXPOSURE_COARSE,
+		.max = OV5670_MAX_EXPOSURE_COARSE,
+		.def = OV5670_DEFAULT_EXPOSURE_COARSE,
+		.step = 1,
+	},
+	{
+		.ops = &ov5670_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GROUP_HOLD,
+		.name = "Group Hold",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &ov5670_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_HDR_EN,
+		.name = "HDR enable",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &ov5670_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_EEPROM_DATA,
+		.name = "EEPROM Data",
+		.type = V4L2_CTRL_TYPE_STRING,
+		.flags = V4L2_CTRL_FLAG_VOLATILE,
+		.min = 0,
+		.max = OV5670_EEPROM_STR_SIZE,
+		.step = 2,
+	},
+	{
+		.ops = &ov5670_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_OTP_DATA,
+		.name = "OTP Data",
+		.type = V4L2_CTRL_TYPE_STRING,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY,
+		.min = 0,
+		.max = OV5670_OTP_STR_SIZE,
+		.step = 2,
+	},
+};
+
+static inline void ov5670_get_frame_length_regs(ov5670_reg *regs,
+				u32 frame_length)
+{
+	regs->addr = OV5670_FRAME_LENGTH_ADDR_MSB;
+	regs->val = (frame_length >> 8) & 0xff;
+	(regs + 1)->addr = OV5670_FRAME_LENGTH_ADDR_LSB;
+	(regs + 1)->val = (frame_length) & 0xff;
+}
+
+
+static inline void ov5670_get_coarse_time_regs(ov5670_reg *regs,
+				u32 coarse_time)
+{
+	regs->addr = OV5670_COARSE_TIME_ADDR_1;
+	regs->val = (coarse_time >> 12) & 0xff;
+	(regs + 1)->addr = OV5670_COARSE_TIME_ADDR_2;
+	(regs + 1)->val = (coarse_time >> 4) & 0xff;
+	(regs + 2)->addr = OV5670_COARSE_TIME_ADDR_3;
+	(regs + 2)->val = (coarse_time & 0xf) << 4;
+}
+
+static inline void ov5670_get_coarse_time_short_regs(ov5670_reg *regs,
+				u32 coarse_time)
+{
+	regs->addr = OV5670_COARSE_TIME_SHORT_ADDR_1;
+	regs->val = (coarse_time >> 12) & 0xff;
+	(regs + 1)->addr = OV5670_COARSE_TIME_SHORT_ADDR_2;
+	(regs + 1)->val = (coarse_time >> 4) & 0xff;
+	(regs + 2)->addr = OV5670_COARSE_TIME_SHORT_ADDR_3;
+	(regs + 2)->val = (coarse_time & 0xf) << 4;
+}
+
+static inline void ov5670_get_gain_regs(ov5670_reg *regs,
+				u16 gain)
+{
+	regs->addr = OV5670_GAIN_ADDR_MSB;
+	regs->val = (gain >> 8) & 0xff;
+
+	(regs + 1)->addr = OV5670_GAIN_ADDR_LSB;
+	(regs + 1)->val = (gain) & 0xff;
+}
+
+static int test_mode;
+module_param(test_mode, int, 0644);
+
+static inline int ov5670_read_reg(struct camera_common_data *s_data,
+				u16 addr, u8 *val)
+{
+	struct ov5670 *priv = (struct ov5670 *)s_data->priv;
+	int err = 0;
+	u32 reg_val = 0;
+
+	err = regmap_read(priv->regmap, addr, &reg_val);
+	*val = reg_val & 0xFF;
+
+	return err;
+}
+
+static int ov5670_write_reg(struct camera_common_data *s_data, u16 addr, u8 val)
+{
+	int err;
+	struct ov5670 *priv = (struct ov5670 *)s_data->priv;
+
+	err = regmap_write(priv->regmap, addr, val);
+	if (err)
+		pr_err("%s:i2c write failed, %x = %x\n",
+			__func__, addr, val);
+
+	return err;
+}
+
+static int ov5670_write_table(struct ov5670 *priv,
+			      const ov5670_reg table[])
+{
+	return regmap_util_write_table_8(priv->regmap,
+					 table,
+					 NULL, 0,
+					 OV5670_TABLE_WAIT_MS,
+					 OV5670_TABLE_END);
+}
+
+static void ov5670_gpio_set(struct ov5670 *priv,
+			    unsigned int gpio, int val)
+{
+	if (priv->pdata && priv->pdata->use_cam_gpio)
+		cam_gpio_ctrl(&priv->i2c_client->dev, gpio, val, 1);
+	else {
+		if (gpio_cansleep(gpio))
+			gpio_set_value_cansleep(gpio, val);
+		else
+			gpio_set_value(gpio, val);
+	}
+}
+
+static int ov5670_power_on(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct ov5670 *priv = (struct ov5670 *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+	u32 frame_time;
+
+	dev_dbg(&priv->i2c_client->dev, "%s: power on\n", __func__);
+
+	if (priv->pdata && priv->pdata->power_on) {
+		err = priv->pdata->power_on(pw);
+		if (err)
+			pr_err("%s failed.\n", __func__);
+		else
+			pw->state = SWITCH_ON;
+		return err;
+	}
+
+	/* sleeps calls in the sequence below are for internal device
+	 * signal propagation as specified by sensor vendor */
+
+	if (pw->avdd)
+		err = regulator_enable(pw->avdd);
+	if (err)
+		goto ov5670_avdd_fail;
+
+	if (pw->dvdd) {
+		err = regulator_enable(pw->dvdd);
+		dev_dbg(&priv->i2c_client->dev, "%s: power on - enable dvdd\n", __func__);
+	}
+	if (err)
+		goto ov5670_dvdd_fail;
+
+	usleep_range(1, 2);
+	if (pw->pwdn_gpio)
+		ov5670_gpio_set(priv, pw->pwdn_gpio, 1);
+
+	/*
+	 * datasheet 2.9: reset requires ~2ms settling time
+	 * a power on reset is generated after core power becomes stable
+	 */
+	usleep_range(2000, 2010);
+
+	if (pw->reset_gpio)
+		ov5670_gpio_set(priv, pw->reset_gpio, 1);
+
+	/* datasheet fig 2-9: t3 */
+	usleep_range(2000, 2010);
+
+	pw->state = SWITCH_ON;
+
+	/* need SW standby LP11 for mipical.
+	 * sensor default is LP00, this will transition to LP11 */
+	ov5670_write_reg(s_data, 0x0100, 0x1);
+	ov5670_write_reg(s_data, 0x0100, 0x0);
+	/*
+	 * Sleep to allow SW reset to settle into LP11. After writing
+	 * 0x1, according to the datasheet, it could take the remainder
+	 * of the frame time to settle.  Streaming too soon after this
+	 * may have unintended consequences.
+	 */
+	frame_time = OV5670_DEFAULT_FRAME_LENGTH *
+			OV5670_DEFAULT_LINE_LENGTH / OV5670_DEFAULT_PIXEL_CLOCK;
+	usleep_range(frame_time, frame_time + 1000);
+
+	return 0;
+
+ov5670_dvdd_fail:
+	regulator_disable(pw->avdd);
+
+ov5670_avdd_fail:
+	pr_err("%s failed.\n", __func__);
+	return -ENODEV;
+}
+
+static int ov5670_power_off(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct ov5670 *priv = (struct ov5670 *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+
+	dev_dbg(&priv->i2c_client->dev, "%s: power off\n", __func__);
+
+	if (priv->pdata && priv->pdata->power_off) {
+		err = priv->pdata->power_off(pw);
+		if (!err) {
+			goto power_off_done;
+		} else {
+			pr_err("%s failed.\n", __func__);
+			return err;
+		}
+	}
+
+	/* sleeps calls in the sequence below are for internal device
+	 * signal propagation as specified by sensor vendor */
+
+	usleep_range(21, 25);
+	if (pw->pwdn_gpio)
+		ov5670_gpio_set(priv, pw->pwdn_gpio, 0);
+	usleep_range(1, 2);
+	if (pw->reset_gpio)
+		ov5670_gpio_set(priv, pw->reset_gpio, 0);
+
+	/* datasheet 2.9: reset requires ~2ms settling time*/
+	usleep_range(2000, 2010);
+
+	if (pw->dvdd)
+		regulator_disable(pw->dvdd);
+	if (pw->avdd)
+		regulator_disable(pw->avdd);
+
+power_off_done:
+	pw->state = SWITCH_OFF;
+	return 0;
+}
+
+static int ov5670_power_put(struct ov5670 *priv)
+{
+	struct camera_common_power_rail *pw = &priv->power;
+
+	if (unlikely(!pw))
+		return -EFAULT;
+
+	if (likely(pw->avdd))
+		regulator_put(pw->avdd);
+
+	if (likely(pw->dvdd))
+		regulator_put(pw->dvdd);
+
+	pw->avdd = NULL;
+	pw->dvdd = NULL;
+
+	if (priv->pdata && priv->pdata->use_cam_gpio)
+		cam_gpio_deregister(&priv->i2c_client->dev, pw->pwdn_gpio);
+	else {
+		gpio_free(pw->pwdn_gpio);
+		gpio_free(pw->reset_gpio);
+	}
+
+	return 0;
+}
+
+static int ov5670_power_get(struct ov5670 *priv)
+{
+	struct camera_common_power_rail *pw = &priv->power;
+	struct camera_common_pdata *pdata = priv->pdata;
+	const char *mclk_name;
+	const char *parentclk_name;
+	struct clk *parent;
+	int err = 0, ret = 0;
+
+	if (!pdata) {
+		dev_err(&priv->i2c_client->dev, "pdata missing\n");
+		return -EFAULT;
+	}
+
+	mclk_name = pdata->mclk_name ?
+		    pdata->mclk_name : "cam_mclk1";
+	pw->mclk = devm_clk_get(&priv->i2c_client->dev, mclk_name);
+	if (IS_ERR(pw->mclk)) {
+		dev_err(&priv->i2c_client->dev,
+			"unable to get clock %s\n", mclk_name);
+		return PTR_ERR(pw->mclk);
+	}
+
+	parentclk_name = pdata->parentclk_name;
+	if (parentclk_name) {
+		parent = devm_clk_get(&priv->i2c_client->dev, parentclk_name);
+		if (IS_ERR(parent)) {
+			dev_err(&priv->i2c_client->dev,
+				"unable to get parent clcok %s",
+				parentclk_name);
+		} else
+			clk_set_parent(pw->mclk, parent);
+	}
+
+
+	/* analog 2.8v */
+	err |= camera_common_regulator_get(&priv->i2c_client->dev,
+			&pw->avdd, pdata->regulators.avdd);
+	/* IO 1.2v */
+	err |= camera_common_regulator_get(&priv->i2c_client->dev,
+			&pw->dvdd, pdata->regulators.dvdd);
+
+	if (!err) {
+		pw->reset_gpio = pdata->reset_gpio;
+		pw->pwdn_gpio = pdata->pwdn_gpio;
+	}
+
+	if (pdata->use_cam_gpio) {
+		err = cam_gpio_register(&priv->i2c_client->dev, pw->pwdn_gpio);
+		if (err)
+			dev_err(&priv->i2c_client->dev,
+				"%s ERR can't register cam gpio %u!\n",
+				 __func__, pw->pwdn_gpio);
+	} else {
+		ret = gpio_request(pw->pwdn_gpio, "cam_pwdn_gpio");
+		if (ret < 0)
+			dev_dbg(&priv->i2c_client->dev,
+				"%s can't request pwdn_gpio %d\n",
+				__func__, ret);
+		ret = gpio_request(pw->reset_gpio, "cam_reset_gpio");
+		if (ret < 0)
+			dev_dbg(&priv->i2c_client->dev,
+				"%s can't request reset_gpio %d\n",
+				__func__, ret);
+	}
+
+
+	pw->state = SWITCH_OFF;
+	return err;
+}
+
+static int ov5670_set_gain(struct ov5670 *priv, s32 val);
+static int ov5670_set_frame_length(struct ov5670 *priv, s32 val);
+static int ov5670_set_coarse_time(struct ov5670 *priv, s32 val);
+static int ov5670_set_coarse_time_short(struct ov5670 *priv, s32 val);
+
+static int ov5670_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct ov5670 *priv = (struct ov5670 *)s_data->priv;
+	struct v4l2_control control;
+	int err;
+	u32 frame_time;
+	u8 val;
+
+	dev_dbg(&client->dev, "%s++\n", __func__);
+
+	if (!enable) {
+		ov5670_update_ctrl_range(priv, OV5670_MAX_FRAME_LENGTH);
+
+		err = ov5670_write_table(priv,
+			mode_table[OV5670_MODE_STOP_STREAM]);
+		if (err)
+			return err;
+
+		/*
+		 * Wait for one frame to make sure sensor is set to
+		 * software standby in V-blank
+		 *
+		 * frame_time = frame length rows * Tline
+		 * Tline = line length / pixel clock (in MHz)
+		 */
+		frame_time = priv->frame_length *
+			OV5670_DEFAULT_LINE_LENGTH / OV5670_DEFAULT_PIXEL_CLOCK;
+
+		usleep_range(frame_time, frame_time + 1000);
+		return 0;
+	}
+
+	// setup pll
+	err = ov5670_write_table(priv, ov5670_pll_840mbps);
+	if (err)
+		goto exit;
+
+	err = ov5670_write_table(priv, mode_table[s_data->mode]);
+	if (err)
+		goto exit;
+
+
+	if (s_data->override_enable) {
+		/*
+		 * write list of override regs for the asking frame length,
+		 * coarse integration time, and gain. Failures to write
+		 * overrides are non-fatal
+		 */
+		control.id = TEGRA_CAMERA_CID_GAIN;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		err |= ov5670_set_gain(priv, control.value);
+		if (err)
+			dev_dbg(&client->dev, "%s: warning gain override failed\n",
+				__func__);
+
+		control.id = TEGRA_CAMERA_CID_FRAME_LENGTH;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		err |= ov5670_set_frame_length(priv, control.value);
+		if (err)
+			dev_dbg(&client->dev,
+				"%s: warning frame length override failed\n",
+				__func__);
+
+		control.id = TEGRA_CAMERA_CID_COARSE_TIME;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		err |= ov5670_set_coarse_time(priv, control.value);
+		if (err)
+			dev_dbg(&client->dev,
+				"%s: warning coarse time override failed\n",
+				__func__);
+
+		control.id = TEGRA_CAMERA_CID_COARSE_TIME_SHORT;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		err |= ov5670_set_coarse_time_short(priv, control.value);
+		if (err)
+			dev_dbg(&client->dev,
+				"%s: warning coarse time short override failed\n",
+				__func__);
+	}
+
+	err = ov5670_write_table(priv, mode_table[OV5670_MODE_START_STREAM]);
+	if (err)
+		goto exit;
+	if (priv->pdata->v_flip) {
+		ov5670_read_reg(priv->s_data, OV5670_TIMING_REG20, &val);
+		ov5670_write_reg(priv->s_data, OV5670_TIMING_REG20,
+				 val | VERTICAL_FLIP);
+	}
+	if (priv->pdata->h_mirror) {
+		ov5670_read_reg(priv->s_data, OV5670_TIMING_REG21, &val);
+		ov5670_write_reg(priv->s_data, OV5670_TIMING_REG21,
+				 val | HORIZONTAL_MIRROR_MASK);
+	} else {
+		ov5670_read_reg(priv->s_data, OV5670_TIMING_REG21, &val);
+		ov5670_write_reg(priv->s_data, OV5670_TIMING_REG21,
+				 val & (~HORIZONTAL_MIRROR_MASK));
+	}
+	if (test_mode)
+		err = ov5670_write_table(priv,
+			mode_table[OV5670_MODE_TEST_PATTERN]);
+
+	dev_dbg(&client->dev, "%s--\n", __func__);
+	return 0;
+exit:
+	dev_dbg(&client->dev, "%s: error setting stream\n", __func__);
+	return err;
+}
+
+static int ov5670_g_input_status(struct v4l2_subdev *sd, u32 *status)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct ov5670 *priv = (struct ov5670 *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+
+	*status = pw->state == SWITCH_ON;
+	return 0;
+}
+
+static struct v4l2_subdev_video_ops ov5670_subdev_video_ops = {
+	.s_stream	= ov5670_s_stream,
+	.g_mbus_config	= camera_common_g_mbus_config,
+	.g_input_status = ov5670_g_input_status,
+};
+
+static struct v4l2_subdev_core_ops ov5670_subdev_core_ops = {
+	.s_power	= camera_common_s_power,
+};
+
+static int ov5670_get_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	return camera_common_g_fmt(sd, &format->format);
+}
+
+static int ov5670_set_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	int ret;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		ret = camera_common_try_fmt(sd, &format->format);
+	else
+		ret = camera_common_s_fmt(sd, &format->format);
+
+	return ret;
+}
+
+static struct v4l2_subdev_pad_ops ov5670_subdev_pad_ops = {
+	.set_fmt = ov5670_set_fmt,
+	.get_fmt = ov5670_get_fmt,
+	.enum_mbus_code = camera_common_enum_mbus_code,
+	.enum_frame_size	= camera_common_enum_framesizes,
+	.enum_frame_interval	= camera_common_enum_frameintervals,
+};
+
+static struct v4l2_subdev_ops ov5670_subdev_ops = {
+	.core	= &ov5670_subdev_core_ops,
+	.video	= &ov5670_subdev_video_ops,
+	.pad	= &ov5670_subdev_pad_ops,
+};
+
+static struct of_device_id ov5670_of_match[] = {
+	{ .compatible = "nvidia,ov5670", },
+	{ },
+};
+
+static struct camera_common_sensor_ops ov5670_common_ops = {
+	.power_on = ov5670_power_on,
+	.power_off = ov5670_power_off,
+	.write_reg = ov5670_write_reg,
+	.read_reg = ov5670_read_reg,
+};
+
+static int ov5670_set_group_hold(struct ov5670 *priv)
+{
+	int err;
+	int gh_prev = switch_ctrl_qmenu[priv->group_hold_prev];
+
+	if (priv->group_hold_en == true && gh_prev == SWITCH_OFF) {
+		/* enter group hold */
+		err = ov5670_write_reg(priv->s_data,
+				       OV5670_GROUP_HOLD_ADDR, 0x01);
+		if (err)
+			goto fail;
+
+		priv->group_hold_prev = 1;
+
+		dev_dbg(&priv->i2c_client->dev,
+			 "%s: enter group hold\n", __func__);
+	} else if (priv->group_hold_en == false && gh_prev == SWITCH_ON) {
+		/* leave group hold */
+		err = ov5670_write_reg(priv->s_data,
+				       OV5670_GROUP_HOLD_ADDR, 0x11);
+		if (err)
+			goto fail;
+
+		err = ov5670_write_reg(priv->s_data,
+				       OV5670_GROUP_HOLD_ADDR, 0x61);
+		if (err)
+			goto fail;
+
+		priv->group_hold_prev = 0;
+
+		dev_dbg(&priv->i2c_client->dev,
+			 "%s: leave group hold\n", __func__);
+	}
+
+	return 0;
+
+fail:
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: Group hold control error\n", __func__);
+	return err;
+}
+
+static u16 ov5670_to_real_gain(u32 rep, int shift)
+{
+	u16 gain;
+	int gain_int;
+	int gain_dec;
+	int min_int = (1 << shift);
+
+	if (rep < OV5670_MIN_GAIN)
+		rep = OV5670_MIN_GAIN;
+	else if (rep > OV5670_MAX_GAIN)
+		rep = OV5670_MAX_GAIN;
+
+	gain_int = (int)(rep >> shift);
+	gain_dec = (int)(rep & ~(0xffff << shift));
+
+	/* derived from formulat gain = (x * 16 + 0.5) */
+	gain = ((gain_int * min_int + gain_dec) * 32 + min_int) / (2 * min_int);
+
+	return gain;
+}
+
+static int ov5670_set_gain(struct ov5670 *priv, s32 val)
+{
+	ov5670_reg reg_list[2];
+	int err;
+	u16 gain;
+	int i;
+
+	if (!priv->group_hold_prev)
+		ov5670_set_group_hold(priv);
+
+	/* translate value */
+	gain = ov5670_to_real_gain((u32)val, OV5670_GAIN_SHIFT);
+
+	ov5670_get_gain_regs(reg_list, gain);
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: gain %04x val: %04x\n", __func__, val, gain);
+
+	for (i = 0; i < 2; i++) {
+		err = ov5670_write_reg(priv->s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: GAIN control error\n", __func__);
+	return err;
+}
+
+static void ov5670_update_ctrl_range(struct ov5670 *priv, s32 frame_length)
+{
+	struct v4l2_ctrl *ctrl = NULL;
+	int ctrl_ids[2] = {TEGRA_CAMERA_CID_COARSE_TIME,
+			TEGRA_CAMERA_CID_COARSE_TIME_SHORT};
+	s32 max, min, def;
+	int i, j;
+
+	for (i = 0; i < ARRAY_SIZE(ctrl_ids); i++) {
+		for (j = 0; j < priv->numctrls; j++) {
+			if (priv->ctrls[j]->id == ctrl_ids[i]) {
+				ctrl = priv->ctrls[j];
+				break;
+			}
+		}
+
+		if (j == priv->numctrls) {
+			dev_err(&priv->i2c_client->dev,
+				"could not find ctrl %x\n",
+				ctrl_ids[i]);
+			continue;
+		}
+
+		max = frame_length - OV5670_MAX_COARSE_DIFF;
+		/* clamp the value in case above is negative */
+		max = clamp_val(max, OV5670_MIN_EXPOSURE_COARSE,
+			OV5670_MAX_EXPOSURE_COARSE);
+		min = OV5670_MIN_EXPOSURE_COARSE;
+		def = clamp_val(OV5670_DEFAULT_EXPOSURE_COARSE, min, max);
+		if (__v4l2_ctrl_modify_range(ctrl, min, max, 1, def))
+			dev_err(&priv->i2c_client->dev,
+				"ctrl %x: range update failed\n",
+				ctrl_ids[i]);
+	}
+
+}
+
+static int ov5670_set_frame_length(struct ov5670 *priv, s32 val)
+{
+	ov5670_reg reg_list[2];
+	int err;
+	u32 frame_length;
+	int i;
+
+	if (!priv->group_hold_prev)
+		ov5670_set_group_hold(priv);
+
+	frame_length = (u32)val;
+
+	ov5670_get_frame_length_regs(reg_list, frame_length);
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: val: %d\n", __func__, frame_length);
+
+	for (i = 0; i < 2; i++) {
+		err = ov5670_write_reg(priv->s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+	priv->frame_length = frame_length;
+
+	ov5670_update_ctrl_range(priv, val);
+	return 0;
+
+fail:
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: FRAME_LENGTH control error\n", __func__);
+	return err;
+}
+
+static int ov5670_set_coarse_time(struct ov5670 *priv, s32 val)
+{
+	ov5670_reg reg_list[3];
+	int err;
+	u32 coarse_time;
+	int i;
+
+	if (!priv->group_hold_prev)
+		ov5670_set_group_hold(priv);
+
+	coarse_time = (u32)val;
+
+	ov5670_get_coarse_time_regs(reg_list, coarse_time);
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: val: %d\n", __func__, coarse_time);
+
+	for (i = 0; i < 3; i++) {
+		err = ov5670_write_reg(priv->s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: COARSE_TIME control error\n", __func__);
+	return err;
+}
+
+static int ov5670_set_coarse_time_short(struct ov5670 *priv, s32 val)
+{
+	ov5670_reg reg_list[3];
+	int err;
+	struct v4l2_control hdr_control;
+	int hdr_en;
+	u32 coarse_time_short;
+	int i;
+
+	if (!priv->group_hold_prev)
+		ov5670_set_group_hold(priv);
+
+	/* check hdr enable ctrl */
+	hdr_control.id = TEGRA_CAMERA_CID_HDR_EN;
+
+	err = camera_common_g_ctrl(priv->s_data, &hdr_control);
+	if (err < 0) {
+		dev_err(&priv->i2c_client->dev,
+			"could not find device ctrl.\n");
+		return err;
+	}
+
+	hdr_en = switch_ctrl_qmenu[hdr_control.value];
+	if (hdr_en == SWITCH_OFF)
+		return 0;
+
+	coarse_time_short = (u32)val;
+
+	ov5670_get_coarse_time_short_regs(reg_list, coarse_time_short);
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: val: %d\n", __func__, coarse_time_short);
+
+	for (i = 0; i < 3; i++) {
+		err = ov5670_write_reg(priv->s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: COARSE_TIME_SHORT control error\n", __func__);
+	return err;
+}
+
+static int ov5670_eeprom_device_release(struct ov5670 *priv)
+{
+	int i;
+
+	for (i = 0; i < OV5670_EEPROM_NUM_BLOCKS; i++) {
+		if (priv->eeprom[i].i2c_client != NULL) {
+			i2c_unregister_device(priv->eeprom[i].i2c_client);
+			priv->eeprom[i].i2c_client = NULL;
+		}
+	}
+
+	return 0;
+}
+
+static int ov5670_eeprom_device_init(struct ov5670 *priv)
+{
+	char *dev_name = "eeprom_ov5670";
+	static struct regmap_config eeprom_regmap_config = {
+		.reg_bits = 8,
+		.val_bits = 8,
+	};
+	int i;
+	int err;
+
+	if (!priv->pdata->has_eeprom)
+		return -EINVAL;
+
+	for (i = 0; i < OV5670_EEPROM_NUM_BLOCKS; i++) {
+		priv->eeprom[i].adap = i2c_get_adapter(
+				priv->i2c_client->adapter->nr);
+		memset(&priv->eeprom[i].brd, 0, sizeof(priv->eeprom[i].brd));
+		strncpy(priv->eeprom[i].brd.type, dev_name,
+				sizeof(priv->eeprom[i].brd.type));
+		priv->eeprom[i].brd.addr = OV5670_EEPROM_ADDRESS + i;
+		priv->eeprom[i].i2c_client = i2c_new_device(
+				priv->eeprom[i].adap, &priv->eeprom[i].brd);
+
+		priv->eeprom[i].regmap = devm_regmap_init_i2c(
+			priv->eeprom[i].i2c_client, &eeprom_regmap_config);
+		if (IS_ERR(priv->eeprom[i].regmap)) {
+			err = PTR_ERR(priv->eeprom[i].regmap);
+			ov5670_eeprom_device_release(priv);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static int ov5670_read_eeprom(struct ov5670 *priv,
+				struct v4l2_ctrl *ctrl)
+{
+	int err, i;
+
+	for (i = 0; i < OV5670_EEPROM_NUM_BLOCKS; i++) {
+		err = regmap_bulk_read(priv->eeprom[i].regmap, 0,
+			&priv->eeprom_buf[i * OV5670_EEPROM_BLOCK_SIZE],
+			OV5670_EEPROM_BLOCK_SIZE);
+		if (err)
+			return err;
+	}
+
+	for (i = 0; i < OV5670_EEPROM_SIZE; i++)
+		sprintf(&ctrl->p_new.p_char[i*2], "%02x",
+			priv->eeprom_buf[i]);
+	return 0;
+}
+
+static int ov5670_write_eeprom(struct ov5670 *priv,
+				char *string)
+{
+	int err;
+	int i;
+	u8 curr[3];
+	unsigned long data;
+
+	for (i = 0; i < OV5670_EEPROM_SIZE; i++) {
+		curr[0] = string[i*2];
+		curr[1] = string[i*2+1];
+		curr[2] = '\0';
+
+		err = kstrtol(curr, 16, &data);
+		if (err) {
+			dev_err(&priv->i2c_client->dev,
+				"invalid eeprom string\n");
+			return -EINVAL;
+		}
+
+		priv->eeprom_buf[i] = (u8)data;
+		err = regmap_write(priv->eeprom[i >> 8].regmap,
+				   i & 0xFF, (u8)data);
+		if (err)
+			return err;
+		msleep(20);
+	}
+	return 0;
+}
+
+static int ov5670_read_otp_bank(struct ov5670 *priv,
+				u8 *buf, int bank, u16 addr, int size)
+{
+	int err;
+
+	/* sleeps calls in the sequence below are for internal device
+	 * signal propagation as specified by sensor vendor */
+
+	usleep_range(10000, 11000);
+	err = ov5670_write_table(priv, mode_table[OV5670_MODE_START_STREAM]);
+	if (err)
+		return err;
+
+	err = ov5670_write_reg(priv->s_data, OV5670_OTP_BANK_SELECT_ADDR,
+			       0xC0 | bank);
+	if (err)
+		return err;
+
+	err = ov5670_write_reg(priv->s_data, OV5670_OTP_LOAD_CTRL_ADDR, 0x01);
+	if (err)
+		return err;
+
+	usleep_range(10000, 11000);
+	err = regmap_bulk_read(priv->regmap, addr, buf, size);
+	if (err)
+		return err;
+
+	err = ov5670_write_table(priv,
+			mode_table[OV5670_MODE_STOP_STREAM]);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int ov5670_otp_setup(struct ov5670 *priv)
+{
+	int err;
+	int i;
+	struct v4l2_ctrl *ctrl;
+	u8 otp_buf[OV5670_OTP_SIZE];
+
+	err = camera_common_s_power(priv->subdev, true);
+	if (err)
+		return -ENODEV;
+
+	for (i = 0; i < OV5670_OTP_NUM_BANKS; i++) {
+		err = ov5670_read_otp_bank(priv,
+					&otp_buf[i * OV5670_OTP_BANK_SIZE],
+					i,
+					OV5670_OTP_BANK_START_ADDR,
+					OV5670_OTP_BANK_SIZE);
+		if (err) {
+			dev_err(&priv->i2c_client->dev,
+				"could not read otp bank\n");
+			goto ret;
+		}
+	}
+
+	ctrl = v4l2_ctrl_find(&priv->ctrl_handler, TEGRA_CAMERA_CID_OTP_DATA);
+	if (!ctrl) {
+		dev_err(&priv->i2c_client->dev,
+			"could not find device ctrl.\n");
+		err = -EINVAL;
+		goto ret;
+	}
+
+	for (i = 0; i < OV5670_OTP_SIZE; i++)
+		sprintf(&ctrl->p_new.p_char[i*2], "%02x",
+			otp_buf[i]);
+	ctrl->p_cur.p_char = ctrl->p_new.p_char;
+
+ret:
+	camera_common_s_power(priv->subdev, false);
+
+	return err;
+}
+
+static int ov5670_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov5670 *priv =
+		container_of(ctrl->handler, struct ov5670, ctrl_handler);
+	int err = 0;
+
+	if (priv->power.state == SWITCH_OFF)
+		return 0;
+
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_EEPROM_DATA:
+		err = ov5670_read_eeprom(priv, ctrl);
+		if (err)
+			return err;
+		break;
+	default:
+			pr_err("%s: unknown ctrl id.\n", __func__);
+			return -EINVAL;
+	}
+
+	return err;
+}
+
+static int ov5670_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov5670 *priv =
+		container_of(ctrl->handler, struct ov5670, ctrl_handler);
+	int err = 0;
+
+	if (priv->power.state == SWITCH_OFF)
+		return 0;
+
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_GAIN:
+		err = ov5670_set_gain(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_FRAME_LENGTH:
+		err = ov5670_set_frame_length(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_COARSE_TIME:
+		err = ov5670_set_coarse_time(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_COARSE_TIME_SHORT:
+		err = ov5670_set_coarse_time_short(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_GROUP_HOLD:
+		if (switch_ctrl_qmenu[ctrl->val] == SWITCH_ON) {
+			priv->group_hold_en = true;
+		} else {
+			priv->group_hold_en = false;
+			err = ov5670_set_group_hold(priv);
+		}
+		break;
+	case TEGRA_CAMERA_CID_EEPROM_DATA:
+		if (!ctrl->p_new.p_char[0])
+			break;
+		err = ov5670_write_eeprom(priv, ctrl->p_new.p_char);
+		if (err)
+			return err;
+		break;
+	case TEGRA_CAMERA_CID_HDR_EN:
+		break;
+	default:
+		pr_err("%s: unknown ctrl id.\n", __func__);
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static int ov5670_ctrls_init(struct ov5670 *priv, bool eeprom_ctrl)
+{
+	struct i2c_client *client = priv->i2c_client;
+	struct camera_common_data *common_data = priv->s_data;
+	struct v4l2_ctrl *ctrl;
+	int numctrls;
+	int err;
+	int i;
+
+	dev_dbg(&client->dev, "%s++\n", __func__);
+
+	numctrls = ARRAY_SIZE(ctrl_config_list);
+	v4l2_ctrl_handler_init(&priv->ctrl_handler, numctrls);
+
+	for (i = 0; i < numctrls; i++) {
+		/*
+		 * Skip control 'TEGRA_CAMERA_CID_EEPROM_DATA'
+		 * if eeprom inint err
+		 */
+		if (ctrl_config_list[i].id == TEGRA_CAMERA_CID_EEPROM_DATA) {
+			if (!eeprom_ctrl) {
+				common_data->numctrls -= 1;
+				continue;
+			}
+		}
+
+		ctrl = v4l2_ctrl_new_custom(&priv->ctrl_handler,
+			&ctrl_config_list[i], NULL);
+		if (ctrl == NULL) {
+			dev_err(&client->dev, "Failed to init %s ctrl\n",
+				ctrl_config_list[i].name);
+			continue;
+		}
+
+		if (ctrl_config_list[i].type == V4L2_CTRL_TYPE_STRING &&
+			ctrl_config_list[i].flags & V4L2_CTRL_FLAG_READ_ONLY) {
+			ctrl->p_new.p_char = devm_kzalloc(&client->dev,
+				ctrl_config_list[i].max + 1, GFP_KERNEL);
+			if (!ctrl->p_new.p_char)
+				return -ENOMEM;
+		}
+		priv->ctrls[i] = ctrl;
+	}
+
+	priv->numctrls = numctrls;
+	priv->subdev->ctrl_handler = &priv->ctrl_handler;
+	if (priv->ctrl_handler.error) {
+		dev_err(&client->dev, "Error %d adding controls\n",
+			priv->ctrl_handler.error);
+		err = priv->ctrl_handler.error;
+		goto error;
+	}
+
+	err = v4l2_ctrl_handler_setup(&priv->ctrl_handler);
+	if (err) {
+		dev_err(&client->dev,
+			"Error %d setting default controls\n", err);
+		goto error;
+	}
+
+	err = ov5670_otp_setup(priv);
+	if (err) {
+		dev_err(&client->dev,
+			"Error %d reading otp data\n", err);
+		goto error;
+	}
+
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	return err;
+}
+
+MODULE_DEVICE_TABLE(of, ov5670_of_match);
+
+static struct camera_common_pdata *ov5670_parse_dt(struct i2c_client *client)
+{
+	struct device_node *node = client->dev.of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	const struct of_device_id *match;
+	int gpio;
+	int err;
+	struct camera_common_pdata *ret = NULL;
+
+	if (!node)
+		return NULL;
+
+	match = of_match_device(ov5670_of_match, &client->dev);
+	if (!match) {
+		dev_err(&client->dev, "Failed to find matching dt id\n");
+		return NULL;
+	}
+
+	board_priv_pdata = devm_kzalloc(&client->dev,
+			   sizeof(*board_priv_pdata), GFP_KERNEL);
+	if (!board_priv_pdata)
+		return NULL;
+
+	err = camera_common_parse_clocks(&client->dev, board_priv_pdata);
+	if (err) {
+		dev_err(&client->dev, "Failed to find clocks\n");
+		goto error;
+	}
+
+	gpio = of_get_named_gpio(node, "pwdn-gpios", 0);
+	if (gpio < 0) {
+		if (gpio == -EPROBE_DEFER) {
+			ret = ERR_PTR(-EPROBE_DEFER);
+			goto error;
+		}
+		dev_err(&client->dev, "pwdn gpios not in DT\n");
+		goto error;
+	}
+	board_priv_pdata->pwdn_gpio = (unsigned int)gpio;
+
+	gpio = of_get_named_gpio(node, "reset-gpios", 0);
+	if (gpio < 0) {
+		/* reset-gpio is not absolutely needed */
+		if (gpio == -EPROBE_DEFER) {
+			ret = ERR_PTR(-EPROBE_DEFER);
+			goto error;
+		}
+		dev_dbg(&client->dev, "reset gpios not in DT\n");
+		gpio = 0;
+	}
+	board_priv_pdata->reset_gpio = (unsigned int)gpio;
+
+	board_priv_pdata->use_cam_gpio =
+		of_property_read_bool(node, "cam,use-cam-gpio");
+
+	err = of_property_read_string(node, "avdd-reg",
+			&board_priv_pdata->regulators.avdd);
+	if (err) {
+		dev_err(&client->dev, "avdd-reg not in DT\n");
+		goto error;
+	}
+	err = of_property_read_string(node, "dvdd-reg",
+			&board_priv_pdata->regulators.dvdd);
+	if (err) {
+		dev_err(&client->dev, "dvdd-reg not in DT\n");
+		goto error;
+	}
+
+	board_priv_pdata->has_eeprom =
+		of_property_read_bool(node, "has-eeprom");
+	board_priv_pdata->v_flip = of_property_read_bool(node, "vertical-flip");
+	board_priv_pdata->h_mirror = of_property_read_bool(node,
+							 "horizontal-mirror");
+	return board_priv_pdata;
+
+error:
+	devm_kfree(&client->dev, board_priv_pdata);
+	return ret;
+}
+
+static int ov5670_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev_dbg(&client->dev, "%s:\n", __func__);
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops ov5670_subdev_internal_ops = {
+	.open = ov5670_open,
+};
+
+static const struct media_entity_operations ov5670_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static int ov5670_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct camera_common_data *common_data;
+	struct device_node *node = client->dev.of_node;
+	struct ov5670 *priv;
+	int err;
+
+	pr_info("[OV5670]: probing v4l2 sensor.\n");
+
+	if (!IS_ENABLED(CONFIG_OF) || !node)
+		return -EINVAL;
+
+	common_data = devm_kzalloc(&client->dev,
+			    sizeof(struct camera_common_data), GFP_KERNEL);
+	if (!common_data)
+		return -ENOMEM;
+
+	priv = devm_kzalloc(&client->dev,
+			    sizeof(struct ov5670) + sizeof(struct v4l2_ctrl *) *
+			    ARRAY_SIZE(ctrl_config_list),
+			    GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->regmap = devm_regmap_init_i2c(client, &ov5670_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(&client->dev,
+			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
+		return -ENODEV;
+	}
+
+	priv->pdata = ov5670_parse_dt(client);
+	if (PTR_ERR(priv->pdata) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	if (!priv->pdata) {
+		dev_err(&client->dev, "unable to get platform data\n");
+		return -EFAULT;
+	}
+
+	common_data->ops		= &ov5670_common_ops;
+	common_data->ctrl_handler	= &priv->ctrl_handler;
+	common_data->dev		= &client->dev;
+	common_data->frmfmt		= ov5670_frmfmt;
+	common_data->colorfmt		= camera_common_find_datafmt(
+					  OV5670_DEFAULT_DATAFMT);
+	common_data->power		= &priv->power;
+	common_data->ctrls		= priv->ctrls;
+	common_data->priv		= (void *)priv;
+	common_data->numctrls		= ARRAY_SIZE(ctrl_config_list);
+	common_data->numfmts		= ARRAY_SIZE(ov5670_frmfmt);
+	common_data->def_mode		= OV5670_DEFAULT_MODE;
+	common_data->def_width		= OV5670_DEFAULT_WIDTH;
+	common_data->def_height		= OV5670_DEFAULT_HEIGHT;
+	common_data->fmt_width		= common_data->def_width;
+	common_data->fmt_height		= common_data->def_height;
+	common_data->def_clk_freq	= OV5670_DEFAULT_CLK_FREQ;
+
+	priv->i2c_client = client;
+	priv->s_data			= common_data;
+	priv->subdev			= &common_data->subdev;
+	priv->subdev->dev		= &client->dev;
+	priv->s_data->dev		= &client->dev;
+
+	err = ov5670_power_get(priv);
+	if (err)
+		return err;
+
+	err = camera_common_initialize(common_data, "ov5670");
+	if (err) {
+		dev_err(&client->dev, "Failed to initialize ov5670.\n");
+		return err;
+	}
+
+
+	v4l2_i2c_subdev_init(priv->subdev, client, &ov5670_subdev_ops);
+
+	/* eeprom interface */
+	err = ov5670_eeprom_device_init(priv);
+	if (err && priv->pdata->has_eeprom)
+		dev_err(&client->dev,
+			"Failed to allocate eeprom reg map: %d\n", err);
+
+	err = ov5670_ctrls_init(priv, !err);
+	if (err)
+		return err;
+
+	priv->subdev->internal_ops = &ov5670_subdev_internal_ops;
+	priv->subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+			       V4L2_SUBDEV_FL_HAS_EVENTS;
+
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	priv->subdev->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+	priv->subdev->entity.ops = &ov5670_media_ops;
+	err = media_entity_init(&priv->subdev->entity, 1, &priv->pad, 0);
+	if (err < 0) {
+		dev_err(&client->dev, "unable to init media entity\n");
+		return err;
+	}
+#endif
+
+	err = v4l2_async_register_subdev(priv->subdev);
+	if (err)
+		return err;
+
+	dev_dbg(&client->dev, "Detected OV5670 sensor\n");
+
+
+	return 0;
+}
+
+static int
+ov5670_remove(struct i2c_client *client)
+{
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct ov5670 *priv = (struct ov5670 *)s_data->priv;
+
+	v4l2_async_unregister_subdev(priv->subdev);
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	media_entity_cleanup(&priv->subdev->entity);
+#endif
+
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	ov5670_power_put(priv);
+	camera_common_cleanup(s_data);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov5670_id[] = {
+	{ "ov5670", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, ov5670_id);
+
+static struct i2c_driver ov5670_i2c_driver = {
+	.driver = {
+		.name = "ov5670",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(ov5670_of_match),
+	},
+	.probe = ov5670_probe,
+	.remove = ov5670_remove,
+	.id_table = ov5670_id,
+};
+
+module_i2c_driver(ov5670_i2c_driver);
+
+MODULE_DESCRIPTION("SoC Camera driver for Sony OV5670");
+MODULE_AUTHOR("David Wang <davidw@nvidia.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/i2c/ov5670_mode_tbls.h b/drivers/media/i2c/ov5670_mode_tbls.h
new file mode 100644
index 0000000..47abf4a
--- /dev/null
+++ b/drivers/media/i2c/ov5670_mode_tbls.h
@@ -0,0 +1,2954 @@
+/*
+ * ov5670_mode_tbls.h - ov5670 sensor mode tables
+ *
+ * Copyright (c) 2015-2017, NVIDIA CORPORATION, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __OV5670_TABLES__
+#define __OV5670_TABLES__
+
+#include <media/camera_common.h>
+
+#define OV5670_TABLE_WAIT_MS	0
+#define OV5670_TABLE_END	1
+#define OV5670_MAX_RETRIES	3
+#define OV5670_WAIT_MS		10
+
+#define ov5670_reg struct reg_8
+
+static const ov5670_reg ov5670_start[] = {
+	{0x0100, 0x01}, /* mode select streaming on */
+	{OV5670_TABLE_END, 0x00}
+};
+
+static const ov5670_reg ov5670_stop[] = {
+	{0x0100, 0x00}, /* mode select streaming on */
+	{OV5670_TABLE_END, 0x00}
+};
+
+static const ov5670_reg tp_colorbars[] = {
+	{0x4303, 0x08},
+	{0x4320, 0x80},
+
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{OV5670_TABLE_END, 0x00}
+};
+
+static const ov5670_reg ov5670_pll_840mbps[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{ 0x030a, 0x00 },
+	{ 0x0300, 0x04 },
+	{ 0x0301, 0x00 },
+	{ 0x0302, 0x78 },
+	{ 0x0304, 0x03 },
+	{ 0x0303, 0x00 },
+	{ 0x0305, 0x01 },
+	{ 0x0306, 0x01 },
+	{ 0x0312, 0x01 },
+	{ 0x030b, 0x00 },
+	{ 0x030c, 0x00 },
+	{ 0x030d, 0x1e },
+	{ 0x030f, 0x06 },
+	{ 0x030e, 0x00 },
+	{OV5670_TABLE_END, 0x00}
+};
+
+static const ov5670_reg mode_2592x1944_regs[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x3000, 0x00},
+	{0x3002, 0x21},
+	{0x3005, 0xf0},
+	{0x3007, 0x00},
+	{0x3015, 0x0f},
+	{0x3018, 0x32},
+	{0x301a, 0xf0},
+	{0x301b, 0xf0},
+	{0x301c, 0xf0},
+	{0x301d, 0xf0},
+	{0x301e, 0xf0},
+	{0x3030, 0x00},
+	{0x3031, 0x0a},
+	{0x303c, 0xff},
+	{0x303e, 0xff},
+	{0x3040, 0xf0},
+	{0x3041, 0x00},
+	{0x3042, 0xf0},
+	{0x3106, 0x11},
+	{0x3500, 0x00},
+	{0x3501, 0x80},
+	{0x3502, 0x00},
+	{0x3503, 0x04},
+	{0x3504, 0x03},
+	{0x3505, 0x83},
+	{0x3508, 0x04},
+	{0x3509, 0x00},
+	{0x350e, 0x04},
+	{0x350f, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3601, 0xc8},
+	{0x3610, 0x88},
+	{0x3612, 0x48},
+	{0x3614, 0x5b},
+	{0x3615, 0x96},
+	{0x3621, 0xd0},
+	{0x3622, 0x00},
+	{0x3623, 0x00},
+	{0x3633, 0x13},
+	{0x3634, 0x13},
+	{0x3635, 0x13},
+	{0x3636, 0x13},
+	{0x3645, 0x13},
+	{0x3646, 0x82},
+	{0x3650, 0x00},
+	{0x3652, 0xff},
+	{0x3655, 0x20},
+	{0x3656, 0xff},
+	{0x365a, 0xff},
+	{0x365e, 0xff},
+	{0x3668, 0x00},
+	{0x366a, 0x07},
+	{0x366e, 0x10},
+	{0x366d, 0x00},
+	{0x366f, 0x80},
+	{0x3700, 0x28},
+	{0x3701, 0x10},
+	{0x3702, 0x3a},
+	{0x3703, 0x19},
+	{0x3704, 0x10},
+	{0x3705, 0x00},
+	{0x3706, 0x66},
+	{0x3707, 0x08},
+	{0x3708, 0x34},
+	{0x3709, 0x40},
+	{0x370a, 0x01},
+	{0x370b, 0x1b},
+	{0x3714, 0x24},
+	{0x371a, 0x3e},
+	{0x3733, 0x00},
+	{0x3734, 0x00},
+	{0x373a, 0x05},
+	{0x373b, 0x06},
+	{0x373c, 0x0a},
+	{0x373f, 0xa0},
+	{0x3755, 0x00},
+	{0x3758, 0x00},
+	{0x375b, 0x0e},
+	{0x3766, 0x5f},
+	{0x3768, 0x00},
+	{0x3769, 0x22},
+	{0x3773, 0x08},
+	{0x3774, 0x1f},
+	{0x3776, 0x06},
+	{0x37a0, 0x88},
+	{0x37a1, 0x5c},
+	{0x37a7, 0x88},
+	{0x37a8, 0x70},
+	{0x37aa, 0x88},
+	{0x37ab, 0x48},
+	{0x37b3, 0x66},
+	{0x37c2, 0x04},
+	{0x37c5, 0x00},
+	{0x37c8, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x0c},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3804, 0x0a},
+	{0x3805, 0x33},
+	{0x3806, 0x07},
+	{0x3807, 0xa3},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x07},
+	{0x380b, 0x98},
+	{0x380c, 0x06},
+	{0x380d, 0x90},
+	{0x380e, 0x08},
+	{0x380f, 0x08},
+	{0x3811, 0x04},
+	{0x3813, 0x02},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x00},
+	{0x3817, 0x00},
+	{0x3818, 0x00},
+	{0x3819, 0x00},
+	{0x3820, 0x02},
+	{0x3821, 0x46},
+	{0x3822, 0x48},
+	{0x3826, 0x00},
+	{0x3827, 0x08},
+	{0x382a, 0x01},
+	{0x382b, 0x01},
+	{0x3830, 0x08},
+	{0x3836, 0x02},
+	{0x3837, 0x00},
+	{0x3838, 0x10},
+	{0x3841, 0xff},
+	{0x3846, 0x48},
+	{0x3861, 0x00},
+	{0x3862, 0x04},
+	{0x3863, 0x06},
+	{0x3a11, 0x01},
+	{0x3a12, 0x78},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3c00, 0x89},
+	{0x3c01, 0xab},
+	{0x3c02, 0x01},
+	{0x3c03, 0x00},
+	{0x3c04, 0x00},
+	{0x3c05, 0x03},
+	{0x3c06, 0x00},
+	{0x3c07, 0x05},
+	{0x3c0c, 0x00},
+	{0x3c0d, 0x00},
+	{0x3c0e, 0x00},
+	{0x3c0f, 0x00},
+	{0x3c40, 0x00},
+	{0x3c41, 0xa3},
+	{0x3c43, 0x7d},
+	{0x3c45, 0xd7},
+	{0x3c47, 0xfc},
+	{0x3c50, 0x05},
+	{0x3c52, 0xaa},
+	{0x3c54, 0x71},
+	{0x3c56, 0x80},
+	{0x3d85, 0x17},
+	{0x3f03, 0x00},
+	{0x3f0a, 0x00},
+	{0x3f0b, 0x00},
+	{0x4001, 0x60},
+	{0x4009, 0x0d},
+	{0x4020, 0x00},
+	{0x4021, 0x00},
+	{0x4022, 0x00},
+	{0x4023, 0x00},
+	{0x4024, 0x00},
+	{0x4025, 0x00},
+	{0x4026, 0x00},
+	{0x4027, 0x00},
+	{0x4028, 0x00},
+	{0x4029, 0x00},
+	{0x402a, 0x00},
+	{0x402b, 0x00},
+	{0x402c, 0x00},
+	{0x402d, 0x00},
+	{0x402e, 0x00},
+	{0x402f, 0x00},
+	{0x4040, 0x00},
+	{0x4041, 0x03},
+	{0x4042, 0x00},
+	{0x4043, 0x7A},
+	{0x4044, 0x00},
+	{0x4045, 0x7A},
+	{0x4046, 0x00},
+	{0x4047, 0x7A},
+	{0x4048, 0x00},
+	{0x4049, 0x7A},
+	{0x4307, 0x30},
+	{0x4500, 0x58},
+	{0x4501, 0x04},
+	{0x4502, 0x40},
+	{0x4503, 0x10},
+	{0x4508, 0xaa},
+	{0x4509, 0xaa},
+	{0x450a, 0x00},
+	{0x450b, 0x00},
+	{0x4600, 0x01},
+	{0x4601, 0x03},
+	{0x4700, 0xa4},
+	{0x4800, 0x4c},
+	{0x4816, 0x53},
+	{0x481f, 0x40},
+	{0x4837, 0x13},
+	{0x5000, 0x56},
+	{0x5001, 0x01},
+	{0x5002, 0x28},
+	{0x5004, 0x0c},
+	{0x5006, 0x0c},
+	{0x5007, 0xe0},
+	{0x5008, 0x01},
+	{0x5009, 0xb0},
+	{0x5901, 0x00},
+	{0x5a01, 0x00},
+	{0x5a03, 0x00},
+	{0x5a04, 0x0c},
+	{0x5a05, 0xe0},
+	{0x5a06, 0x09},
+	{0x5a07, 0xb0},
+	{0x5a08, 0x06},
+	{0x5e00, 0x00},
+	{0x3734, 0x40},
+	{0x5b00, 0x01},
+	{0x5b01, 0x10},
+	{0x5b02, 0x01},
+	{0x5b03, 0xdb},
+	{0x3d8c, 0x71},
+	{0x3d8d, 0xea},
+	{0x4017, 0x08},
+	{0x3618, 0x2a},
+	{0x5780, 0x3e},
+	{0x5781, 0x0f},
+	{0x5782, 0x44},
+	{0x5783, 0x02},
+	{0x5784, 0x01},
+	{0x5785, 0x01},
+	{0x5786, 0x00},
+	{0x5787, 0x04},
+	{0x5788, 0x02},
+	{0x5789, 0x0f},
+	{0x578a, 0xfd},
+	{0x578b, 0xf5},
+	{0x578c, 0xf5},
+	{0x578d, 0x03},
+	{0x578e, 0x08},
+	{0x578f, 0x0c},
+	{0x5790, 0x08},
+	{0x5791, 0x06},
+	{0x5792, 0x00},
+	{0x5793, 0x52},
+	{0x5794, 0xa3},
+	{0x3503, 0x00},
+	{0x5045, 0x05},
+	{0x4003, 0x40},
+	{0x5048, 0x40},
+	{OV5670_TABLE_END, 0x0000}
+};
+static const ov5670_reg mode_2592x1944[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3090, 0x02},
+	{0x3091, 0x0e},
+	{0x3092, 0x00},
+	{0x3093, 0x00},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x18},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x02},
+	{0x3802, 0x00},
+	{0x3803, 0x02},
+	{0x3804, 0x0a},
+	{0x3805, 0x41},
+	{0x3806, 0x07},
+	{0x3807, 0xa5},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x07},
+	{0x380b, 0x98},
+	{0x380c, 0x0a},
+	{0x380d, 0x80},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x02},
+	{0x3821, 0x1e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3d00, 0x00},
+	{0x3d01, 0x00},
+	{0x3d02, 0x00},
+	{0x3d03, 0x00},
+	{0x3d04, 0x00},
+	{0x3d05, 0x00},
+	{0x3d06, 0x00},
+	{0x3d07, 0x00},
+	{0x3d08, 0x00},
+	{0x3d09, 0x00},
+	{0x3d0a, 0x00},
+	{0x3d0b, 0x00},
+	{0x3d0c, 0x00},
+	{0x3d0d, 0x00},
+	{0x3d0e, 0x00},
+	{0x3d0f, 0x00},
+	{0x3d80, 0x00},
+	{0x3d81, 0x00},
+	{0x3d84, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_2560x1440_regs[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x3000, 0x00},
+	{0x3002, 0x21},
+	{0x3005, 0xf0},
+	{0x3007, 0x00},
+	{0x3015, 0x0f},
+	{0x3018, 0x32},
+	{0x301a, 0xf0},
+	{0x301b, 0xf0},
+	{0x301c, 0xf0},
+	{0x301d, 0xf0},
+	{0x301e, 0xf0},
+	{0x3030, 0x00},
+	{0x3031, 0x0a},
+	{0x303c, 0xff},
+	{0x303e, 0xff},
+	{0x3040, 0xf0},
+	{0x3041, 0x00},
+	{0x3042, 0xf0},
+	{0x3106, 0x11},
+	{0x3500, 0x00},
+	{0x3501, 0x80},
+	{0x3502, 0x00},
+	{0x3503, 0x04},
+	{0x3504, 0x03},
+	{0x3505, 0x83},
+	{0x3508, 0x04},
+	{0x3509, 0x00},
+	{0x350e, 0x04},
+	{0x350f, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3601, 0xc8},
+	{0x3610, 0x88},
+	{0x3612, 0x48},
+	{0x3614, 0x5b},
+	{0x3615, 0x96},
+	{0x3621, 0xd0},
+	{0x3622, 0x00},
+	{0x3623, 0x00},
+	{0x3633, 0x13},
+	{0x3634, 0x13},
+	{0x3635, 0x13},
+	{0x3636, 0x13},
+	{0x3645, 0x13},
+	{0x3646, 0x82},
+	{0x3650, 0x00},
+	{0x3652, 0xff},
+	{0x3655, 0x20},
+	{0x3656, 0xff},
+	{0x365a, 0xff},
+	{0x365e, 0xff},
+	{0x3668, 0x00},
+	{0x366a, 0x07},
+	{0x366e, 0x10},
+	{0x366d, 0x00},
+	{0x366f, 0x80},
+	{0x3700, 0x28},
+	{0x3701, 0x10},
+	{0x3702, 0x3a},
+	{0x3703, 0x19},
+	{0x3704, 0x10},
+	{0x3705, 0x00},
+	{0x3706, 0x66},
+	{0x3707, 0x08},
+	{0x3708, 0x34},
+	{0x3709, 0x40},
+	{0x370a, 0x01},
+	{0x370b, 0x1b},
+	{0x3714, 0x24},
+	{0x371a, 0x3e},
+	{0x3733, 0x00},
+	{0x3734, 0x00},
+	{0x373a, 0x05},
+	{0x373b, 0x06},
+	{0x373c, 0x0a},
+	{0x373f, 0xa0},
+	{0x3755, 0x00},
+	{0x3758, 0x00},
+	{0x375b, 0x0e},
+	{0x3766, 0x5f},
+	{0x3768, 0x00},
+	{0x3769, 0x22},
+	{0x3773, 0x08},
+	{0x3774, 0x1f},
+	{0x3776, 0x06},
+	{0x37a0, 0x88},
+	{0x37a1, 0x5c},
+	{0x37a7, 0x88},
+	{0x37a8, 0x70},
+	{0x37aa, 0x88},
+	{0x37ab, 0x48},
+	{0x37b3, 0x66},
+	{0x37c2, 0x04},
+	{0x37c5, 0x00},
+	{0x37c8, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x0c},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3804, 0x0a},
+	{0x3805, 0x33},
+	{0x3806, 0x07},
+	{0x3807, 0xa3},
+	{0x3808, 0x0a},
+	{0x3809, 0x00},
+	{0x380a, 0x05},
+	{0x380b, 0xa0},
+	{0x380c, 0x06},
+	{0x380d, 0x90},
+	{0x380e, 0x08},
+	{0x380f, 0x08},
+	{0x3811, 0x04},
+	{0x3813, 0x02},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x00},
+	{0x3817, 0x00},
+	{0x3818, 0x00},
+	{0x3819, 0x00},
+	{0x3820, 0x84},
+	{0x3821, 0x46},
+	{0x3822, 0x48},
+	{0x3826, 0x00},
+	{0x3827, 0x08},
+	{0x382a, 0x01},
+	{0x382b, 0x01},
+	{0x3830, 0x08},
+	{0x3836, 0x02},
+	{0x3837, 0x00},
+	{0x3838, 0x10},
+	{0x3841, 0xff},
+	{0x3846, 0x48},
+	{0x3861, 0x00},
+	{0x3862, 0x04},
+	{0x3863, 0x06},
+	{0x3a11, 0x01},
+	{0x3a12, 0x78},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3c00, 0x89},
+	{0x3c01, 0xab},
+	{0x3c02, 0x01},
+	{0x3c03, 0x00},
+	{0x3c04, 0x00},
+	{0x3c05, 0x03},
+	{0x3c06, 0x00},
+	{0x3c07, 0x05},
+	{0x3c0c, 0x00},
+	{0x3c0d, 0x00},
+	{0x3c0e, 0x00},
+	{0x3c0f, 0x00},
+	{0x3c40, 0x00},
+	{0x3c41, 0xa3},
+	{0x3c43, 0x7d},
+	{0x3c45, 0xd7},
+	{0x3c47, 0xfc},
+	{0x3c50, 0x05},
+	{0x3c52, 0xaa},
+	{0x3c54, 0x71},
+	{0x3c56, 0x80},
+	{0x3d85, 0x17},
+	{0x3f03, 0x00},
+	{0x3f0a, 0x00},
+	{0x3f0b, 0x00},
+	{0x4001, 0x60},
+	{0x4009, 0x0d},
+	{0x4020, 0x00},
+	{0x4021, 0x00},
+	{0x4022, 0x00},
+	{0x4023, 0x00},
+	{0x4024, 0x00},
+	{0x4025, 0x00},
+	{0x4026, 0x00},
+	{0x4027, 0x00},
+	{0x4028, 0x00},
+	{0x4029, 0x00},
+	{0x402a, 0x00},
+	{0x402b, 0x00},
+	{0x402c, 0x00},
+	{0x402d, 0x00},
+	{0x402e, 0x00},
+	{0x402f, 0x00},
+	{0x4040, 0x00},
+	{0x4041, 0x03},
+	{0x4042, 0x00},
+	{0x4043, 0x7A},
+	{0x4044, 0x00},
+	{0x4045, 0x7A},
+	{0x4046, 0x00},
+	{0x4047, 0x7A},
+	{0x4048, 0x00},
+	{0x4049, 0x7A},
+	{0x4307, 0x30},
+	{0x4500, 0x58},
+	{0x4501, 0x04},
+	{0x4502, 0x40},
+	{0x4503, 0x10},
+	{0x4508, 0xaa},
+	{0x4509, 0xaa},
+	{0x450a, 0x00},
+	{0x450b, 0x00},
+	{0x4600, 0x01},
+	{0x4601, 0x00},
+	{0x4700, 0xa4},
+	{0x4800, 0x4c},
+	{0x4816, 0x53},
+	{0x481f, 0x40},
+	{0x4837, 0x13},
+	{0x5000, 0x56},
+	{0x5001, 0x01},
+	{0x5002, 0x28},
+	{0x5004, 0x0c},
+	{0x5006, 0x0c},
+	{0x5007, 0xe0},
+	{0x5008, 0x01},
+	{0x5009, 0xb0},
+	{0x5901, 0x00},
+	{0x5a01, 0x00},
+	{0x5a03, 0x00},
+	{0x5a04, 0x0c},
+	{0x5a05, 0xe0},
+	{0x5a06, 0x09},
+	{0x5a07, 0xb0},
+	{0x5a08, 0x06},
+	{0x5e00, 0x00},
+	{0x3734, 0x40},
+	{0x5b00, 0x01},
+	{0x5b01, 0x10},
+	{0x5b02, 0x01},
+	{0x5b03, 0xdb},
+	{0x3d8c, 0x71},
+	{0x3d8d, 0xea},
+	{0x4017, 0x08},
+	{0x3618, 0x2a},
+	{0x5780, 0x3e},
+	{0x5781, 0x0f},
+	{0x5782, 0x44},
+	{0x5783, 0x02},
+	{0x5784, 0x01},
+	{0x5785, 0x01},
+	{0x5786, 0x00},
+	{0x5787, 0x04},
+	{0x5788, 0x02},
+	{0x5789, 0x0f},
+	{0x578a, 0xfd},
+	{0x578b, 0xf5},
+	{0x578c, 0xf5},
+	{0x578d, 0x03},
+	{0x578e, 0x08},
+	{0x578f, 0x0c},
+	{0x5790, 0x08},
+	{0x5791, 0x06},
+	{0x5792, 0x00},
+	{0x5793, 0x52},
+	{0x5794, 0xa3},
+	{0x5045, 0x05},
+	{0x4003, 0x40},
+	{0x5048, 0x40},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_2592x1458[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3400, 0x04},
+	{0x3401, 0x00},
+	{0x3402, 0x04},
+	{0x3403, 0x00},
+	{0x3404, 0x04},
+	{0x3405, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3600, 0xbc},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x44},
+	{0x3621, 0xb5},
+	{0x3622, 0x0c},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0xf4},
+	{0x3804, 0x0a},
+	{0x3805, 0x3f},
+	{0x3806, 0x06},
+	{0x3807, 0xb1},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x05},
+	{0x380b, 0xb2},
+	{0x380c, 0x0a},
+	{0x380d, 0x80},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x10},
+	{0x3812, 0x00},
+	{0x3813, 0x06},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x02},
+	{0x3821, 0x1e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0xfc},
+	{0x5781, 0x13},
+	{0x5782, 0x03},
+	{0x5786, 0x20},
+	{0x5787, 0x40},
+	{0x5788, 0x08},
+	{0x5789, 0x08},
+	{0x578a, 0x02},
+	{0x578b, 0x01},
+	{0x578c, 0x01},
+	{0x578d, 0x0c},
+	{0x578e, 0x02},
+	{0x578f, 0x01},
+	{0x5790, 0x01},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_1920x1080_regs[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},
+	{0x3000, 0x00},
+	{0x3002, 0x21},
+	{0x3005, 0xf0},
+	{0x3007, 0x00},
+	{0x3015, 0x0f},
+	{0x3018, 0x32},
+	{0x301a, 0xf0},
+	{0x301b, 0xf0},
+	{0x301c, 0xf0},
+	{0x301d, 0xf0},
+	{0x301e, 0xf0},
+	{0x3021, 0x03},
+	{0x3030, 0x00},
+	{0x3031, 0x0a},
+	{0x303c, 0xff},
+	{0x303e, 0xff},
+	{0x3040, 0xf0},
+	{0x3041, 0x00},
+	{0x3042, 0xf0},
+	{0x3106, 0x11},
+	{0x3500, 0x00},
+	{0x3502, 0x00},
+	{0x3503, 0x04},
+	{0x3504, 0x03},
+	{0x3505, 0x83},
+	{0x3508, 0x04},
+	{0x3509, 0x00},
+	{0x350e, 0x04},
+	{0x350f, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3601, 0xc8},
+	{0x3610, 0x88},
+	{0x3612, 0x48},
+	{0x3614, 0x5b},
+	{0x3615, 0x96},
+	{0x3621, 0xd0},
+	{0x3622, 0x00},
+	{0x3623, 0x00},
+	{0x3633, 0x13},
+	{0x3634, 0x13},
+	{0x3635, 0x13},
+	{0x3636, 0x13},
+	{0x3645, 0x13},
+	{0x3646, 0x82},
+	{0x3650, 0x00},
+	{0x3652, 0xff},
+	{0x3655, 0x20},
+	{0x3656, 0xff},
+	{0x365a, 0xff},
+	{0x365e, 0xff},
+	{0x3668, 0x00},
+	{0x366a, 0x07},
+	{0x366e, 0x10},
+	{0x366d, 0x00},
+	{0x366f, 0x80},
+	{0x3700, 0x28},
+	{0x3701, 0x10},
+	{0x3702, 0x3a},
+	{0x3703, 0x19},
+	{0x3704, 0x10},
+	{0x3705, 0x00},
+	{0x3706, 0x66},
+	{0x3707, 0x08},
+	{0x3708, 0x34},
+	{0x3709, 0x40},
+	{0x370a, 0x01},
+	{0x370b, 0x1b},
+	{0x3714, 0x24},
+	{0x371a, 0x3e},
+	{0x3733, 0x00},
+	{0x3734, 0x00},
+	{0x373a, 0x05},
+	{0x373b, 0x06},
+	{0x373c, 0x0a},
+	{0x373f, 0xa0},
+	{0x3755, 0x00},
+	{0x3758, 0x00},
+	{0x375b, 0x0e},
+	{0x3766, 0x5f},
+	{0x3768, 0x00},
+	{0x3769, 0x22},
+	{0x3773, 0x08},
+	{0x3774, 0x1f},
+	{0x3776, 0x06},
+	{0x37a0, 0x88},
+	{0x37a1, 0x5c},
+	{0x37a7, 0x88},
+	{0x37a8, 0x70},
+	{0x37aa, 0x88},
+	{0x37ab, 0x48},
+	{0x37b3, 0x66},
+	{0x37c2, 0x04},
+	{0x37c5, 0x00},
+	{0x37c8, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x0c},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3804, 0x0a},
+	{0x3805, 0x33},
+	{0x3806, 0x07},
+	{0x3807, 0xa3},
+	{0x3811, 0x04},
+	{0x3813, 0x02},
+	{0x3815, 0x01},
+	{0x3816, 0x00},
+	{0x3817, 0x00},
+	{0x3818, 0x00},
+	{0x3819, 0x00},
+	{0x3820, 0x00},
+	{0x3821, 0x06},
+	{0x3822, 0x48},
+	{0x3826, 0x00},
+	{0x3827, 0x08},
+	{0x3830, 0x08},
+	{0x3836, 0x02},
+	{0x3837, 0x00},
+	{0x3838, 0x10},
+	{0x3841, 0xff}, /* Auto size function enabled */
+	{0x3846, 0x48},
+	{0x3861, 0x00},
+	{0x3862, 0x04},
+	{0x3863, 0x06},
+	{0x3a11, 0x01},
+	{0x3a12, 0x78},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3c00, 0x89},
+	{0x3c01, 0xab},
+	{0x3c02, 0x01},
+	{0x3c03, 0x00},
+	{0x3c04, 0x00},
+	{0x3c05, 0x03},
+	{0x3c06, 0x00},
+	{0x3c07, 0x05},
+	{0x3c0c, 0x00},
+	{0x3c0d, 0x00},
+	{0x3c0e, 0x00},
+	{0x3c0f, 0x00},
+	{0x3c40, 0x00},
+	{0x3c41, 0xa3},
+	{0x3c43, 0x7d},
+	{0x3c45, 0xd7},
+	{0x3c47, 0xfc},
+	{0x3c50, 0x05},
+	{0x3c52, 0xaa},
+	{0x3c54, 0x71},
+	{0x3c56, 0x80},
+	{0x3d85, 0x17},
+	{0x3d8d, 0xea},
+	{0x3f03, 0x00},
+	{0x3f0a, 0x00},
+	{0x3f0b, 0x00},
+	{0x4001, 0x60},
+	{0x4009, 0x0d},
+	{0x4017, 0x08},
+	{0x4020, 0x00},
+	{0x4021, 0x00},
+	{0x4022, 0x00},
+	{0x4023, 0x00},
+	{0x4024, 0x00},
+	{0x4025, 0x00},
+	{0x4026, 0x00},
+	{0x4027, 0x00},
+	{0x4028, 0x00},
+	{0x4029, 0x00},
+	{0x402a, 0x00},
+	{0x402b, 0x00},
+	{0x402c, 0x00},
+	{0x402d, 0x00},
+	{0x402e, 0x00},
+	{0x402f, 0x00},
+	{0x4040, 0x00},
+	{0x4041, 0x03},
+	{0x4042, 0x00},
+	{0x4043, 0x7A},
+	{0x4044, 0x00},
+	{0x4045, 0x7A},
+	{0x4046, 0x00},
+	{0x4047, 0x7A},
+	{0x4048, 0x00},
+	{0x4049, 0x7A},
+	{0x4303, 0x00},
+	{0x4307, 0x30},
+	{0x4320, 0x80},
+	{0x4500, 0x58},
+	{0x4501, 0x04},
+	{0x4502, 0x40},
+	{0x4503, 0x10},
+	{0x4508, 0xaa},
+	{0x4509, 0xaa},
+	{0x450a, 0x00},
+	{0x450b, 0x00},
+	{0x4700, 0xa4},
+	{0x4800, 0x4c},
+	{0x4816, 0x53},
+	{0x481f, 0x40},
+	{0x4837, 0x13},
+	{0x5000, 0x56},
+	{0x5001, 0x01},
+	{0x5002, 0x28},
+	{0x5004, 0x0c},
+	{0x5006, 0x0c},
+	{0x5007, 0xe0},
+	{0x5008, 0x01},
+	{0x5009, 0xb0},
+	{0x5901, 0x00},
+	{0x5a01, 0x00},
+	{0x5a03, 0x00},
+	{0x5a04, 0x0c},
+	{0x5a05, 0xe0},
+	{0x5a06, 0x09},
+	{0x5a07, 0xb0},
+	{0x5a08, 0x06},
+	{0x5e00, 0x00},
+	{0x3734, 0x40},
+	{0x5b00, 0x01},
+	{0x5b01, 0x10},
+	{0x5b02, 0x01},
+	{0x5b03, 0xdb},
+	{0x3d8c, 0x71},
+	{0x370b, 0x05},
+	{0x3618, 0x2a},
+	{0x5780, 0x3e},
+	{0x5781, 0x0f},
+	{0x5782, 0x44},
+	{0x5783, 0x02},
+	{0x5784, 0x01},
+	{0x5785, 0x01},
+	{0x5786, 0x00},
+	{0x5787, 0x04},
+	{0x5788, 0x02},
+	{0x5789, 0x0f},
+	{0x578a, 0xfd},
+	{0x578b, 0xf5},
+	{0x578c, 0xf5},
+	{0x578d, 0x03},
+	{0x578e, 0x08},
+	{0x578f, 0x0c},
+	{0x5790, 0x08},
+	{0x5791, 0x06},
+	{0x5792, 0x00},
+	{0x5793, 0x52},
+	{0x5794, 0xa3},
+	{0x3503, 0x00},
+	{0x380e, 0x04},
+	{0x380f, 0x60},
+	{0x3002, 0x61},
+	{0x3010, 0x40},
+	{0x300D, 0x00},
+	{0x5045, 0x05},
+	{0x5048, 0x10},
+	{0x3610, 0xa8},
+	{0x3733, 0x10},
+	{0x3734, 0x40},
+	{0x3808, 0x07},
+	{0x3809, 0x80},
+	{0x380a, 0x04},
+	{0x380b, 0x38},
+	{0x3821, 0x06},
+	{0x4600, 0x00},
+	{0x4601, 0xc0},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_1920x1080[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/*, 0xIncluding, 0xsw, 0xreset, 0x*/
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0xf8},
+	{0x3804, 0x0a},
+	{0x3805, 0x3f},
+	{0x3806, 0x06},
+	{0x3807, 0xab},
+	{0x3808, 0x07},
+	{0x3809, 0x80},
+	{0x380a, 0x04},
+	{0x380b, 0x38},
+	{0x380c, 0x0a},
+	{0x380d, 0x80},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x02},
+	{0x3821, 0x1e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x80},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_1280x720_120fps[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x2e},
+	{0x3502, 0x80},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe6},
+	{0x3709, 0xc7},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0xf4},
+	{0x3804, 0x0a},
+	{0x3805, 0x3f},
+	{0x3806, 0x06},
+	{0x3807, 0xab},
+	{0x3808, 0x05},
+	{0x3809, 0x00},
+	{0x380a, 0x02},
+	{0x380b, 0xd0},
+	{0x380c, 0x06},
+	{0x380d, 0xd8},
+	{0x380e, 0x02},
+	{0x380f, 0xf8},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x31},
+	{0x3815, 0x31},
+	{0x3820, 0x02},
+	{0x3821, 0x1f},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x00},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_2592x1944_HDR_24fps[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x0103, 0x01},
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x02},
+	{0x3099, 0x16},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30b2, 0x00},
+	{0x30b3, 0x6e},
+	{0x30b4, 0x03},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x80},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x01},
+	{0x3508, 0x80},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x05},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xa8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x0c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x02},
+	{0x3802, 0x00},
+	{0x3803, 0x06},
+	{0x3804, 0x0a},
+	{0x3805, 0x41},
+	{0x3806, 0x07},
+	{0x3807, 0xa1},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x07},
+	{0x380b, 0x98},
+	{0x380c, 0x0e},
+	{0x380d, 0x70},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x10},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x02},
+	{0x3821, 0x9e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x09},
+	{0x3a05, 0xa9},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_1920x1080_HDR_30fps[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x0103, 0x01},
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x72},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x01},
+	{0x3508, 0x80},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x01},
+	{0x3801, 0x70},
+	{0x3802, 0x01},
+	{0x3803, 0xbc},
+	{0x3804, 0x09},
+	{0x3805, 0x0f},
+	{0x3806, 0x05},
+	{0x3807, 0xff},
+	{0x3808, 0x07},
+	{0x3809, 0x80},
+	{0x380a, 0x04},
+	{0x380b, 0x38},
+	{0x380c, 0x0b},
+	{0x380d, 0x40},
+	{0x380e, 0x07},
+	{0x380f, 0x3a},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x02},
+	{0x3821, 0x9e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x09},
+	{0x3a05, 0xa9},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_1280x720_HDR_60fps[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x0103, 0x01},
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x39},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x01},
+	{0x3508, 0x80},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x02},
+	{0x3801, 0xa8},
+	{0x3802, 0x02},
+	{0x3803, 0x68},
+	{0x3804, 0x07},
+	{0x3805, 0xb7},
+	{0x3806, 0x05},
+	{0x3807, 0x3b},
+	{0x3808, 0x05},
+	{0x3809, 0x00},
+	{0x380a, 0x02},
+	{0x380b, 0xd0},
+	{0x380c, 0x0b},
+	{0x380d, 0x40},
+	{0x380e, 0x03},
+	{0x380f, 0x9e},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x02},
+	{0x3821, 0x9e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x09},
+	{0x3a05, 0xa9},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_2592x1944_one_lane_15fps[] = {
+	{0x0100, 0x00},/* Including sw reset */
+	{0x0103, 0x01},
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x11},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x28},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x05},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x64},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3400, 0x04},
+	{0x3401, 0x00},
+	{0x3402, 0x04},
+	{0x3403, 0x00},
+	{0x3404, 0x04},
+	{0x3405, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x20},
+	{0x3600, 0xbc},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x44},
+	{0x3621, 0xb5},
+	{0x3622, 0x0c},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x0a},
+	{0x3805, 0x3f},
+	{0x3806, 0x07},
+	{0x3807, 0xa3},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x07},
+	{0x380b, 0x98},
+	{0x380c, 0x0a},
+	{0x380d, 0x80},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x02},
+	{0x3821, 0x1e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x2c},
+	{0x4831, 0x64},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0xfc},
+	{0x5781, 0x13},
+	{0x5782, 0x03},
+	{0x5786, 0x20},
+	{0x5787, 0x40},
+	{0x5788, 0x08},
+	{0x5789, 0x08},
+	{0x578a, 0x02},
+	{0x578b, 0x01},
+	{0x578c, 0x01},
+	{0x578d, 0x0c},
+	{0x578e, 0x02},
+	{0x578f, 0x01},
+	{0x5790, 0x01},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{0x0100, 0x01},
+	{0x3810, 0x00},
+	{0x3811, 0x10},
+	{0x3812, 0x00},
+	{0x3813, 0x06},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+enum {
+	OV5670_MODE_2592X1944,
+	OV5670_MODE_2560X1440,
+	OV5670_MODE_1920X1080,
+
+	OV5670_MODE_START_STREAM,
+	OV5670_MODE_STOP_STREAM,
+	OV5670_MODE_TEST_PATTERN
+};
+
+static const ov5670_reg *mode_table[] = {
+	[OV5670_MODE_2592X1944]			= mode_2592x1944_regs,
+	[OV5670_MODE_2560X1440]			= mode_2560x1440_regs,
+	[OV5670_MODE_1920X1080]			= mode_1920x1080_regs,
+
+	[OV5670_MODE_START_STREAM]		= ov5670_start,
+	[OV5670_MODE_STOP_STREAM]		= ov5670_stop,
+	[OV5670_MODE_TEST_PATTERN]		= tp_colorbars,
+};
+
+static const int ov5670_15fps[] = {
+	15,
+};
+
+static const int ov5670_24fps[] = {
+	24,
+};
+
+static const int ov5670_30fps[] = {
+	30,
+};
+
+static const int ov5670_60fps[] = {
+	60,
+};
+
+static const int ov5670_120fps[] = {
+	120,
+};
+
+static const struct camera_common_frmfmt ov5670_frmfmt[] = {
+	{{2592, 1944},	ov5670_30fps,	1, 0,	OV5670_MODE_2592X1944},
+	{{2560, 1440},	ov5670_30fps,	1, 0,	OV5670_MODE_2560X1440},
+	{{1920, 1080},	ov5670_60fps,	1, 0,	OV5670_MODE_1920X1080},
+};
+#endif  /* __OV5670_TABLES__ */
diff --git a/drivers/media/platform/tegra/camera/camera_common.c b/drivers/media/platform/tegra/camera/camera_common.c
index dd2780f..2380380 100644
--- a/drivers/media/platform/tegra/camera/camera_common.c
+++ b/drivers/media/platform/tegra/camera/camera_common.c
@@ -125,6 +125,24 @@ static const struct camera_common_colorfmt camera_common_color_fmts[] = {
 		V4L2_COLORSPACE_SRGB,
 		V4L2_PIX_FMT_XRGGB10P,
 	},
+	/*
+	* new yuv formats
+	*/
+	{
+		MEDIA_BUS_FMT_UYVY8_2X8,
+		V4L2_COLORSPACE_DEFAULT,
+		V4L2_PIX_FMT_UYVY,
+	},
+	{
+		MEDIA_BUS_FMT_SGRBG10_1X10,
+		V4L2_COLORSPACE_SRGB,
+		V4L2_PIX_FMT_SGRBG10,
+	},
+	{
+		MEDIA_BUS_FMT_SGBRG10_1X10,
+		V4L2_COLORSPACE_SRGB,
+		V4L2_PIX_FMT_SGBRG10,
+	},
 };
 
 struct camera_common_csi_io_pad_ctx {
diff --git a/drivers/media/platform/tegra/camera/sensor_common.c b/drivers/media/platform/tegra/camera/sensor_common.c
index 75a3af2..e58ad62 100644
--- a/drivers/media/platform/tegra/camera/sensor_common.c
+++ b/drivers/media/platform/tegra/camera/sensor_common.c
@@ -214,6 +214,12 @@ static int extract_pixel_format(
 		*format = V4L2_PIX_FMT_XBGGR10P;
 	else if (strncmp(pixel_t, "bayer_xrggb10p", size) == 0)
 		*format = V4L2_PIX_FMT_XRGGB10P;
+	else if (strncmp(pixel_t, "yuv_uyvy8", size) == 0)
+		*format = V4L2_PIX_FMT_UYVY;
+	else if (strncmp(pixel_t, "bayer_grbg", size) == 0)
+		*format = V4L2_PIX_FMT_SGRBG10;
+	else if (strncmp(pixel_t, "bayer_gbrg", size) == 0)
+		*format = V4L2_PIX_FMT_SGBRG10;
 	else if (strncmp(pixel_t, "yuv_yuyv16", size) == 0)
 		*format = V4L2_PIX_FMT_YUYV;
 	else if (strncmp(pixel_t, "yuv_yvyu16", size) == 0)
@@ -306,6 +312,7 @@ static int sensor_common_parse_image_props(
 		}
 		sprintf(pix_format, "%s_%s%d", mode_str, phase_str, depth);
 		temp_str = pix_format;
+		dev_err(dev, "pixel_format = %s_%s%d", mode_str, phase_str, depth);
 	}
 
 	err = extract_pixel_format(temp_str, &image->pixel_format);
diff --git a/include/media/imx214.h b/include/media/imx214.h
new file mode 100644
index 0000000..f582162
--- /dev/null
+++ b/include/media/imx214.h
@@ -0,0 +1,174 @@
+/*
+ * Copyright (c) 2013-2017, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __IMX214_H__
+#define __IMX214_H__
+
+#include <media/nvc.h>
+#include <uapi/media/nvc_image.h>
+
+#define IMX214_IOCTL_SET_MODE               _IOW('o', 1, struct imx214_mode)
+#define IMX214_IOCTL_SET_FRAME_LENGTH       _IOW('o', 2, __u32)
+#define IMX214_IOCTL_SET_COARSE_TIME        _IOW('o', 3, __u32)
+#define IMX214_IOCTL_SET_GAIN               _IOW('o', 4, __u16)
+#define IMX214_IOCTL_GET_STATUS             _IOR('o', 5, __u8)
+#define IMX214_IOCTL_SET_BINNING            _IOW('o', 6, __u8)
+#define IMX214_IOCTL_TEST_PATTERN           _IOW('o', 7, \
+						 enum imx214_test_pattern)
+#define IMX214_IOCTL_SET_GROUP_HOLD         _IOW('o', 8, struct imx214_ae)
+/* IOCTL to set the operating mode of camera.
+ * This can be either stereo , leftOnly or rightOnly */
+#define IMX214_IOCTL_SET_CAMERA_MODE        _IOW('o', 10, __u32)
+#define IMX214_IOCTL_SYNC_SENSORS           _IOW('o', 11, __u32)
+#define IMX214_IOCTL_GET_FUSEID             _IOR('o', 12, struct nvc_fuseid)
+#define IMX214_IOCTL_SET_HDR_COARSE_TIME    _IOW('o', 13, struct imx214_hdr)
+#define IMX214_IOCTL_READ_OTP_BANK          _IOWR('o', 14, \
+						struct imx214_otp_bank)
+#define IMX214_IOCTL_SET_CAL_DATA           _IOW('o', 15, \
+						struct imx214_cal_data)
+#define IMX214_IOCTL_GET_EEPROM_DATA        _IOR('o', 20, __u8 *)
+#define IMX214_IOCTL_SET_EEPROM_DATA        _IOW('o', 21, __u8 *)
+#define IMX214_IOCTL_GET_CAPS               _IOR('o', 22, struct nvc_imager_cap)
+#define IMX214_IOCTL_SET_POWER              _IOW('o', 23, __u32)
+
+#define IMX214_INVALID_COARSE_TIME  -1
+
+#define IMX214_EEPROM_ADDRESS		0x50
+#define IMX214_EEPROM_SIZE		1024
+#define IMX214_EEPROM_STR_SIZE		(IMX214_EEPROM_SIZE * 2)
+#define IMX214_EEPROM_BLOCK_SIZE	(1 << 8)
+#define IMX214_EEPROM_NUM_BLOCKS \
+	(IMX214_EEPROM_SIZE / IMX214_EEPROM_BLOCK_SIZE)
+
+#define IMX214_OTP_LOAD_CTRL_ADDR	0x0A00
+#define IMX214_OTP_BANK_SELECT_ADDR	0x0A02
+#define IMX214_OTP_BANK_START_ADDR	0x0A04
+#define IMX214_OTP_BANK_END_ADDR	0x0A43
+#define IMX214_OTP_NUM_BANKS		(15)
+#define IMX214_OTP_BANK_SIZE \
+	 (IMX214_OTP_BANK_END_ADDR - IMX214_OTP_BANK_START_ADDR + 1)
+#define IMX214_OTP_SIZE \
+	 (IMX214_OTP_BANK_SIZE * IMX214_OTP_NUM_BANKS)
+#define IMX214_OTP_STR_SIZE (IMX214_OTP_SIZE * 2)
+
+//#define IMX214_FUSE_ID_OTP_START_ADDR	0x3D00
+//#define IMX214_FUSE_ID_OTP_BANK	0
+//#define IMX214_FUSE_ID_SIZE		8
+//#define IMX214_FUSE_ID_STR_SIZE	(IMX214_FUSE_ID_SIZE * 2)
+
+#define IMX214_FRAME_LENGTH_ADDR_MSB		0x0340
+#define IMX214_FRAME_LENGTH_ADDR_LSB		0x0341
+#define IMX214_COARSE_TIME_ADDR_1		0x0202
+#define IMX214_COARSE_TIME_ADDR_2		0x0203
+#define IMX214_COARSE_TIME_SHORT_ADDR_1	0x0200
+#define IMX214_COARSE_TIME_SHORT_ADDR_2	0x0201
+#define IMX214_GAIN_ADDR_MSB			0x0204
+#define IMX214_GAIN_ADDR_LSB			0x0205
+#define IMX214_GROUP_HOLD_ADDR			0x0104
+#define IMX214_TIMING_REG20			0x0101
+#define VERTICAL_FLIP				(0x1 << 1)
+#define IMX214_TIMING_REG21			0x0101
+#define HORIZONTAL_MIRROR_MASK			(0x1)
+
+struct imx214_mode {
+	int res_x;
+	int res_y;
+	int fps;
+	__u32 frame_length;
+	__u32 coarse_time;
+	__u32 coarse_time_short;
+	__u16 gain;
+	__u8 hdr_en;
+};
+
+struct imx214_ae {
+	__u32 frame_length;
+	__u8  frame_length_enable;
+	__u32 coarse_time;
+	__u32 coarse_time_short;
+	__u8  coarse_time_enable;
+	__s32 gain;
+	__u8  gain_enable;
+};
+
+struct imx214_fuseid {
+	__u32 size;
+	__u8  id[16];
+};
+
+struct imx214_hdr {
+	__u32 coarse_time_long;
+	__u32 coarse_time_short;
+};
+
+struct imx214_otp_bank {
+	__u32 id;
+	__u8  buf[16];
+};
+
+struct imx214_cal_data {
+	int loaded;
+	int rg_ratio;
+	int bg_ratio;
+	int rg_ratio_typical;
+	int bg_ratio_typical;
+	__u8 lenc[62];
+};
+
+/* See notes in the nvc.h file on the GPIO usage */
+enum imx214_gpio_type {
+	IMX214_GPIO_TYPE_PWRDN = 0,
+	IMX214_GPIO_TYPE_RESET,
+};
+
+struct imx214_eeprom_data {
+	struct i2c_client *i2c_client;
+	struct i2c_adapter *adap;
+	struct i2c_board_info brd;
+	struct regmap *regmap;
+};
+
+struct imx214_power_rail {
+	struct regulator *dvdd;
+	struct regulator *avdd;
+	struct regulator *dovdd;
+};
+
+struct imx214_regulators {
+	const char *avdd;
+	const char *dvdd;
+	const char *dovdd;
+};
+
+struct imx214_platform_data {
+	unsigned cfg;
+	unsigned num;
+	const char *dev_name;
+	unsigned gpio_count; /* see nvc.h GPIO notes */
+	struct nvc_gpio_pdata *gpio; /* see nvc.h GPIO notes */
+	struct nvc_imager_static_nvc *static_info;
+	bool use_vcm_vdd;
+	int (*probe_clock)(unsigned long);
+	int (*power_on)(struct imx214_power_rail *);
+	int (*power_off)(struct imx214_power_rail *);
+	const char *mclk_name;
+	struct nvc_imager_cap *cap;
+	struct imx214_regulators regulators;
+	bool has_eeprom;
+	bool use_cam_gpio;
+};
+
+#endif  /* __IMX214_H__ */
diff --git a/include/media/ov5640.h b/include/media/ov5640.h
new file mode 100644
index 0000000..127cbee
--- /dev/null
+++ b/include/media/ov5640.h
@@ -0,0 +1,176 @@
+/*
+ * Copyright (c) 2013-2017, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __OV5640_H__
+#define __OV5640_H__
+
+#include <media/nvc.h>
+#include <uapi/media/nvc_image.h>
+
+#define OV5640_IOCTL_SET_MODE               _IOW('o', 1, struct ov5640_mode)
+#define OV5640_IOCTL_SET_FRAME_LENGTH       _IOW('o', 2, __u32)
+#define OV5640_IOCTL_SET_COARSE_TIME        _IOW('o', 3, __u32)
+#define OV5640_IOCTL_SET_GAIN               _IOW('o', 4, __u16)
+#define OV5640_IOCTL_GET_STATUS             _IOR('o', 5, __u8)
+#define OV5640_IOCTL_SET_BINNING            _IOW('o', 6, __u8)
+#define OV5640_IOCTL_TEST_PATTERN           _IOW('o', 7, \
+						 enum ov5640_test_pattern)
+#define OV5640_IOCTL_SET_GROUP_HOLD         _IOW('o', 8, struct ov5640_ae)
+/* IOCTL to set the operating mode of camera.
+ * This can be either stereo , leftOnly or rightOnly */
+#define OV5640_IOCTL_SET_CAMERA_MODE        _IOW('o', 10, __u32)
+#define OV5640_IOCTL_SYNC_SENSORS           _IOW('o', 11, __u32)
+#define OV5640_IOCTL_GET_FUSEID             _IOR('o', 12, struct nvc_fuseid)
+#define OV5640_IOCTL_SET_HDR_COARSE_TIME    _IOW('o', 13, struct ov5640_hdr)
+#define OV5640_IOCTL_READ_OTP_BANK          _IOWR('o', 14, \
+						struct ov5640_otp_bank)
+#define OV5640_IOCTL_SET_CAL_DATA           _IOW('o', 15, \
+						struct ov5640_cal_data)
+#define OV5640_IOCTL_GET_EEPROM_DATA        _IOR('o', 20, __u8 *)
+#define OV5640_IOCTL_SET_EEPROM_DATA        _IOW('o', 21, __u8 *)
+#define OV5640_IOCTL_GET_CAPS               _IOR('o', 22, struct nvc_imager_cap)
+#define OV5640_IOCTL_SET_POWER              _IOW('o', 23, __u32)
+
+#define OV5640_INVALID_COARSE_TIME  -1
+
+#define OV5640_EEPROM_ADDRESS		0x50
+#define OV5640_EEPROM_SIZE		1024
+#define OV5640_EEPROM_STR_SIZE		(OV5640_EEPROM_SIZE * 2)
+#define OV5640_EEPROM_BLOCK_SIZE	(1 << 8)
+#define OV5640_EEPROM_NUM_BLOCKS \
+	(OV5640_EEPROM_SIZE / OV5640_EEPROM_BLOCK_SIZE)
+
+#define OV5640_OTP_LOAD_CTRL_ADDR	0x3D81
+#define OV5640_OTP_BANK_SELECT_ADDR	0x3D84
+#define OV5640_OTP_BANK_START_ADDR	0x3D00
+#define OV5640_OTP_BANK_END_ADDR	0x3D0F
+#define OV5640_OTP_NUM_BANKS		(32)
+#define OV5640_OTP_BANK_SIZE \
+	 (OV5640_OTP_BANK_END_ADDR - OV5640_OTP_BANK_START_ADDR + 1)
+#define OV5640_OTP_SIZE \
+	 (OV5640_OTP_BANK_SIZE * OV5640_OTP_NUM_BANKS)
+#define OV5640_OTP_STR_SIZE (OV5640_OTP_SIZE * 2)
+
+#define OV5640_FUSE_ID_OTP_START_ADDR	0x3D00
+#define OV5640_FUSE_ID_OTP_BANK	0
+#define OV5640_FUSE_ID_SIZE		8
+#define OV5640_FUSE_ID_STR_SIZE	(OV5640_FUSE_ID_SIZE * 2)
+
+#define OV5640_FRAME_LENGTH_ADDR_MSB		0x380E
+#define OV5640_FRAME_LENGTH_ADDR_LSB		0x380F
+#define OV5640_COARSE_TIME_ADDR_1		0x3500
+#define OV5640_COARSE_TIME_ADDR_2		0x3501
+#define OV5640_COARSE_TIME_ADDR_3		0x3502
+#define OV5640_COARSE_TIME_SHORT_ADDR_1	0x3506
+#define OV5640_COARSE_TIME_SHORT_ADDR_2	0x3507
+#define OV5640_COARSE_TIME_SHORT_ADDR_3	0x3508
+#define OV5640_GAIN_ADDR_MSB			0x350A
+#define OV5640_GAIN_ADDR_LSB			0x350B
+#define OV5640_GROUP_HOLD_ADDR			0x3208
+#define OV5640_TIMING_REG20			0x3820
+#define VERTICAL_FLIP				((0x1 << 1) | (0x1 << 6))
+#define OV5640_TIMING_REG21			0x3821
+#define HORIZONTAL_MIRROR_MASK			(0x3 << 1)
+
+struct ov5640_mode {
+	int res_x;
+	int res_y;
+	int fps;
+	__u32 frame_length;
+	__u32 coarse_time;
+	__u32 coarse_time_short;
+	__u16 gain;
+	__u8 hdr_en;
+};
+
+struct ov5640_ae {
+	__u32 frame_length;
+	__u8  frame_length_enable;
+	__u32 coarse_time;
+	__u32 coarse_time_short;
+	__u8  coarse_time_enable;
+	__s32 gain;
+	__u8  gain_enable;
+};
+
+struct ov5640_fuseid {
+	__u32 size;
+	__u8  id[16];
+};
+
+struct ov5640_hdr {
+	__u32 coarse_time_long;
+	__u32 coarse_time_short;
+};
+
+struct ov5640_otp_bank {
+	__u32 id;
+	__u8  buf[16];
+};
+
+struct ov5640_cal_data {
+	int loaded;
+	int rg_ratio;
+	int bg_ratio;
+	int rg_ratio_typical;
+	int bg_ratio_typical;
+	__u8 lenc[62];
+};
+
+/* See notes in the nvc.h file on the GPIO usage */
+enum ov5640_gpio_type {
+	OV5640_GPIO_TYPE_PWRDN = 0,
+	OV5640_GPIO_TYPE_RESET,
+};
+
+struct ov5640_eeprom_data {
+	struct i2c_client *i2c_client;
+	struct i2c_adapter *adap;
+	struct i2c_board_info brd;
+	struct regmap *regmap;
+};
+
+struct ov5640_power_rail {
+	struct regulator *dvdd;
+	struct regulator *avdd;
+	struct regulator *dovdd;
+};
+
+struct ov5640_regulators {
+	const char *avdd;
+	const char *dvdd;
+	const char *dovdd;
+};
+
+struct ov5640_platform_data {
+	unsigned cfg;
+	unsigned num;
+	const char *dev_name;
+	unsigned gpio_count; /* see nvc.h GPIO notes */
+	struct nvc_gpio_pdata *gpio; /* see nvc.h GPIO notes */
+	struct nvc_imager_static_nvc *static_info;
+	bool use_vcm_vdd;
+	int (*probe_clock)(unsigned long);
+	int (*power_on)(struct ov5640_power_rail *);
+	int (*power_off)(struct ov5640_power_rail *);
+	const char *mclk_name;
+	struct nvc_imager_cap *cap;
+	struct ov5640_regulators regulators;
+	bool has_eeprom;
+	bool use_cam_gpio;
+};
+
+#endif  /* __OV5640_H__ */
diff --git a/include/media/ov5670.h b/include/media/ov5670.h
new file mode 100644
index 0000000..bf95535
--- /dev/null
+++ b/include/media/ov5670.h
@@ -0,0 +1,185 @@
+/*
+ * Copyright (c) 2013-2017, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __OV5670_H__
+#define __OV5670_H__
+
+#include <media/nvc.h>
+#include <uapi/media/nvc_image.h>
+
+#define OV5670_IOCTL_SET_MODE               _IOW('o', 1, struct ov5670_mode)
+#define OV5670_IOCTL_SET_FRAME_LENGTH       _IOW('o', 2, __u32)
+#define OV5670_IOCTL_SET_COARSE_TIME        _IOW('o', 3, __u32)
+#define OV5670_IOCTL_SET_GAIN               _IOW('o', 4, __u16)
+#define OV5670_IOCTL_GET_STATUS             _IOR('o', 5, __u8)
+#define OV5670_IOCTL_SET_BINNING            _IOW('o', 6, __u8)
+#define OV5670_IOCTL_TEST_PATTERN           _IOW('o', 7, \
+						 enum ov5670_test_pattern)
+#define OV5670_IOCTL_SET_GROUP_HOLD         _IOW('o', 8, struct ov5670_ae)
+/* IOCTL to set the operating mode of camera.
+ * This can be either stereo , leftOnly or rightOnly */
+#define OV5670_IOCTL_SET_CAMERA_MODE        _IOW('o', 10, __u32)
+#define OV5670_IOCTL_SYNC_SENSORS           _IOW('o', 11, __u32)
+#define OV5670_IOCTL_GET_FUSEID             _IOR('o', 12, struct nvc_fuseid)
+#define OV5670_IOCTL_SET_HDR_COARSE_TIME    _IOW('o', 13, struct ov5670_hdr)
+#define OV5670_IOCTL_READ_OTP_BANK          _IOWR('o', 14, \
+						struct ov5670_otp_bank)
+#define OV5670_IOCTL_SET_CAL_DATA           _IOW('o', 15, \
+						struct ov5670_cal_data)
+#define OV5670_IOCTL_GET_EEPROM_DATA        _IOR('o', 20, __u8 *)
+#define OV5670_IOCTL_SET_EEPROM_DATA        _IOW('o', 21, __u8 *)
+#define OV5670_IOCTL_GET_CAPS               _IOR('o', 22, struct nvc_imager_cap)
+#define OV5670_IOCTL_SET_POWER              _IOW('o', 23, __u32)
+
+#define OV5670_INVALID_COARSE_TIME  -1
+
+#define OV5670_EEPROM_ADDRESS		0x50
+#define OV5670_EEPROM_SIZE		1024
+#define OV5670_EEPROM_STR_SIZE		(OV5670_EEPROM_SIZE * 2)
+#define OV5670_EEPROM_BLOCK_SIZE	(1 << 8)
+#define OV5670_EEPROM_NUM_BLOCKS \
+	(OV5670_EEPROM_SIZE / OV5670_EEPROM_BLOCK_SIZE)
+
+#define OV5670_OTP_LOAD_CTRL_ADDR	0x3D81
+#define OV5670_OTP_LOAD_CTRL_ADDR_START	0x3D88
+#define OV5670_OTP_LOAD_CTRL_ADDR_END	0x3D8A
+#define OV5670_OTP_BANK_SELECT_ADDR	0x3D84
+#define OV5670_OTP_BANK_START_ADDR	0x7010
+#define OV5670_OTP_BANK_END_ADDR	0x7063
+//#define OV5670_OTP_NUM_BANKS		(3)
+#define OV5670_OTP_NUM_BANKS		(1)
+//#define OV5670_OTP_BANK_SIZE		0x20
+#define OV5670_OTP_BANK_SIZE		(OV5670_OTP_BANK_END_ADDR - OV5670_OTP_BANK_START_ADDR + 1)
+#define OV5670_OTP_SIZE			(OV5670_OTP_BANK_END_ADDR - OV5670_OTP_BANK_START_ADDR + 1)
+#define OV5670_OTP_STR_SIZE (OV5670_OTP_SIZE * 2)
+/*
+//#define OV5670_OTP_BANK_SIZE \
+//	 (OV5670_OTP_BANK_END_ADDR - OV5670_OTP_BANK_START_ADDR + 1)
+//#define OV5670_OTP_SIZE \
+//	 (OV5670_OTP_BANK_SIZE * OV5670_OTP_NUM_BANKS)
+//#define OV5670_OTP_STR_SIZE (OV5670_OTP_SIZE * 2)
+
+//#define OV5670_FUSE_ID_OTP_START_ADDR	0x7100
+//#define OV5670_FUSE_ID_OTP_BANK	0
+//#define OV5670_FUSE_ID_SIZE		8
+//#define OV5670_FUSE_ID_STR_SIZE	(OV5670_FUSE_ID_SIZE * 2)
+*/
+
+#define OV5670_FRAME_LENGTH_ADDR_MSB		0x380E
+#define OV5670_FRAME_LENGTH_ADDR_LSB		0x380F
+#define OV5670_COARSE_TIME_ADDR_1		0x3500
+#define OV5670_COARSE_TIME_ADDR_2		0x3501
+#define OV5670_COARSE_TIME_ADDR_3		0x3502
+#define OV5670_COARSE_TIME_SHORT_ADDR_1		0x3510
+#define OV5670_COARSE_TIME_SHORT_ADDR_2		0x3511
+#define OV5670_COARSE_TIME_SHORT_ADDR_3		0x3512
+#define OV5670_GAIN_ADDR_MSB			0x3508
+#define OV5670_GAIN_ADDR_LSB			0x3509
+#define OV5670_GROUP_HOLD_ADDR			0x3208
+#define OV5670_TIMING_REG20			0x3820
+#define VERTICAL_FLIP				((0x1 << 1) | (0x1 << 2) | (0x1 << 6))
+#define OV5670_TIMING_REG21			0x3821
+#define HORIZONTAL_MIRROR_MASK			(0x3 << 1)
+
+struct ov5670_mode {
+	int res_x;
+	int res_y;
+	int fps;
+	__u32 frame_length;
+	__u32 coarse_time;
+	__u32 coarse_time_short;
+	__u16 gain;
+	__u8 hdr_en;
+};
+
+struct ov5670_ae {
+	__u32 frame_length;
+	__u8  frame_length_enable;
+	__u32 coarse_time;
+	__u32 coarse_time_short;
+	__u8  coarse_time_enable;
+	__s32 gain;
+	__u8  gain_enable;
+};
+
+struct ov5670_fuseid {
+	__u32 size;
+	__u8  id[16];
+};
+
+struct ov5670_hdr {
+	__u32 coarse_time_long;
+	__u32 coarse_time_short;
+};
+
+struct ov5670_otp_bank {
+	__u32 id;
+	__u8  buf[16];
+};
+
+struct ov5670_cal_data {
+	int loaded;
+	int rg_ratio;
+	int bg_ratio;
+	int rg_ratio_typical;
+	int bg_ratio_typical;
+	__u8 lenc[62];
+};
+
+/* See notes in the nvc.h file on the GPIO usage */
+enum ov5670_gpio_type {
+	OV5670_GPIO_TYPE_PWRDN = 0,
+	OV5670_GPIO_TYPE_RESET,
+};
+
+struct ov5670_eeprom_data {
+	struct i2c_client *i2c_client;
+	struct i2c_adapter *adap;
+	struct i2c_board_info brd;
+	struct regmap *regmap;
+};
+
+struct ov5670_power_rail {
+	struct regulator *dvdd;
+	struct regulator *avdd;
+	struct regulator *dovdd;
+};
+
+struct ov5670_regulators {
+	const char *avdd;
+	const char *dvdd;
+	const char *dovdd;
+};
+
+struct ov5670_platform_data {
+	unsigned cfg;
+	unsigned num;
+	const char *dev_name;
+	unsigned gpio_count; /* see nvc.h GPIO notes */
+	struct nvc_gpio_pdata *gpio; /* see nvc.h GPIO notes */
+	struct nvc_imager_static_nvc *static_info;
+	bool use_vcm_vdd;
+	int (*probe_clock)(unsigned long);
+	int (*power_on)(struct ov5670_power_rail *);
+	int (*power_off)(struct ov5670_power_rail *);
+	const char *mclk_name;
+	struct nvc_imager_cap *cap;
+	struct ov5670_regulators regulators;
+	bool has_eeprom;
+	bool use_cam_gpio;
+};
+
+#endif  /* __OV5670_H__ */
-- 
2.7.4

