diff --git a/arch/arm64/configs/tegra18_defconfig b/arch/arm64/configs/tegra18_defconfig
index a4974a1..39b57f7 100644
--- a/arch/arm64/configs/tegra18_defconfig
+++ b/arch/arm64/configs/tegra18_defconfig
@@ -369,6 +369,9 @@ CONFIG_VIDEO_OV10823=y
 CONFIG_VIDEO_OV23850=y
 CONFIG_VIDEO_LC898212=y
 CONFIG_VIDEO_OV5693=y
+CONFIG_VIDEO_OV5640=y
+CONFIG_VIDEO_OV5670=y
+CONFIG_VIDEO_IMX214=y
 CONFIG_VIDEO_IMX274=y
 CONFIG_VIDEO_IMX185=y
 CONFIG_I2C_IOEXPANDER_PCA9570=y
@@ -629,3 +632,6 @@ CONFIG_CRYPTO_GHASH_ARM64_CE=y
 CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
 CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
 CONFIG_CRYPTO_AES_ARM64_NEON_BLK=y
+CONFIG_SI7020=m
+CONFIG_INPUT_LSM303D=m
+CONFIG_INPUT_L3G20H=m
\ No newline at end of file
diff --git a/drivers/iio/accel/st_accel_core.c b/drivers/iio/accel/st_accel_core.c
index 197a08b..be64456 100644
--- a/drivers/iio/accel/st_accel_core.c
+++ b/drivers/iio/accel/st_accel_core.c
@@ -41,7 +41,7 @@
 #define ST_ACCEL_FS_AVL_16G			16
 
 /* CUSTOM VALUES FOR SENSOR 1 */
-#define ST_ACCEL_1_WAI_EXP			0x33
+#define ST_ACCEL_1_WAI_EXP			0x49
 #define ST_ACCEL_1_ODR_ADDR			0x20
 #define ST_ACCEL_1_ODR_MASK			0xf0
 #define ST_ACCEL_1_ODR_AVL_1HZ_VAL		0x01
diff --git a/drivers/iio/gyro/st_gyro.h b/drivers/iio/gyro/st_gyro.h
index 5353d63..d18bbb3 100644
--- a/drivers/iio/gyro/st_gyro.h
+++ b/drivers/iio/gyro/st_gyro.h
@@ -21,6 +21,7 @@
 #define L3GD20_GYRO_DEV_NAME		"l3gd20"
 #define L3G4IS_GYRO_DEV_NAME		"l3g4is_ui"
 #define LSM330_GYRO_DEV_NAME		"lsm330_gyro"
+#define L3GD20H_GYRO_DEV_NAME   "l3gd20h"
 
 /**
  * struct st_sensors_platform_data - gyro platform data
diff --git a/drivers/iio/gyro/st_gyro_core.c b/drivers/iio/gyro/st_gyro_core.c
index 02eddce..265e7f9 100644
--- a/drivers/iio/gyro/st_gyro_core.c
+++ b/drivers/iio/gyro/st_gyro_core.c
@@ -256,7 +256,7 @@ static const struct st_sensor_settings st_gyro_sensors_settings[] = {
 		.wai = ST_GYRO_3_WAI_EXP,
 		.wai_addr = ST_SENSORS_DEFAULT_WAI_ADDRESS,
 		.sensors_supported = {
-			[0] = L3GD20_GYRO_DEV_NAME,
+			[0] = L3GD20H_GYRO_DEV_NAME,
 		},
 		.ch = (struct iio_chan_spec *)st_gyro_16bit_channels,
 		.odr = {
diff --git a/drivers/iio/gyro/st_gyro_i2c.c b/drivers/iio/gyro/st_gyro_i2c.c
index 6848451..2a12dde 100644
--- a/drivers/iio/gyro/st_gyro_i2c.c
+++ b/drivers/iio/gyro/st_gyro_i2c.c
@@ -41,6 +41,14 @@ static const struct of_device_id st_gyro_of_match[] = {
 		.data = L3GD20_GYRO_DEV_NAME,
 	},
 	{
+		.compatible = "st,l3gd20h-gyr",
+		.data = L3GD20H_GYRO_DEV_NAME,
+	},
+	{
+		.compatible = "st,l3gd20h-gyro",
+		.data = L3GD20H_GYRO_DEV_NAME,
+	},
+	{
 		.compatible = "st,l3g4is-gyro",
 		.data = L3G4IS_GYRO_DEV_NAME,
 	},
@@ -93,6 +101,7 @@ static const struct i2c_device_id st_gyro_id_table[] = {
 	{ L3GD20_GYRO_DEV_NAME },
 	{ L3G4IS_GYRO_DEV_NAME },
 	{ LSM330_GYRO_DEV_NAME },
+	{ L3GD20H_GYRO_DEV_NAME },
 	{},
 };
 MODULE_DEVICE_TABLE(i2c, st_gyro_id_table);
diff --git a/drivers/iio/gyro/st_gyro_spi.c b/drivers/iio/gyro/st_gyro_spi.c
index d2b7a5f..441f823 100644
--- a/drivers/iio/gyro/st_gyro_spi.c
+++ b/drivers/iio/gyro/st_gyro_spi.c
@@ -54,6 +54,7 @@ static const struct spi_device_id st_gyro_id_table[] = {
 	{ L3GD20_GYRO_DEV_NAME },
 	{ L3G4IS_GYRO_DEV_NAME },
 	{ LSM330_GYRO_DEV_NAME },
+	{ L3GD20H_GYRO_DEV_NAME },
 	{},
 };
 MODULE_DEVICE_TABLE(spi, st_gyro_id_table);
diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index b27f014..d408358 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -87,7 +87,7 @@
 #define ST_MAGN_0_MULTIREAD_BIT			false
 
 /* CUSTOM VALUES FOR SENSOR 1 */
-#define ST_MAGN_1_WAI_EXP			0x3c
+#define ST_MAGN_1_WAI_EXP			0x49
 #define ST_MAGN_1_ODR_ADDR			0x00
 #define ST_MAGN_1_ODR_MASK			0x1c
 #define ST_MAGN_1_ODR_AVL_1HZ_VAL		0x00
diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index 0325460..e1ef09a 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -812,6 +812,18 @@ config INPUT_DRV2667_HAPTICS
 	  To compile this driver as a module, choose M here: the
 	  module will be called drv2667-haptics.
 
+config INPUT_LSM303D
+	tristate "ST LSM303D acceleromter/magnetometer support"
+	depends on INPUT && I2C
+	help
+	  Say Y to enable support for the ST LSM303D accelerometer and
+	  magnetometer combo driver.
+
+config INPUT_L3GD20H
+	tristate "ST L3GD20H gyroscope support"
+	depends on INPUT && I2C
+	help
+	  Say Y to enable support for the ST L3GD20H gyroscope driver.
 source	"drivers/input/misc/compass/Kconfig"
 source	"drivers/input/misc/mpu/Kconfig"
 source	"drivers/input/misc/pressure/Kconfig"
diff --git a/drivers/input/misc/Makefile b/drivers/input/misc/Makefile
index f15565b..6142277 100644
--- a/drivers/input/misc/Makefile
+++ b/drivers/input/misc/Makefile
@@ -77,6 +77,8 @@ obj-$(CONFIG_INPUT_WM831X_ON)		+= wm831x-on.o
 obj-$(CONFIG_INPUT_XEN_KBDDEV_FRONTEND)	+= xen-kbdfront.o
 obj-$(CONFIG_INPUT_YEALINK)		+= yealink.o
 obj-$(CONFIG_INPUT_IDEAPAD_SLIDEBAR)	+= ideapad_slidebar.o
+obj-$(CONFIG_INPUT_LSM303D)		+= lsm303d.o
+obj-$(CONFIG_INPUT_L3GD20H)		+= l3gd20h.o
 obj-y					+= compass/
 obj-y					+= mpu/
 obj-y					+= pressure/
diff --git a/drivers/input/misc/l3gd20h.c b/drivers/input/misc/l3gd20h.c
new file mode 100644
index 0000000..5c6b035
--- /dev/null
+++ b/drivers/input/misc/l3gd20h.c
@@ -0,0 +1,1825 @@
+/******************** (C) COPYRIGHT 2012 STMicroelectronics ********************
+*
+* File Name		: l3gd20h_gyr_sysfs.c
+* Authors		: MEMS Motion Sensors Products Div- Application Team
+*			: Matteo Dameno (matteo.dameno@st.com)
+*			: Denis Ciocca (denis.ciocca@st.com)
+*			: Both authors are willing to be considered the contact
+*			: and update points for the driver.
+* Version		: V 1.2.1 sysfs
+* Date			: 2012/Jul/10
+* Description		: L3GD20H digital output gyroscope sensor API
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+* REVISON HISTORY
+*
+* VERSION	| DATE		| AUTHORS	  | DESCRIPTION
+* 1.0		| 2010/May/02	| Carmine Iascone | First Release
+* 1.1.3		| 2011/Jun/24	| Matteo Dameno	  | Corrects ODR Bug
+* 1.1.4		| 2011/Sep/02	| Matteo Dameno	  | SMB Bus Mng,
+*		|		|		  | forces BDU setting
+* 1.1.5		| 2011/Sep/24	| Matteo Dameno	  | Introduces FIFO Feat.
+* 1.1.5.2	| 2011/Nov/11	| Matteo Dameno	  | enable gpio_int to be
+*		|		|		  | passed as parameter at
+*		|		|		  | module loading time;
+*		|		|		  | corrects polling
+*		|		|		  | bug at end of probing;
+* 1.1.5.3	| 2011/Dec/20	| Matteo Dameno	  | corrects error in
+*		|		|		  | I2C SADROOT; Modifies
+*		|		|		  | resume suspend func.
+* 1.1.5.4	| 2012/Jan/09	| Matteo Dameno	  | moved under input/misc;
+* 1.1.5.5	| 2012/Mar/30	| Matteo Dameno	  | moved watermark, use_smbus,
+*		|		|		  | fifomode @ struct foo_status
+*		|		|		  | sysfs range input format
+*		|		|		  | changed to decimal
+* 1.2		| 2012/Jul/10	| Denis Ciocca	  | input_poll_dev removal
+* 1.2.1		| 2012/Jul/10	| Denis Ciocca	  | added high resolution timers
+*******************************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/stat.h>
+#include <linux/of_gpio.h>
+#include <linux/of_graph.h>
+#include <linux/of_device.h>
+
+#include "l3gd20h.h"
+
+/* Maximum polled-device-reported rot speed value value in dps */
+#define FS_MAX		32768
+#define MS_TO_NS(x)		(x*1000000L)
+
+/* l3gd20h gyroscope registers */
+#define WHO_AM_I	(0x0F)
+
+#define SENSITIVITY_250		8750		/*	udps/LSB */
+#define SENSITIVITY_500		17500		/*	udps/LSB */
+#define SENSITIVITY_2000	70000		/*	udps/LSB */
+
+#define CTRL_REG1	(0x20)    /* CTRL REG1 */
+#define CTRL_REG2	(0x21)    /* CTRL REG2 */
+#define CTRL_REG3	(0x22)    /* CTRL_REG3 */
+#define CTRL_REG4	(0x23)    /* CTRL_REG4 */
+#define CTRL_REG5	(0x24)    /* CTRL_REG5 */
+#define	REFERENCE	(0x25)    /* REFERENCE REG */
+#define	FIFO_CTRL_REG	(0x2E)    /* FIFO CONTROL REGISTER */
+#define FIFO_SRC_REG	(0x2F)    /* FIFO SOURCE REGISTER */
+#define	OUT_X_L		(0x28)    /* 1st AXIS OUT REG of 6 */
+
+#define AXISDATA_REG	OUT_X_L
+
+/* CTRL_REG1 */
+#define ALL_ZEROES	(0x00)
+#define PM_OFF		(0x00)
+#define PM_NORMAL	(0x08)
+#define ENABLE_ALL_AXES	(0x07)
+#define ENABLE_NO_AXES	(0x00)
+#define BW00		(0x00)
+#define BW01		(0x10)
+#define BW10		(0x20)
+#define BW11		(0x30)
+#define ODR12		(0x00)  /* ODR = 12.5Hz */
+#define ODR25		(0x40)  /* ODR = 25Hz */
+#define ODR50		(0x80)  /* ODR = 50Hz */
+#define ODR100		(0x00)  /* ODR = 100Hz */
+#define ODR200		(0x40)  /* ODR = 200Hz */
+#define ODR400		(0x80)  /* ODR = 400Hz */
+#define ODR800		(0xC0)  /* ODR = 800Hz */
+
+/* CTRL_REG3 bits */
+#define	I2_DRDY		(0x08)
+#define	I2_WTM		(0x04)
+#define	I2_OVRUN	(0x02)
+#define	I2_EMPTY	(0x01)
+#define	I2_NONE		(0x00)
+#define	I2_MASK		(0x0F)
+
+/* CTRL_REG4 bits */
+#define	FS_MASK		(0x30)
+#define	BDU_ENABLE	(0x80)
+
+/* CTRL_REG5 bits */
+#define	FIFO_ENABLE	(0x40)
+#define HPF_ENALBE	(0x11)
+
+/* FIFO_CTRL_REG bits */
+#define	FIFO_MODE_MASK		(0xE0)
+#define	FIFO_MODE_BYPASS	(0x00)
+#define	FIFO_MODE_FIFO		(0x20)
+#define	FIFO_MODE_STREAM	(0x40)
+#define	FIFO_MODE_STR2FIFO	(0x60)
+#define	FIFO_MODE_BYPASS2STR	(0x80)
+#define	FIFO_WATERMARK_MASK	(0x1F)
+
+#define FIFO_STORED_DATA_MASK	(0x1F)
+
+#define I2C_AUTO_INCREMENT	(0x80)
+
+/* RESUME STATE INDICES */
+#define	RES_CTRL_REG1		0
+#define	RES_CTRL_REG2		1
+#define	RES_CTRL_REG3		2
+#define	RES_CTRL_REG4		3
+#define	RES_CTRL_REG5		4
+#define	RES_FIFO_CTRL_REG	5
+#define	RESUME_ENTRIES		6
+
+/* LOW_ODR REGISTER */
+#define LOW_ODR_REGISTER	(0x39)
+#define LOW_ODR_DISABLE		(0x00)
+#define LOW_ODR_ENABLE		(0x01)
+#define LOW_ODR_MASK		(0x01)
+
+/* #define DEBUG 1 */
+
+/** Registers Contents */
+#define WHOAMI_L3GD20H_GYR	(0xD7)  /* Expected content for WAI register*/
+
+static int int1_gpio = L3GD20H_GYR_DEFAULT_INT1_GPIO;
+static int int2_gpio = L3GD20H_GYR_DEFAULT_INT2_GPIO;
+/* module_param(int1_gpio, int, S_IRUGO); */
+module_param(int2_gpio, int, S_IRUGO);
+
+/*
+ * L3GD20H gyroscope data
+ * brief structure containing gyroscope values for yaw, pitch and roll in
+ * s32
+ */
+
+struct l3gd20h_gyr_triple {
+	s32	x,	/* x-axis angular rate data. */
+		y,	/* y-axis angluar rate data. */
+		z;	/* z-axis angular rate data. */
+};
+
+struct output_rate {
+	int poll_rate_ms;
+	u8 mask;
+};
+
+static const struct output_rate odr_table[] = {
+
+	{	1,	ODR800|BW10},
+	{	2,	ODR400|BW01},
+	{	5,	ODR200|BW00},
+	{	10,	ODR100|BW00},
+};
+
+static const struct output_rate odr_table_low_odr[] = {
+
+	{	20,	ODR50|BW10},
+	{	40,	ODR25|BW01},
+	{	80,	ODR12|BW00},
+};
+
+static struct l3gd20h_gyr_platform_data default_l3gd20h_gyr_pdata = {
+	.fs_range = L3GD20H_GYR_FS_250DPS,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.negate_x = 0,
+	.negate_y = 0,
+	.negate_z = 0,
+
+	.poll_interval = 100,
+	.min_interval = L3GD20H_GYR_MIN_POLL_PERIOD_MS, /* 2ms */
+
+	.gpio_int1 = L3GD20H_GYR_DEFAULT_INT1_GPIO,
+	.gpio_int2 = L3GD20H_GYR_DEFAULT_INT2_GPIO,	/* int for fifo */
+
+};
+
+struct workqueue_struct *l3gd20h_gyr_workqueue = 0;
+
+struct l3gd20h_gyr_status {
+	struct i2c_client *client;
+	struct l3gd20h_gyr_platform_data *pdata;
+
+	struct mutex lock;
+
+	struct input_dev *input_dev;
+
+	int hw_initialized;
+	atomic_t enabled;
+	atomic_t low_odr_enabled;
+	int use_smbus;
+
+	u8 reg_addr;
+	u8 resume_state[RESUME_ENTRIES];
+
+	u32 sensitivity;
+
+	/* interrupt related */
+	int irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+
+	bool polling_enabled;
+	/* fifo related */
+	u8 watermark;
+	u8 fifomode;
+
+	struct hrtimer hr_timer;
+	ktime_t ktime;
+	struct work_struct polling_task;
+};
+
+
+static int l3gd20h_gyr_i2c_read(struct l3gd20h_gyr_status *stat, u8 *buf,
+									int len)
+{
+	int ret;
+	u8 reg = buf[0];
+	u8 cmd = reg;
+
+/*
+	if (len > sizeof(buf))
+			dev_err(&stat->client->dev,
+				"read error insufficient buffer length: "
+				"len:%d, buf size=%d\n",
+				len, sizeof(buf));
+*/
+	if (len > 1)
+		cmd = (I2C_AUTO_INCREMENT | reg);
+	if (stat->use_smbus) {
+		if (len == 1) {
+			ret = i2c_smbus_read_byte_data(stat->client, cmd);
+			buf[0] = ret & 0xff;
+#ifdef DEBUG
+			dev_warn(&stat->client->dev,
+				"i2c_smbus_read_byte_data: ret=0x%02x, len:%d ,"
+				"command=0x%02x, buf[0]=0x%02x\n",
+				ret, len, cmd , buf[0]);
+#endif
+		} else if (len > 1) {
+			ret = i2c_smbus_read_i2c_block_data(stat->client,
+								cmd, len, buf);
+#ifdef DEBUG
+			dev_warn(&stat->client->dev,
+				"i2c_smbus_read_i2c_block_data: ret:%d len:%d, "
+				"command=0x%02x, ",
+				ret, len, cmd);
+			unsigned int ii;
+			for (ii = 0; ii < len; ii++)
+				printk(KERN_DEBUG "buf[%d]=0x%02x,",
+								ii, buf[ii]);
+
+			printk("\n");
+#endif
+		} else
+			ret = -1;
+
+		if (ret < 0) {
+			dev_err(&stat->client->dev,
+				"read transfer error: len:%d, command=0x%02x\n",
+				len, cmd);
+			return 0; /* failure */
+		}
+		return len; /* success */
+	}
+
+	ret = i2c_master_send(stat->client, &cmd, sizeof(cmd));
+	if (ret != sizeof(cmd))
+		return ret;
+
+	return i2c_master_recv(stat->client, buf, len);
+}
+
+static int l3gd20h_gyr_i2c_write(struct l3gd20h_gyr_status *stat, u8 *buf,
+									int len)
+{
+	int ret;
+	u8 reg, value;
+
+	if (len > 1)
+		buf[0] = (I2C_AUTO_INCREMENT | buf[0]);
+
+	reg = buf[0];
+	value = buf[1];
+
+	if (stat->use_smbus) {
+		if (len == 1) {
+			ret = i2c_smbus_write_byte_data(stat->client,
+								reg, value);
+#ifdef DEBUG
+			dev_warn(&stat->client->dev,
+				"i2c_smbus_write_byte_data: ret=%d, len:%d, "
+				"command=0x%02x, value=0x%02x\n",
+				ret, len, reg , value);
+#endif
+			return ret;
+		} else if (len > 1) {
+			ret = i2c_smbus_write_i2c_block_data(stat->client,
+							reg, len, buf + 1);
+#ifdef DEBUG
+			dev_warn(&stat->client->dev,
+				"i2c_smbus_write_i2c_block_data: ret=%d, "
+				"len:%d, command=0x%02x, ",
+				ret, len, reg);
+			unsigned int ii;
+			for (ii = 0; ii < (len + 1); ii++)
+				printk(KERN_DEBUG "value[%d]=0x%02x,",
+								ii, buf[ii]);
+
+			printk("\n");
+#endif
+			return ret;
+		}
+	}
+
+	ret = i2c_master_send(stat->client, buf, len+1);
+	return (ret == len+1) ? 0 : ret;
+}
+
+
+static int l3gd20h_gyr_register_write(struct l3gd20h_gyr_status *stat,
+		u8 *buf, u8 reg_address, u8 new_value)
+{
+	int err;
+
+		/* Sets configuration register at reg_address
+		 *  NOTE: this is a straight overwrite  */
+		buf[0] = reg_address;
+		buf[1] = new_value;
+		err = l3gd20h_gyr_i2c_write(stat, buf, 1);
+		if (err < 0)
+			return err;
+
+	return err;
+}
+
+static int l3gd20h_gyr_register_read(struct l3gd20h_gyr_status *stat,
+							u8 *buf, u8 reg_address)
+{
+
+	int err = -1;
+	buf[0] = (reg_address);
+	err = l3gd20h_gyr_i2c_read(stat, buf, 1);
+	return err;
+}
+
+static int l3gd20h_gyr_register_update(struct l3gd20h_gyr_status *stat,
+			u8 *buf, u8 reg_address, u8 mask, u8 new_bit_values)
+{
+	int err = -1;
+	u8 init_val;
+	u8 updated_val;
+	err = l3gd20h_gyr_register_read(stat, buf, reg_address);
+	if (!(err < 0)) {
+		init_val = buf[0];
+		updated_val = ((mask & new_bit_values) | ((~mask) & init_val));
+		err = l3gd20h_gyr_register_write(stat, buf, reg_address,
+				updated_val);
+	}
+	return err;
+}
+
+
+static int l3gd20h_gyr_update_watermark(struct l3gd20h_gyr_status *stat,
+								u8 watermark)
+{
+	int res = 0;
+	u8 buf[2];
+	u8 new_value;
+
+	mutex_lock(&stat->lock);
+	new_value = (watermark % 0x20);
+	res = l3gd20h_gyr_register_update(stat, buf, FIFO_CTRL_REG,
+			 FIFO_WATERMARK_MASK, new_value);
+	if (res < 0) {
+		dev_err(&stat->client->dev, "failed to update watermark\n");
+		return res;
+	}
+	dev_dbg(&stat->client->dev, "%s new_value:0x%02x,watermark:0x%02x\n",
+					__func__, new_value, watermark);
+
+	stat->resume_state[RES_FIFO_CTRL_REG] =
+		((FIFO_WATERMARK_MASK & new_value) |
+		(~FIFO_WATERMARK_MASK &
+				stat->resume_state[RES_FIFO_CTRL_REG]));
+	stat->watermark = new_value;
+	mutex_unlock(&stat->lock);
+	return res;
+}
+
+static int l3gd20h_gyr_update_fifomode(struct l3gd20h_gyr_status *stat,
+								u8 fifomode)
+{
+	int res;
+	u8 buf[2];
+	u8 new_value;
+
+	new_value = fifomode;
+	res = l3gd20h_gyr_register_update(stat, buf, FIFO_CTRL_REG,
+					FIFO_MODE_MASK, new_value);
+	if (res < 0) {
+		dev_err(&stat->client->dev, "failed to update fifoMode\n");
+		return res;
+	}
+	/*
+	dev_dbg(&stat->client->dev, "new_value:0x%02x,prev fifomode:0x%02x\n",
+				__func__, new_value, stat->fifomode);
+	 */
+	stat->resume_state[RES_FIFO_CTRL_REG] =
+		((FIFO_MODE_MASK & new_value) |
+		(~FIFO_MODE_MASK &
+				stat->resume_state[RES_FIFO_CTRL_REG]));
+	stat->fifomode = new_value;
+
+	return res;
+}
+
+static int l3gd20h_gyr_fifo_reset(struct l3gd20h_gyr_status *stat)
+{
+	u8 oldmode;
+	int res;
+
+	oldmode = stat->fifomode;
+	res = l3gd20h_gyr_update_fifomode(stat, FIFO_MODE_BYPASS);
+	if (res < 0)
+		return res;
+	res = l3gd20h_gyr_update_fifomode(stat, oldmode);
+	if (res >= 0)
+		dev_dbg(&stat->client->dev, "%s fifo reset to: 0x%02x\n",
+							__func__, oldmode);
+
+	return res;
+}
+
+static int l3gd20h_gyr_fifo_hwenable(struct l3gd20h_gyr_status *stat,
+								u8 enable)
+{
+	int res;
+	u8 buf[2];
+	u8 set = 0x00;
+	if (enable)
+		set = FIFO_ENABLE;
+
+	res = l3gd20h_gyr_register_update(stat, buf, CTRL_REG5,
+			FIFO_ENABLE, set);
+	if (res < 0) {
+		dev_err(&stat->client->dev, "fifo_hw switch to:0x%02x failed\n",
+									set);
+		return res;
+	}
+	stat->resume_state[RES_CTRL_REG5] =
+		((FIFO_ENABLE & set) |
+		(~FIFO_ENABLE & stat->resume_state[RES_CTRL_REG5]));
+	dev_dbg(&stat->client->dev, "%s set to:0x%02x\n", __func__, set);
+	return res;
+}
+
+static int l3gd20h_gyr_manage_int2settings(struct l3gd20h_gyr_status *stat,
+								u8 fifomode)
+{
+	int res;
+	u8 buf[2];
+	bool enable_fifo_hw;
+	bool recognized_mode = false;
+	u8 int2bits = I2_NONE;
+/*
+	if (stat->polling_enabled) {
+		fifomode = FIFO_MODE_BYPASS;
+		dbg_warn(&stat->client->dev, "in polling mode, fifo mode forced"
+							" to BYPASS mode\n");
+	}
+*/
+
+
+	switch (fifomode) {
+	case FIFO_MODE_FIFO:
+		recognized_mode = true;
+
+		if (stat->polling_enabled) {
+			int2bits = I2_NONE;
+			enable_fifo_hw = false;
+		} else {
+			int2bits = (I2_WTM | I2_OVRUN);
+			enable_fifo_hw = true;
+		}
+		res = l3gd20h_gyr_register_update(stat, buf, CTRL_REG3,
+					I2_MASK, int2bits);
+		if (res < 0) {
+			dev_err(&stat->client->dev, "%s : failed to update "
+							"CTRL_REG3:0x%02x\n",
+							__func__, fifomode);
+			goto err_mutex_unlock;
+		}
+		stat->resume_state[RES_CTRL_REG3] =
+			((I2_MASK & int2bits) |
+			(~(I2_MASK) & stat->resume_state[RES_CTRL_REG3]));
+		/* enable_fifo_hw = true; */
+		break;
+
+	case FIFO_MODE_BYPASS:
+		recognized_mode = true;
+
+		if (stat->polling_enabled)
+			int2bits = I2_NONE;
+		else
+			int2bits = I2_DRDY;
+
+		res = l3gd20h_gyr_register_update(stat, buf, CTRL_REG3,
+					I2_MASK, int2bits);
+		if (res < 0) {
+			dev_err(&stat->client->dev, "%s : failed to update"
+						" to CTRL_REG3:0x%02x\n",
+							__func__, fifomode);
+			goto err_mutex_unlock;
+		}
+		stat->resume_state[RES_CTRL_REG3] =
+			((I2_MASK & int2bits) |
+			(~I2_MASK & stat->resume_state[RES_CTRL_REG3]));
+		enable_fifo_hw = false;
+		break;
+
+	default:
+		recognized_mode = false;
+		res = l3gd20h_gyr_register_update(stat, buf, CTRL_REG3,
+					I2_MASK, I2_NONE);
+		if (res < 0) {
+			dev_err(&stat->client->dev, "%s : failed to update "
+						"CTRL_REG3:0x%02x\n",
+						__func__, fifomode);
+			goto err_mutex_unlock;
+		}
+		enable_fifo_hw = false;
+		stat->resume_state[RES_CTRL_REG3] =
+			((I2_MASK & 0x00) |
+			(~I2_MASK & stat->resume_state[RES_CTRL_REG3]));
+		break;
+
+	}
+	if (recognized_mode) {
+		res = l3gd20h_gyr_update_fifomode(stat, fifomode);
+		if (res < 0) {
+			dev_err(&stat->client->dev, "%s : failed to "
+						"set fifoMode\n", __func__);
+			goto err_mutex_unlock;
+		}
+	}
+	res = l3gd20h_gyr_fifo_hwenable(stat, enable_fifo_hw);
+
+err_mutex_unlock:
+
+	return res;
+}
+
+
+static int l3gd20h_gyr_update_fs_range(struct l3gd20h_gyr_status *stat,
+							u8 new_fs)
+{
+	int res ;
+	u8 buf[2];
+
+	u32 sensitivity;
+
+	switch(new_fs) {
+		case L3GD20H_GYR_FS_250DPS:
+			sensitivity = SENSITIVITY_250;
+			break;
+		case L3GD20H_GYR_FS_500DPS:
+			sensitivity = SENSITIVITY_500;
+			break;
+		case L3GD20H_GYR_FS_2000DPS:
+			sensitivity = SENSITIVITY_2000;
+			break;
+		default:
+			dev_err(&stat->client->dev, "invalid g range "
+						"requested: %u\n", new_fs);
+			return -EINVAL;
+	}
+
+
+	buf[0] = CTRL_REG4;
+
+	res = l3gd20h_gyr_register_update(stat, buf, CTRL_REG4,
+							FS_MASK, new_fs);
+
+	if (res < 0) {
+		dev_err(&stat->client->dev, "%s : failed to update fs:0x%02x\n",
+							__func__, new_fs);
+		return res;
+	}
+	stat->resume_state[RES_CTRL_REG4] =
+		((FS_MASK & new_fs) |
+		(~FS_MASK & stat->resume_state[RES_CTRL_REG4]));
+
+	stat->sensitivity = sensitivity;
+	return res;
+}
+
+
+static int l3gd20h_gyr_update_odr(struct l3gd20h_gyr_status *stat,
+			unsigned int poll_interval_ms)
+{
+	int err = -1;
+	int i;
+	u8 config[2];
+
+	if(!atomic_read(&stat->low_odr_enabled)) {
+		for(i = ARRAY_SIZE(odr_table) - 1; i >= 0; i--) {
+			if(odr_table[i].poll_rate_ms <= poll_interval_ms)
+				break;
+		}
+		config[1] = odr_table[i].mask;
+	} else {
+		for(i = ARRAY_SIZE(odr_table_low_odr) - 1; i >= 0; i--) {
+			if(odr_table_low_odr[i].poll_rate_ms <= poll_interval_ms)
+				break;
+		}
+		config[1] = odr_table_low_odr[i].mask;
+	}
+	config[1] = odr_table[i].mask;
+	config[1] |= (ENABLE_ALL_AXES + PM_NORMAL);
+
+	/* If device is currently enabled, we need to write new
+	 *  configuration out to it */
+	if (atomic_read(&stat->enabled)) {
+		config[0] = CTRL_REG1;
+		err = l3gd20h_gyr_i2c_write(stat, config, 1);
+		if (err < 0)
+			return err;
+		stat->resume_state[RES_CTRL_REG1] = config[1];
+		stat->ktime = ktime_set(0, MS_TO_NS(poll_interval_ms));
+	}
+
+	return err;
+}
+
+static int l3gd20h_gyr_enable_low_odr(struct l3gd20h_gyr_status *stat,
+				unsigned int enable)
+{
+	int res;
+	int status;
+	u8 buf[2];
+
+	buf[0] = LOW_ODR_REGISTER;
+	res = l3gd20h_gyr_i2c_read(stat,buf,1);
+	if(res<0)
+		return -1;
+	status = (int)(buf[0] & LOW_ODR_MASK);
+	buf[0] = LOW_ODR_REGISTER;
+	if(enable > 0)
+		buf[1] = LOW_ODR_ENABLE;
+	else
+		buf[1] = LOW_ODR_DISABLE;
+	res = l3gd20h_gyr_i2c_write(stat,buf,1);
+	if(res<0) {
+		if(status > 0)
+			return 1;
+		else
+			return -1;
+	}
+	return enable;
+}
+
+/* gyroscope data readout */
+static int l3gd20h_gyr_get_data(struct l3gd20h_gyr_status *stat,
+			     struct l3gd20h_gyr_triple *data)
+{
+	int err;
+	unsigned char gyro_out[6];
+	/* y,p,r hardware data */
+	s32 hw_d[3] = { 0 };
+
+	gyro_out[0] = (AXISDATA_REG);
+
+	err = l3gd20h_gyr_i2c_read(stat, gyro_out, 6);
+
+	if (err < 0)
+		return err;
+
+	hw_d[0] = (s32) ((s16)((gyro_out[1]) << 8) | gyro_out[0]);
+	hw_d[1] = (s32) ((s16)((gyro_out[3]) << 8) | gyro_out[2]);
+	hw_d[2] = (s32) ((s16)((gyro_out[5]) << 8) | gyro_out[4]);
+
+	//hw_d[0] = hw_d[0] * stat->sensitivity;
+	//hw_d[1] = hw_d[1] * stat->sensitivity;
+	//hw_d[2] = hw_d[2] * stat->sensitivity;
+
+	data->x = ((stat->pdata->negate_x) ? (-hw_d[stat->pdata->axis_map_x])
+		   : (hw_d[stat->pdata->axis_map_x]));
+	data->y = ((stat->pdata->negate_y) ? (-hw_d[stat->pdata->axis_map_y])
+		   : (hw_d[stat->pdata->axis_map_y]));
+	data->z = ((stat->pdata->negate_z) ? (-hw_d[stat->pdata->axis_map_z])
+		   : (hw_d[stat->pdata->axis_map_z]));
+
+#ifdef DEBUG
+	/* dev_info(&stat->client->dev, "gyro_out: x = %d, y = %d, z = %d\n",
+		data->x, data->y, data->z); */
+#endif
+
+	return err;
+}
+
+static void l3gd20h_gyr_report_values(struct l3gd20h_gyr_status *stat,
+					struct l3gd20h_gyr_triple *data)
+{
+	input_report_abs(stat->input_dev, ABS_X, data->x);
+	input_report_abs(stat->input_dev, ABS_Y, data->y);
+	input_report_abs(stat->input_dev, ABS_Z, data->z);
+	input_sync(stat->input_dev);
+}
+
+static int l3gd20h_gyr_hw_init(struct l3gd20h_gyr_status *stat)
+{
+	int err;
+	u8 buf[6];
+
+	dev_dbg(&stat->client->dev, "hw init\n");
+
+	buf[0] = (CTRL_REG1);
+	buf[1] = stat->resume_state[RES_CTRL_REG1];
+	buf[2] = stat->resume_state[RES_CTRL_REG2];
+	buf[3] = stat->resume_state[RES_CTRL_REG3];
+	buf[4] = stat->resume_state[RES_CTRL_REG4];
+	buf[5] = stat->resume_state[RES_CTRL_REG5];
+
+	err = l3gd20h_gyr_i2c_write(stat, buf, 5);
+	if (err < 0)
+		return err;
+
+	buf[0] = (FIFO_CTRL_REG);
+	buf[1] = stat->resume_state[RES_FIFO_CTRL_REG];
+	err = l3gd20h_gyr_i2c_write(stat, buf, 1);
+	if (err < 0)
+			return err;
+
+	stat->hw_initialized = 1;
+
+	return err;
+}
+
+static void l3gd20h_gyr_device_power_off(struct l3gd20h_gyr_status *stat)
+{
+	int err;
+	u8 buf[2];
+
+	dev_dbg(&stat->client->dev, "power off\n");
+
+	buf[0] = (CTRL_REG1);
+	buf[1] = (PM_OFF);
+	err = l3gd20h_gyr_i2c_write(stat, buf, 1);
+	if (err < 0)
+		dev_err(&stat->client->dev, "soft power off failed\n");
+
+	if (stat->pdata->power_off) {
+		/* disable_irq_nosync(acc->irq1); */
+		disable_irq_nosync(stat->irq2);
+		stat->pdata->power_off();
+		stat->hw_initialized = 0;
+	}
+
+	if (stat->hw_initialized) {
+		/*if (stat->pdata->gpio_int1 >= 0)*/
+		/*	disable_irq_nosync(stat->irq1);*/
+		if (stat->pdata->gpio_int2 >= 0) {
+			disable_irq_nosync(stat->irq2);
+			dev_dbg(&stat->client->dev,
+					"power off: irq2 disabled\n");
+		}
+		stat->hw_initialized = 0;
+	}
+}
+
+static int l3gd20h_gyr_device_power_on(struct l3gd20h_gyr_status *stat)
+{
+	int err;
+
+	if (stat->pdata->power_on) {
+		err = stat->pdata->power_on();
+		if (err < 0)
+			return err;
+		if (stat->pdata->gpio_int2 >= 0)
+			enable_irq(stat->irq2);
+	}
+
+
+	if (!stat->hw_initialized) {
+		err = l3gd20h_gyr_hw_init(stat);
+		if (err < 0) {
+			l3gd20h_gyr_device_power_off(stat);
+			return err;
+		}
+	}
+
+	if (stat->hw_initialized) {
+		/* if (stat->pdata->gpio_int1) {
+			enable_irq(stat->irq1);
+			dev_info(&stat->client->dev,
+						"power on: irq1 enabled\n");
+		} */
+		dev_dbg(&stat->client->dev, "stat->pdata->gpio_int2 = %d\n",
+						stat->pdata->gpio_int2);
+		if (stat->pdata->gpio_int2 >= 0) {
+			enable_irq(stat->irq2);
+			dev_dbg(&stat->client->dev,
+					"power on: irq2 enabled\n");
+		}
+	}
+
+	return 0;
+}
+
+static int l3gd20h_gyr_enable(struct l3gd20h_gyr_status *stat)
+{
+	int err;
+
+	if (!atomic_cmpxchg(&stat->enabled, 0, 1)) {
+
+		err = l3gd20h_gyr_device_power_on(stat);
+		if (err < 0) {
+			atomic_set(&stat->enabled, 0);
+			return err;
+		}
+
+		if (stat->polling_enabled) {
+			hrtimer_start(&(stat->hr_timer), stat->ktime,
+							HRTIMER_MODE_REL);
+		}
+
+	}
+
+	return 0;
+}
+
+static int l3gd20h_gyr_disable(struct l3gd20h_gyr_status *stat)
+{
+	dev_dbg(&stat->client->dev, "%s: stat->enabled = %d\n", __func__,
+						atomic_read(&stat->enabled));
+
+	if (atomic_cmpxchg(&stat->enabled, 1, 0)) {
+
+		l3gd20h_gyr_device_power_off(stat);
+		hrtimer_cancel(&stat->hr_timer);
+		dev_dbg(&stat->client->dev, "%s: cancel_hrtimer ", __func__);
+	}
+	return 0;
+}
+
+static ssize_t attr_polling_rate_show(struct device *dev,
+					struct device_attribute *attr,
+								char *buf)
+{
+	int val;
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	mutex_lock(&stat->lock);
+	val = stat->pdata->poll_interval;
+	mutex_unlock(&stat->lock);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_polling_rate_store(struct device *dev,
+					struct device_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (kstrtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+
+	mutex_lock(&stat->lock);
+	err = l3gd20h_gyr_update_odr(stat, interval_ms);
+	if(err >= 0)
+		stat->pdata->poll_interval = interval_ms;
+	mutex_unlock(&stat->lock);
+	return size;
+}
+
+static ssize_t attr_range_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	int range = 0;
+	u8 val;
+	mutex_lock(&stat->lock);
+	val = stat->pdata->fs_range;
+
+	switch (val) {
+	case L3GD20H_GYR_FS_250DPS:
+		range = 250;
+		break;
+	case L3GD20H_GYR_FS_500DPS:
+		range = 500;
+		break;
+	case L3GD20H_GYR_FS_2000DPS:
+		range = 2000;
+		break;
+	}
+	mutex_unlock(&stat->lock);
+	/* return sprintf(buf, "0x%02x\n", val); */
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_range_store(struct device *dev,
+					struct device_attribute *attr,
+						const char *buf, size_t size)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+	u8 range;
+	int err;
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+	switch (val) {
+	case 250:
+		range = L3GD20H_GYR_FS_250DPS;
+		break;
+	case 500:
+		range = L3GD20H_GYR_FS_500DPS;
+		break;
+	case 2000:
+		range = L3GD20H_GYR_FS_2000DPS;
+		break;
+	default:
+		dev_err(&stat->client->dev, "invalid range request: %lu,"
+				" discarded\n", val);
+		return -EINVAL;
+	}
+	mutex_lock(&stat->lock);
+	err = l3gd20h_gyr_update_fs_range(stat, range);
+	if (err >= 0)
+		stat->pdata->fs_range = range;
+	mutex_unlock(&stat->lock);
+	dev_dbg(&stat->client->dev, "range set to: %lu dps\n", val);
+	return size;
+}
+
+static ssize_t attr_enable_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	int val = atomic_read(&stat->enabled);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_enable_store(struct device *dev,
+					struct device_attribute *attr,
+						const char *buf, size_t size)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		l3gd20h_gyr_enable(stat);
+	else
+		l3gd20h_gyr_disable(stat);
+
+	return size;
+}
+
+static ssize_t attr_polling_mode_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int val = 0;
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+
+	mutex_lock(&stat->lock);
+	if (stat->polling_enabled)
+		val = 1;
+	mutex_unlock(&stat->lock);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_polling_mode_store(struct device *dev,
+				struct device_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	mutex_lock(&stat->lock);
+	if (val) {
+		stat->polling_enabled = true;
+		l3gd20h_gyr_manage_int2settings(stat, stat->fifomode);
+		dev_dbg(dev, "polling mode enabled\n");
+		if (atomic_read(&stat->enabled)) {
+			hrtimer_start(&(stat->hr_timer), stat->ktime, HRTIMER_MODE_REL);
+		}
+	} else {
+		if (stat->polling_enabled) {
+			hrtimer_cancel(&stat->hr_timer);
+		}
+		stat->polling_enabled = false;
+		l3gd20h_gyr_manage_int2settings(stat, stat->fifomode);
+		dev_dbg(dev, "polling mode disabled\n");
+	}
+	mutex_unlock(&stat->lock);
+	return size;
+}
+
+static ssize_t attr_watermark_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long watermark;
+	int res;
+
+	if (kstrtoul(buf, 16, &watermark))
+		return -EINVAL;
+
+	res = l3gd20h_gyr_update_watermark(stat, watermark);
+	if (res < 0)
+		return res;
+
+	return size;
+}
+
+static ssize_t attr_watermark_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	int val = stat->watermark;
+	return sprintf(buf, "0x%02x\n", val);
+}
+
+static ssize_t attr_fifomode_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long fifomode;
+	int res;
+
+	if (kstrtoul(buf, 16, &fifomode))
+		return -EINVAL;
+	/* if (!fifomode)
+		return -EINVAL; */
+
+	dev_dbg(dev, "%s, got value:0x%02x\n", __func__, (u8)fifomode);
+
+	mutex_lock(&stat->lock);
+	res = l3gd20h_gyr_manage_int2settings(stat, (u8) fifomode);
+	mutex_unlock(&stat->lock);
+
+	if (res < 0)
+		return res;
+	return size;
+}
+
+static ssize_t attr_fifomode_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	u8 val = stat->fifomode;
+	return sprintf(buf, "0x%02x\n", val);
+}
+
+static ssize_t attr_get_low_odr(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	int val = atomic_read(&stat->low_odr_enabled);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_low_odr(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long enable;
+	int res;
+
+	if (kstrtoul(buf, 10, &enable))
+		return -EINVAL;
+
+	mutex_lock(&stat->lock);
+	res = l3gd20h_gyr_enable_low_odr(stat, enable);
+	if(res<=0)
+		atomic_set(&stat->low_odr_enabled,0);
+	else
+		atomic_set(&stat->low_odr_enabled,1);
+	l3gd20h_gyr_update_odr(stat, stat->pdata->poll_interval);
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+
+#ifdef DEBUG
+static ssize_t attr_reg_set(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	int rc;
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	u8 x[2];
+	unsigned long val;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+	mutex_lock(&stat->lock);
+	x[0] = stat->reg_addr;
+	mutex_unlock(&stat->lock);
+	x[1] = val;
+	rc = l3gd20h_gyr_i2c_write(stat, x, 1);
+	return size;
+}
+
+static ssize_t attr_reg_get(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	ssize_t ret;
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	int rc;
+	u8 data;
+
+	mutex_lock(&stat->lock);
+	data = stat->reg_addr;
+	mutex_unlock(&stat->lock);
+	rc = l3gd20h_gyr_i2c_read(stat, &data, 1);
+	ret = sprintf(buf, "0x%02x\n", data);
+	return ret;
+}
+
+static ssize_t attr_addr_set(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&stat->lock);
+
+	stat->reg_addr = val;
+
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+#endif /* DEBUG */
+
+static struct device_attribute attributes[] = {
+	__ATTR(pollrate_ms, 0664, attr_polling_rate_show, attr_polling_rate_store),
+	__ATTR(range, 0664, attr_range_show, attr_range_store),
+	__ATTR(enable_device, 0664, attr_enable_show, attr_enable_store),
+	__ATTR(enable_polling, 0664, attr_polling_mode_show, attr_polling_mode_store),
+	__ATTR(fifo_samples, 0664, attr_watermark_show, attr_watermark_store),
+	__ATTR(fifo_mode, 0664, attr_fifomode_show, attr_fifomode_store),
+	__ATTR(enable_low_odr, 0664, attr_get_low_odr, attr_set_low_odr),
+#ifdef DEBUG
+	__ATTR(reg_value, 0600, attr_reg_get, attr_reg_set),
+	__ATTR(reg_addr, 0200, NULL, attr_addr_set),
+#endif
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+	return 0;
+
+error:
+	for (; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+	return 0;
+}
+
+static void l3gd20h_gyr_report_triple(struct l3gd20h_gyr_status *stat)
+{
+	int err;
+	struct l3gd20h_gyr_triple data_out;
+
+	err = l3gd20h_gyr_get_data(stat, &data_out);
+	if (err < 0)
+		dev_err(&stat->client->dev, "get_gyroscope_data failed\n");
+	else
+		l3gd20h_gyr_report_values(stat, &data_out);
+}
+
+
+static void l3gd20h_gyr_irq2_fifo(struct l3gd20h_gyr_status *stat)
+{
+	int err;
+	u8 buf[2];
+	u8 int_source;
+	u8 samples;
+	u8 workingmode;
+	u8 stored_samples;
+
+	mutex_lock(&stat->lock);
+
+	workingmode = stat->fifomode;
+
+
+	dev_dbg(&stat->client->dev, "%s : fifomode:0x%02x\n", __func__,
+								workingmode);
+
+
+	switch (workingmode) {
+	case FIFO_MODE_BYPASS:
+	{
+		dev_dbg(&stat->client->dev, "%s : fifomode:0x%02x\n", __func__,
+							stat->fifomode);
+		l3gd20h_gyr_report_triple(stat);
+		break;
+	}
+	case FIFO_MODE_FIFO:
+		samples = (stat->watermark)+1;
+		dev_dbg(&stat->client->dev,
+			"%s : FIFO_SRC_REG init samples:%d\n",
+							__func__, samples);
+		err = l3gd20h_gyr_register_read(stat, buf, FIFO_SRC_REG);
+		if (err < 0)
+			dev_err(&stat->client->dev,
+					"error reading fifo source reg\n");
+
+		int_source = buf[0];
+		dev_dbg(&stat->client->dev, "%s :FIFO_SRC_REG content:0x%02x\n",
+							__func__, int_source);
+
+		stored_samples = int_source & FIFO_STORED_DATA_MASK;
+		dev_dbg(&stat->client->dev, "%s : fifomode:0x%02x\n", __func__,
+						stat->fifomode);
+
+		dev_dbg(&stat->client->dev, "%s : samples:%d stored:%d\n",
+				__func__, samples, stored_samples);
+
+		for (; samples > 0; samples--) {
+#ifdef DEBUG
+			input_report_abs(stat->input_dev, ABS_MISC, 1);
+			input_sync(stat->input_dev);
+#endif
+			dev_dbg(&stat->client->dev, "%s : current sample:%d\n",
+							__func__, samples);
+
+			l3gd20h_gyr_report_triple(stat);
+
+#ifdef DEBUG
+			input_report_abs(stat->input_dev, ABS_MISC, 0);
+			input_sync(stat->input_dev);
+#endif
+		}
+		l3gd20h_gyr_fifo_reset(stat);
+		break;
+	}
+#ifdef DEBUG
+	input_report_abs(stat->input_dev, ABS_MISC, 3);
+	input_sync(stat->input_dev);
+#endif
+
+	mutex_unlock(&stat->lock);
+}
+
+static irqreturn_t l3gd20h_gyr_isr2(int irq, void *dev)
+{
+	struct l3gd20h_gyr_status *stat = dev;
+
+	disable_irq_nosync(irq);
+#ifdef DEBUG
+	input_report_abs(stat->input_dev, ABS_MISC, 2);
+	input_sync(stat->input_dev->input);
+#endif
+	queue_work(stat->irq2_work_queue, &stat->irq2_work);
+	pr_debug("%s %s: isr2 queued\n", L3GD20H_GYR_DEV_NAME, __func__);
+
+	return IRQ_HANDLED;
+}
+
+static void l3gd20h_gyr_irq2_work_func(struct work_struct *work)
+{
+
+	struct l3gd20h_gyr_status *stat =
+		container_of(work, struct l3gd20h_gyr_status, irq2_work);
+	/* TODO  add interrupt service procedure.
+		 ie:l3gd20h_gyr_irq2_XXX(stat); */
+	l3gd20h_gyr_irq2_fifo(stat);
+	/*  */
+	pr_debug("%s %s: IRQ2 served\n", L3GD20H_GYR_DEV_NAME, __func__);
+/* exit: */
+	enable_irq(stat->irq2);
+}
+
+int l3gd20h_gyr_input_open(struct input_dev *input)
+{
+	struct l3gd20h_gyr_status *stat = input_get_drvdata(input);
+	dev_dbg(&stat->client->dev, "%s\n", __func__);
+	return l3gd20h_gyr_enable(stat);
+}
+
+void l3gd20h_gyr_input_close(struct input_dev *dev)
+{
+	struct l3gd20h_gyr_status *stat = input_get_drvdata(dev);
+	dev_dbg(&stat->client->dev, "%s\n", __func__);
+	l3gd20h_gyr_disable(stat);
+}
+
+static int l3gd20h_gyr_validate_pdata(struct l3gd20h_gyr_status *stat)
+{
+	/* checks for correctness of minimal polling period */
+	stat->pdata->min_interval =
+		max((unsigned int) L3GD20H_GYR_MIN_POLL_PERIOD_MS,
+						stat->pdata->min_interval);
+
+	stat->pdata->poll_interval = max(stat->pdata->poll_interval,
+			stat->pdata->min_interval);
+
+	if (stat->pdata->axis_map_x > 2 ||
+	    stat->pdata->axis_map_y > 2 ||
+	    stat->pdata->axis_map_z > 2) {
+		dev_err(&stat->client->dev,
+			"invalid axis_map value x:%u y:%u z%u\n",
+			stat->pdata->axis_map_x,
+			stat->pdata->axis_map_y,
+			stat->pdata->axis_map_z);
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (stat->pdata->negate_x > 1 ||
+	    stat->pdata->negate_y > 1 ||
+	    stat->pdata->negate_z > 1) {
+		dev_err(&stat->client->dev,
+			"invalid negate value x:%u y:%u z:%u\n",
+			stat->pdata->negate_x,
+			stat->pdata->negate_y,
+			stat->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (stat->pdata->poll_interval < stat->pdata->min_interval) {
+		dev_err(&stat->client->dev,
+			"minimum poll interval violated\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int l3gd20h_gyr_input_init(struct l3gd20h_gyr_status *stat)
+{
+	int err = -1;
+
+	dev_dbg(&stat->client->dev, "%s\n", __func__);
+
+	stat->input_dev = input_allocate_device();
+	if (!stat->input_dev) {
+		err = -ENOMEM;
+		dev_err(&stat->client->dev,
+			"input device allocation failed\n");
+		goto err0;
+	}
+
+	stat->input_dev->open = l3gd20h_gyr_input_open;
+	stat->input_dev->close = l3gd20h_gyr_input_close;
+	stat->input_dev->name = L3GD20H_GYR_DEV_NAME;
+
+	stat->input_dev->id.bustype = BUS_I2C;
+	stat->input_dev->dev.parent = &stat->client->dev;
+
+	input_set_drvdata(stat->input_dev, stat);
+
+	set_bit(EV_ABS, stat->input_dev->evbit);
+
+#ifdef DEBUG
+	set_bit(EV_KEY, stat->input_dev->keybit);
+	set_bit(KEY_LEFT, stat->input_dev->keybit);
+	input_set_abs_params(stat->input_dev, ABS_MISC, 0, 1, 0, 0);
+#endif
+
+	input_set_abs_params(stat->input_dev, ABS_X, -FS_MAX-1, FS_MAX, 0, 0);
+	input_set_abs_params(stat->input_dev, ABS_Y, -FS_MAX-1, FS_MAX, 0, 0);
+	input_set_abs_params(stat->input_dev, ABS_Z, -FS_MAX-1, FS_MAX, 0, 0);
+
+
+	err = input_register_device(stat->input_dev);
+	if (err) {
+		dev_err(&stat->client->dev,
+			"unable to register input polled device %s\n",
+			stat->input_dev->name);
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	input_free_device(stat->input_dev);
+err0:
+	return err;
+}
+
+static void l3gd20h_gyr_input_cleanup(struct l3gd20h_gyr_status *stat)
+{
+	input_unregister_device(stat->input_dev);
+	input_free_device(stat->input_dev);
+}
+
+static void poll_function_work(struct work_struct *polling_task)
+{
+	struct l3gd20h_gyr_status *stat;
+	struct l3gd20h_gyr_triple data_out;
+	int err;
+
+	stat = container_of((struct work_struct *)polling_task,
+					struct l3gd20h_gyr_status, polling_task);
+
+	err = l3gd20h_gyr_get_data(stat, &data_out);
+	if (err < 0)
+		dev_err(&stat->client->dev, "get_rotation_data failed.\n");
+	else
+		l3gd20h_gyr_report_values(stat, &data_out);
+
+	hrtimer_start(&stat->hr_timer, stat->ktime, HRTIMER_MODE_REL);
+}
+
+enum hrtimer_restart poll_function_read(struct hrtimer *timer)
+{
+	struct l3gd20h_gyr_status *stat;
+
+	stat = container_of((struct hrtimer *)timer,
+				struct l3gd20h_gyr_status, hr_timer);
+
+	queue_work(l3gd20h_gyr_workqueue, &stat->polling_task);
+	return HRTIMER_NORESTART;
+}
+
+static int l3gd20h_gyr_probe(struct i2c_client *client,
+					const struct i2c_device_id *devid)
+{
+	struct l3gd20h_gyr_status *stat;
+	int gpio = 0;
+
+	u32 smbus_func = I2C_FUNC_SMBUS_BYTE_DATA |
+			I2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_I2C_BLOCK ;
+
+	int err = -1;
+
+	dev_info(&client->dev, "Probing device\n");
+
+
+	stat = kzalloc(sizeof(*stat), GFP_KERNEL);
+	if (stat == NULL) {
+		dev_err(&client->dev,
+			"failed to allocate memory for module data\n");
+		err = -ENOMEM;
+		goto err0;
+	}
+
+
+	/* Support for both I2C and SMBUS adapter interfaces. */
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_warn(&client->dev, "client not i2c capable\n");
+		if (i2c_check_functionality(client->adapter, smbus_func)) {
+			stat->use_smbus = 1;
+			dev_warn(&client->dev, "client using SMBUS\n");
+		} else {
+			err = -ENODEV;
+			dev_err(&client->dev, "client nor SMBUS capable\n");
+			stat->use_smbus = 0;
+			goto err0;
+		}
+	}
+
+	if(l3gd20h_gyr_workqueue == 0)
+		l3gd20h_gyr_workqueue = create_workqueue("l3gd20h_gyr_workqueue");
+
+	hrtimer_init(&stat->hr_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	stat->hr_timer.function = &poll_function_read;
+
+	mutex_init(&stat->lock);
+	mutex_lock(&stat->lock);
+	stat->client = client;
+	i2c_set_clientdata(client, stat);
+
+	stat->pdata = kmalloc(sizeof(*stat->pdata), GFP_KERNEL);
+	if (stat->pdata == NULL) {
+		dev_err(&client->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		goto err1;
+	}
+
+	if (IS_ENABLED(CONFIG_OF) && client->dev.of_node) {
+		struct device_node *np;
+		np = client->dev.of_node;
+		if (np)
+			gpio = of_get_named_gpio(np, "int-gpio", 0);
+	}
+
+	if (client->dev.platform_data == NULL) {
+		default_l3gd20h_gyr_pdata.gpio_int1 = int1_gpio;
+		default_l3gd20h_gyr_pdata.gpio_int2 = gpio;
+		memcpy(stat->pdata, &default_l3gd20h_gyr_pdata,
+							sizeof(*stat->pdata));
+		dev_dbg(&client->dev, "using default plaform_data\n");
+	} else {
+		memcpy(stat->pdata, client->dev.platform_data,
+						sizeof(*stat->pdata));
+		if (gpio > 0)
+			stat->pdata->gpio_int2 = gpio;
+	}
+
+	err = l3gd20h_gyr_validate_pdata(stat);
+	if (err < 0) {
+		dev_err(&client->dev, "failed to validate platform data\n");
+		goto err1_1;
+	}
+
+	i2c_set_clientdata(client, stat);
+
+	if (stat->pdata->init) {
+		err = stat->pdata->init();
+		if (err < 0) {
+			dev_err(&client->dev, "init failed: %d\n", err);
+			goto err1_1;
+		}
+	}
+
+
+	memset(stat->resume_state, 0, ARRAY_SIZE(stat->resume_state));
+
+	stat->resume_state[RES_CTRL_REG1] = ALL_ZEROES | ENABLE_ALL_AXES
+								| PM_NORMAL;
+	stat->resume_state[RES_CTRL_REG2] = ALL_ZEROES;
+	stat->resume_state[RES_CTRL_REG3] = ALL_ZEROES;
+	stat->resume_state[RES_CTRL_REG4] = ALL_ZEROES | BDU_ENABLE;
+	stat->resume_state[RES_CTRL_REG5] = ALL_ZEROES;
+	stat->resume_state[RES_FIFO_CTRL_REG] = ALL_ZEROES;
+
+	stat->polling_enabled = true;
+	dev_dbg(&client->dev, "polling mode enabled\n");
+
+	err = l3gd20h_gyr_device_power_on(stat);
+	if (err < 0) {
+		dev_err(&client->dev, "power on failed: %d\n", err);
+		goto err2;
+	}
+
+	atomic_set(&stat->enabled, 1);
+
+	err = l3gd20h_gyr_update_fs_range(stat, stat->pdata->fs_range);
+	if (err < 0) {
+		dev_err(&client->dev, "update_fs_range failed\n");
+		goto err2;
+	}
+
+	err = l3gd20h_gyr_update_odr(stat, stat->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(&client->dev, "update_odr failed\n");
+		goto err2;
+	}
+
+	err = l3gd20h_gyr_input_init(stat);
+	if (err < 0)
+		goto err3;
+
+	err = create_sysfs_interfaces(&client->dev);
+	if (err < 0) {
+		dev_err(&client->dev,
+			"%s device register failed\n", L3GD20H_GYR_DEV_NAME);
+		goto err4;
+	}
+
+	l3gd20h_gyr_device_power_off(stat);
+
+	/* As default, do not report information */
+	atomic_set(&stat->enabled, 0);
+
+
+	if (stat->pdata->gpio_int2 >= 0) {
+		stat->irq2 = gpio_to_irq(stat->pdata->gpio_int2);
+		dev_info(&client->dev, "%s: %s has set irq2 to irq:"
+						" %d mapped on gpio:%d\n",
+			L3GD20H_GYR_DEV_NAME, __func__, stat->irq2,
+							stat->pdata->gpio_int2);
+
+		INIT_WORK(&stat->irq2_work, l3gd20h_gyr_irq2_work_func);
+		stat->irq2_work_queue =
+			create_singlethread_workqueue("l3gd20h_gyr_irq2_wq");
+		if (!stat->irq2_work_queue) {
+			err = -ENOMEM;
+			dev_err(&client->dev, "cannot create "
+						"work queue2: %d\n", err);
+			goto err5;
+		}
+
+		err = request_irq(stat->irq2, l3gd20h_gyr_isr2,
+				IRQF_TRIGGER_HIGH, "l3gd20h_gyr_irq2", stat);
+
+		if (err < 0) {
+			dev_err(&client->dev, "request irq2 failed: %d\n", err);
+			goto err6;
+		}
+		disable_irq_nosync(stat->irq2);
+	}
+
+	mutex_unlock(&stat->lock);
+
+	INIT_WORK(&stat->polling_task, poll_function_work);
+	dev_info(&client->dev, "%s Probed device successfully\n",
+							L3GD20H_GYR_DEV_NAME);
+
+
+	return 0;
+
+/*err7:
+	free_irq(stat->irq2, stat);
+*/
+err6:
+	destroy_workqueue(stat->irq2_work_queue);
+err5:
+	l3gd20h_gyr_device_power_off(stat);
+	remove_sysfs_interfaces(&client->dev);
+err4:
+	l3gd20h_gyr_input_cleanup(stat);
+err3:
+	l3gd20h_gyr_device_power_off(stat);
+err2:
+	if (stat->pdata->exit)
+		stat->pdata->exit();
+err1_1:
+	mutex_unlock(&stat->lock);
+	kfree(stat->pdata);
+err1:
+	destroy_workqueue(l3gd20h_gyr_workqueue);
+	kfree(stat);
+err0:
+		pr_err("%s: Driver Initialization failed\n",
+							L3GD20H_GYR_DEV_NAME);
+		return err;
+}
+
+static int l3gd20h_gyr_remove(struct i2c_client *client)
+{
+	struct l3gd20h_gyr_status *stat = i2c_get_clientdata(client);
+
+	dev_info(&stat->client->dev, "Removing driver\n");
+
+	cancel_work_sync(&stat->polling_task);
+	if(!l3gd20h_gyr_workqueue) {
+		flush_workqueue(l3gd20h_gyr_workqueue);
+		destroy_workqueue(l3gd20h_gyr_workqueue);
+	}
+	/*
+	if (stat->pdata->gpio_int1 >= 0)
+	{
+		free_irq(stat->irq1, stat);
+		gpio_free(stat->pdata->gpio_int1);
+		destroy_workqueue(stat->irq1_work_queue);
+	}
+	*/
+	if (stat->pdata->gpio_int2 >= 0) {
+		free_irq(stat->irq2, stat);
+		gpio_free(stat->pdata->gpio_int2);
+		destroy_workqueue(stat->irq2_work_queue);
+	}
+
+	l3gd20h_gyr_disable(stat);
+	l3gd20h_gyr_input_cleanup(stat);
+
+	remove_sysfs_interfaces(&client->dev);
+
+	kfree(stat->pdata);
+	kfree(stat);
+	return 0;
+}
+
+static int l3gd20h_gyr_suspend(struct device *dev)
+{
+	int err = 0;
+#define SLEEP
+#ifdef CONFIG_PM
+	struct i2c_client *client = to_i2c_client(dev);
+	struct l3gd20h_gyr_status *stat = i2c_get_clientdata(client);
+	u8 buf[2];
+
+	dev_dbg(&client->dev, "suspend\n");
+
+	dev_dbg(&client->dev, "%s\n", __func__);
+	if (atomic_read(&stat->enabled)) {
+		mutex_lock(&stat->lock);
+		if (stat->polling_enabled) {
+			dev_dbg(&stat->client->dev, "polling mode disabled\n");
+			hrtimer_cancel(&stat->hr_timer);
+		}
+#ifdef SLEEP
+		err = l3gd20h_gyr_register_update(stat, buf, CTRL_REG1,
+				0x0F, (ENABLE_NO_AXES | PM_NORMAL));
+#else
+		err = l3gd20h_gyr_register_update(stat, buf, CTRL_REG1,
+				0x08, PM_OFF);
+#endif /*SLEEP*/
+		mutex_unlock(&stat->lock);
+	}
+#endif /*CONFIG_PM*/
+	return err;
+}
+
+static int l3gd20h_gyr_resume(struct device *dev)
+{
+	int err = 0;
+#ifdef CONFIG_PM
+	struct i2c_client *client = to_i2c_client(dev);
+	struct l3gd20h_gyr_status *stat = i2c_get_clientdata(client);
+	u8 buf[2];
+
+
+	dev_dbg(&client->dev, "resume\n");
+
+	dev_dbg(&client->dev, "%s\n", __func__);
+	if (atomic_read(&stat->enabled)) {
+		mutex_lock(&stat->lock);
+		if (stat->polling_enabled) {
+			dev_dbg(&stat->client->dev, "polling mode enabled\n");
+			hrtimer_init(&stat->hr_timer, CLOCK_MONOTONIC,
+							HRTIMER_MODE_REL);
+		}
+#ifdef SLEEP
+		err = l3gd20h_gyr_register_update(stat, buf, CTRL_REG1,
+				0x0F, (ENABLE_ALL_AXES | PM_NORMAL));
+#else
+		err = l3gd20h_gyr_register_update(stat, buf, CTRL_REG1,
+				0x08, PM_NORMAL);
+#endif
+		mutex_unlock(&stat->lock);
+
+	}
+#endif /*CONFIG_PM*/
+	return err;
+}
+
+
+static const struct i2c_device_id l3gd20h_gyr_id[] = {
+	{ L3GD20H_GYR_DEV_NAME , 0 },
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, l3gd20h_gyr_id);
+
+static const struct dev_pm_ops l3gd20h_gyr_pm = {
+	.suspend = l3gd20h_gyr_suspend,
+	.resume = l3gd20h_gyr_resume,
+};
+
+#ifdef CONFIG_OF
+static const struct of_device_id l3gd20h_gyr_of_match[] = {
+	{ .compatible = "l3gd20h_gyr" },
+	{ /* Sentinel */ }
+};
+
+MODULE_DEVICE_TABLE(of, l3gd20h_gyr_of_match);
+#endif
+
+static struct i2c_driver l3gd20h_gyr_driver = {
+	.driver = {
+			.owner = THIS_MODULE,
+			.name = L3GD20H_GYR_DEV_NAME,
+			.pm = &l3gd20h_gyr_pm,
+			.of_match_table = of_match_ptr(l3gd20h_gyr_of_match),
+	},
+	.probe = l3gd20h_gyr_probe,
+	.remove = l3gd20h_gyr_remove,
+	.id_table = l3gd20h_gyr_id,
+
+};
+
+module_i2c_driver(l3gd20h_gyr_driver);
+
+MODULE_DESCRIPTION("l3gd20h gyroscope driver");
+MODULE_AUTHOR("Matteo Dameno, Denis Ciocca, STMicroelectronics");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/misc/l3gd20h.h b/drivers/input/misc/l3gd20h.h
new file mode 100644
index 0000000..c4ee6cf
--- /dev/null
+++ b/drivers/input/misc/l3gd20h.h
@@ -0,0 +1,112 @@
+/******************** (C) COPYRIGHT 2012 STMicroelectronics ********************
+*
+* File Name		: l3gd20h_gyr_sysfs.c
+* Authors		: MEMS Motion Sensors Products Div- Application Team
+*			: Matteo Dameno (matteo.dameno@st.com)
+*			: Denis Ciocca (denis.ciocca@st.com)
+*			: Both authors are willing to be considered the contact
+*			: and update points for the driver.
+* Version		: V 1.2.1 sysfs
+* Date			: 2012/Jul/10
+* Description		: L3GD20H digital output gyroscope sensor API
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+* REVISON HISTORY
+*
+* VERSION	| DATE		| AUTHORS	  | DESCRIPTION
+* 1.0		| 2010/May/02	| Carmine Iascone | First Release
+* 1.1.3		| 2011/Jun/24	| Matteo Dameno	  | Corrects ODR Bug
+* 1.1.4		| 2011/Sep/02	| Matteo Dameno	  | SMB Bus Mng,
+*		|		|		  | forces BDU setting
+* 1.1.5		| 2011/Sep/24	| Matteo Dameno	  | Introduces FIFO Feat.
+* 1.1.5.2	| 2011/Nov/11	| Matteo Dameno	  | enable gpio_int to be
+*		|		|		  | passed as parameter at
+*		|		|		  | module loading time;
+*		|		|		  | corrects polling
+*		|		|		  | bug at end of probing;
+* 1.1.5.3	| 2011/Dec/20	| Matteo Dameno	  | corrects error in
+*		|		|		  | I2C SADROOT; Modifies
+*		|		|		  | resume suspend func.
+* 1.1.5.4	| 2012/Jan/09	| Matteo Dameno	  | moved under input/misc;
+* 1.1.5.5	| 2012/Mar/30	| Matteo Dameno	  | moved watermark, use_smbus,
+*		|		|		  | fifomode @ struct foo_status
+*		|		|		  | sysfs range input format
+*		|		|		  | changed to decimal
+* 1.2		| 2012/Jul/10	| Denis Ciocca	  | input_poll_dev removal
+* 1.2.1		| 2012/Jul/10	| Denis Ciocca	  | added high resolution timers
+*******************************************************************************/
+
+#ifndef __L3GD20H_GYR_H__
+#define __L3GD20H_GYR_H__
+
+#define L3GD20H_GYR_DEV_NAME		"l3gd20h_gyr"
+
+#define L3GD20H_GYR_ENABLED		1
+#define L3GD20H_GYR_DISABLED		0
+
+#ifdef __KERNEL__
+
+#define L3GD20H_SAD0L			(0x00)
+#define L3GD20H_SAD0H			(0x01)
+#define L3GD20H_GYR_I2C_SADROOT	(0x35)
+
+/* I2C address if gyr SA0 pin to GND */
+#define L3GD20H_GYR_I2C_SAD_L		((L3GD20H_GYR_I2C_SADROOT<<1)| \
+							L3GD20H_SAD0L)
+/* I2C address if gyr SA0 pin to Vdd */
+#define L3GD20H_GYR_I2C_SAD_H		((L3GD20H_GYR_I2C_SADROOT<<1)| \
+							L3GD20H_SAD0H)
+
+
+/* to set gpios numb connected to gyro interrupt pins,
+ * the unused ones havew to be set to -EINVAL
+ */
+#define L3GD20H_GYR_DEFAULT_INT1_GPIO		(-EINVAL)
+#define L3GD20H_GYR_DEFAULT_INT2_GPIO		(-EINVAL)
+
+#define L3GD20H_GYR_MIN_POLL_PERIOD_MS	2
+
+#define L3GD20H_GYR_FS_250DPS		(0x00)
+#define L3GD20H_GYR_FS_500DPS		(0x10)
+#define L3GD20H_GYR_FS_2000DPS	(0x30)
+
+struct l3gd20h_gyr_platform_data {
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	/* gpio ports for interrupt pads */
+	int gpio_int1;
+	int gpio_int2;		/* int for fifo */
+
+	/* axis mapping */
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+};
+#endif /* __KERNEL__ */
+
+#endif  /* __L3GD20H_GYR_H__ */
diff --git a/drivers/input/misc/lsm303d.c b/drivers/input/misc/lsm303d.c
new file mode 100644
index 0000000..6be14e6
--- /dev/null
+++ b/drivers/input/misc/lsm303d.c
@@ -0,0 +1,3462 @@
+/******************** (C) COPYRIGHT 2013 STMicroelectronics *******************
+*
+* File Name          : lsm303d.h
+* Authors            : AMS - MSH Div - Application Team
+*		     : Matteo Dameno (matteo.dameno@st.com)
+*		     : Denis Ciocca (denis.ciocca@st.com)
+*		     : Both authors are willing to be considered the contact
+*		     : and update points for the driver.
+* Version            : V.1.0.5
+* Date               : 2013/Oct/23
+* Description        : LSM303D accelerometer & magnetometer driver
+*
+*******************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+******************************************************************************/
+/******************************************************************************
+Version History.
+
+Revision 1-0-0 2012/05/04
+ first revision
+Revision 1-0-1 2012/05/07
+ New sysfs architecture
+ Support antialiasing filter
+Revision 1-0-2 2012/10/15
+ I2C address bugfix
+Revision 1-0-3 2013/01/21
+ Move CTLREG7 resume write from acc_power_on to magn_power_on
+Revision 1-0-4 2013/05/09
+ Added rotation matrix
+Revision 1-0-5 2013/10/23
+ Corrects Mag Enable bug, Corrects missing BDU enable
+******************************************************************************/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/workqueue.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kobject.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_graph.h>
+
+//#include <linux/input/lsm303d.h>
+#include "lsm303d.h"
+
+
+#define	I2C_AUTO_INCREMENT	(0x80)
+#define MS_TO_NS(x)		(x*1000000L)
+
+#define	ACC_G_MAX_POS		1495040	/** max positive value acc [ug] */
+#define	ACC_G_MAX_NEG		1495770	/** max negative value acc [ug] */
+#define	MAG_G_MAX_POS		983520	/** max positive value mag [ugauss] */
+#define	MAG_G_MAX_NEG		983040	/** max negative value mag [ugauss] */
+
+#define FUZZ			0
+#define FLAT			0
+
+/* Address registers */
+#define REG_WHOAMI_ADDR		(0x0F)	/** Who am i address register */
+#define REG_CNTRL0_ADDR		(0x1F)	/** CNTRL0 address register */
+#define REG_CNTRL1_ADDR		(0x20)	/** CNTRL1 address register */
+#define REG_CNTRL2_ADDR		(0x21)	/** CNTRL2 address register */
+#define REG_CNTRL3_ADDR		(0x22)	/** CNTRL3 address register */
+#define REG_CNTRL4_ADDR		(0x23)	/** CNTRL4 address register */
+#define REG_CNTRL5_ADDR		(0x24)	/** CNTRL5 address register */
+#define REG_CNTRL6_ADDR		(0x25)	/** CNTRL6 address register */
+#define REG_CNTRL7_ADDR		(0x26)	/** CNTRL7 address register */
+
+#define REG_ACC_DATA_ADDR	(0x28)	/** Acc. data low address register */
+#define REG_MAG_DATA_ADDR	(0x08)	/** Mag. data low address register */
+#define REG_TEMP_DATA_ADDR	(0x05)	/** Temp. data low address register */
+
+#define REG_GEN_MAG_ADDR	(0x12)	/** INT_CTRL_REG_M address register */
+#define INT_SRC_REG_M_ADDR	(0x13)	/** INT_SRC_REG_M address register */
+#define REG_GEN_MAG_THR_ADDR	(0x14)	/** INT_THS_L_M address register */
+#define MIG_THRESHOLD_ADDR_H	(0x15)	/** INT_THS_H_M address register */
+#define REG_GEN1_AXIS_ADDR	(0x30)	/** INT_GEN1_REG address register */
+#define INT_GEN1_SRC_ADDR	(0x31)	/** INT_GEN1_SRC address register */
+#define REG_GEN1_THR_ADDR	(0x32)	/** INT_GEN1_THS address register */
+#define REG_GEN1_DUR_ADDR	(0x33)	/** INT_GEN1_DUR address register */
+#define REG_GEN2_AXIS_ADDR	(0x34)	/** INT_GEN2_REG address register */
+#define INT_GEN2_SRC_ADDR	(0x35)	/** INT_GEN2_SRC address register */
+#define REG_GEN2_THR_ADDR	(0x36)	/** INT_GEN2_THS address register */
+#define REG_GEN2_DUR_ADDR	(0x37)	/** INT_GEN2_DUR address register */
+
+/* Sensitivity */
+#define SENSITIVITY_ACC_2G	60	/**	ug/LSB	*/
+#define SENSITIVITY_ACC_4G	120	/**	ug/LSB	*/
+#define SENSITIVITY_ACC_8G	240	/**	ug/LSB	*/
+#define SENSITIVITY_ACC_16G	730	/**	ug/LSB	*/
+
+#define SENSITIVITY_MAG_2G	80	/**	ugauss/LSB	*/
+#define SENSITIVITY_MAG_4G	160	/**	ugauss/LSB	*/
+#define SENSITIVITY_MAG_8G	320	/**	ugauss/LSB	*/
+#define SENSITIVITY_MAG_12G	480	/**	ugauss/LSB	*/
+
+/* ODR */
+#define ODR_ACC_MASK		(0XF0)	/* Mask for odr change on acc */
+#define LSM303D_ACC_ODR_OFF	(0x00)  /* Power down */
+#define LSM303D_ACC_ODR3_125	(0x10)  /* 3.25Hz output data rate */
+#define LSM303D_ACC_ODR6_25	(0x20)  /* 6.25Hz output data rate */
+#define LSM303D_ACC_ODR12_5	(0x30)  /* 12.5Hz output data rate */
+#define LSM303D_ACC_ODR25	(0x40)  /* 25Hz output data rate */
+#define LSM303D_ACC_ODR50	(0x50)  /* 50Hz output data rate */
+#define LSM303D_ACC_ODR100	(0x60)  /* 100Hz output data rate */
+#define LSM303D_ACC_ODR200	(0x70)  /* 200Hz output data rate */
+#define LSM303D_ACC_ODR400	(0x80)  /* 400Hz output data rate */
+#define LSM303D_ACC_ODR800	(0x90)  /* 800Hz output data rate */
+#define LSM303D_ACC_ODR1600	(0xA0)  /* 1600Hz output data rate */
+
+#define ODR_MAG_MASK		(0X1C)	/* Mask for odr change on mag */
+#define LSM303D_MAG_ODR3_125	(0x00)  /* 3.25Hz output data rate */
+#define LSM303D_MAG_ODR6_25	(0x04)  /* 6.25Hz output data rate */
+#define LSM303D_MAG_ODR12_5	(0x08)  /* 12.5Hz output data rate */
+#define LSM303D_MAG_ODR25	(0x0C)  /* 25Hz output data rate */
+#define LSM303D_MAG_ODR50	(0x10)  /* 50Hz output data rate */
+#define LSM303D_MAG_ODR100	(0x14)  /* 100Hz output data rate */
+
+/* Magnetic sensor mode */
+#define MSMS_MASK		(0x03)	/* Mask magnetic sensor mode */
+#define POWEROFF_MAG		(0x02)	/* Power Down */
+#define CONTINUOS_CONVERSION	(0x00)	/* Continuos Conversion */
+
+/* Default values loaded in probe function */
+#define WHOIAM_VALUE		(0x49)	/** Who Am I default value */
+#define REG_DEF_CNTRL0		(0x00)	/** CNTRL0 default value */
+#define REG_DEF_CNTRL1		(0x0F)	/** CNTRL1 default value */
+#define REG_DEF_CNTRL2		(0x00)	/** CNTRL2 default value */
+#define REG_DEF_CNTRL3		(0x00)	/** CNTRL3 default value */
+#define REG_DEF_CNTRL4		(0x00)	/** CNTRL4 default value */
+#define REG_DEF_CNTRL5		(0x18)	/** CNTRL5 default value */
+#define REG_DEF_CNTRL6		(0x20)	/** CNTRL6 default value */
+#define REG_DEF_CNTRL7		(0x02)	/** CNTRL7 default value */
+
+#define REG_DEF_INT_CNTRL_MAG	(0x00)	/** INT_CTRL_REG_M default value */
+#define REG_DEF_INT_GEN1	(0x00)	/** INT_GEN1_REG default value */
+#define REG_DEF_INT_GEN2	(0x00)	/** INT_GEN2_REG default value */
+#define REG_DEF_IIG1_DURATION	(0x00)	/** INT_GEN1_DUR default value */
+#define REG_DEF_IIG2_DURATION	(0x00)	/** INT_GEN2_DUR default value */
+#define REG_DEF_IIG1_THRESHOLD	(0x00)	/** INT_GEN1_THS default value */
+#define REG_DEF_IIG2_THRESHOLD	(0x00)	/** INT_GEN2_THS default value */
+#define REG_DEF_MIG_THRESHOLD_L	(0x00)	/** INT_THS_L_M default value */
+#define REG_DEF_MIG_THRESHOLD_H	(0x00)	/** INT_THS_H_M default value */
+
+#define REG_DEF_ALL_ZEROS	(0x00)
+
+/* Accelerometer Filter */
+#define LSM303D_ACC_FILTER_MASK	(0xC0)	/* Mask for filter band change on acc */
+#define FILTER_773		773	/* Anti-Aliasing 773 Hz */
+#define FILTER_362		362	/* Anti-Aliasing 362 Hz */
+#define FILTER_194		194	/* Anti-Aliasing 194 Hz */
+#define FILTER_50		50	/* Anti-Aliasing 50 Hz */
+
+/* Temperature */
+#define TEMP_MASK		(0x80)	/* Mask for temperature change */
+#define TEMP_ON			(0x80)	/* Enable temperature */
+#define TEMP_OFF		(0x00)	/* Disable temperature */
+#define TEMP_SENSITIVITY	8	/* Sensitivity temperature */
+#define OFFSET_TEMP		25	/* Offset temperature */
+#define NDTEMP			1000	/* Not Available temperature */
+
+/* Interrupt */
+#define GEN1_PIN1_MASK		(0x20)
+#define GEN1_PIN2_MASK		(0x40)
+#define GEN2_PIN1_MASK		(0x10)
+#define GEN2_PIN2_MASK		(0x20)
+#define GEN_MAG_PIN1_MASK	(0x08)
+#define GEN_MAG_PIN2_MASK	(0x10)
+#define GEN_MAG_EN_MASK		(0x01)
+#define MAX_DUR_TH		127
+#define MAX_TH_MAG		131071
+#define GEN_X_HIGH_MASK		(0x02)
+#define GEN_X_LOW_MASK		(0x01)
+#define GEN_Y_HIGH_MASK		(0x08)
+#define GEN_Y_LOW_MASK		(0x04)
+#define GEN_Z_HIGH_MASK		(0x20)
+#define GEN_Z_LOW_MASK		(0x10)
+#define GEN_X_MAG_MASK		(0x80)
+#define GEN_Y_MAG_MASK		(0x40)
+#define GEN_Z_MAG_MASK		(0x20)
+
+#define GEN1_AND_OR_MASK	(0x80)
+#define GEN2_AND_OR_MASK	(0x83)
+
+#define INT_PIN_CONF_MASK	(0x10)
+#define INT_POLARITY_MASK	(0x80)
+
+#define to_dev(obj) container_of(obj, struct device, kobj)
+#define to_dev_attr(_attr) container_of(_attr, struct device_attribute, attr)
+
+static struct kobject *acc_kobj;
+static struct kobject *mag_kobj;
+
+struct workqueue_struct *lsm303d_workqueue = 0;
+
+struct {
+	unsigned int cutoff_us;
+	u8 value;
+} lsm303d_acc_odr_table[] = {
+		{   1, LSM303D_ACC_ODR800  },
+		{   2, LSM303D_ACC_ODR400  },
+		{   5, LSM303D_ACC_ODR200  },
+		{  10, LSM303D_ACC_ODR100  },
+		{  20, LSM303D_ACC_ODR50   },
+		{  40, LSM303D_ACC_ODR25   },
+		{  80, LSM303D_ACC_ODR12_5 },
+		{ 160, LSM303D_ACC_ODR6_25 },
+		{ 320, LSM303D_ACC_ODR3_125},
+};
+
+struct {
+	unsigned int cutoff_us;
+	u8 value;
+} lsm303d_mag_odr_table[] = {
+		{  10, LSM303D_MAG_ODR100  },
+		{  20, LSM303D_MAG_ODR50   },
+		{  40, LSM303D_MAG_ODR25   },
+		{  80, LSM303D_MAG_ODR12_5 },
+		{ 160, LSM303D_MAG_ODR6_25 },
+		{ 320, LSM303D_MAG_ODR3_125},
+};
+
+struct interrupt_enable {
+	atomic_t enable;
+	u8 address;
+	u8 mask;
+};
+
+struct interrupt_value {
+	int value;
+	u8 address;
+};
+
+struct lsm303d_interrupt {
+	struct interrupt_enable gen1_pin1;
+	struct interrupt_enable gen1_pin2;
+	struct interrupt_enable gen2_pin1;
+	struct interrupt_enable gen2_pin2;
+	struct interrupt_value gen1_threshold;
+	struct interrupt_value gen2_threshold;
+	struct interrupt_value gen1_duration;
+	struct interrupt_value gen2_duration;
+	struct interrupt_enable gen_mag_pin1;
+	struct interrupt_enable gen_mag_pin2;
+	struct interrupt_enable gen_mag;
+	struct interrupt_value gen_mag_threshold;
+	struct interrupt_enable gen1_axis[6];
+	struct interrupt_enable gen2_axis[6];
+	struct interrupt_enable gen_mag_axis[3];
+	struct interrupt_enable gen1_and_or;
+	struct interrupt_enable gen2_and_or;
+	struct interrupt_enable interrupt_pin_conf;
+	struct interrupt_enable interrupt_polarity;
+};
+
+struct lsm303d_status {
+	struct i2c_client *client;
+	struct lsm303d_acc_platform_data *pdata_acc;
+	struct lsm303d_mag_platform_data *pdata_mag;
+
+	struct mutex lock;
+	struct work_struct input_work_acc;
+	struct work_struct input_work_mag;
+
+	struct hrtimer hr_timer_acc;
+	ktime_t ktime_acc;
+	struct hrtimer hr_timer_mag;
+	ktime_t ktime_mag;
+
+	struct input_dev *input_dev_acc;
+	struct input_dev *input_dev_mag;
+	struct input_dev *input_dev_temp;
+
+	struct lsm303d_interrupt *interrupt;
+
+	int hw_initialized;
+	/* hw_working=-1 means not tested yet */
+	int hw_working;
+
+	atomic_t enabled_acc;
+	atomic_t enabled_mag;
+	atomic_t enabled_temp;
+
+	int temp_value_dec;
+	unsigned int temp_value_flo;
+
+	int on_before_suspend;
+	int use_smbus;
+
+	u16 sensitivity_acc;
+	u16 sensitivity_mag;
+
+	int irq1;
+	struct work_struct irq1_work;
+	struct workqueue_struct *irq1_work_queue;
+	int irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+};
+
+static const struct lsm303d_acc_platform_data default_lsm303d_acc_pdata = {
+	.fs_range = LSM303D_ACC_FS_2G,
+	.rot_matrix = {
+		{1, 0, 0},
+		{0, 1, 0},
+		{0, 0, 1},
+	},
+	.poll_interval = 100,
+	.min_interval = LSM303D_ACC_MIN_POLL_PERIOD_MS,
+	.aa_filter_bandwidth = ANTI_ALIASING_773,
+	.gpio_int1 = DEFAULT_INT1_GPIO,
+	.gpio_int2 = DEFAULT_INT2_GPIO,
+};
+
+static const struct lsm303d_mag_platform_data default_lsm303d_mag_pdata = {
+	.poll_interval = 100,
+	.min_interval = LSM303D_MAG_MIN_POLL_PERIOD_MS,
+	.fs_range = LSM303D_MAG_FS_2G,
+	.rot_matrix = {
+		{1, 0, 0},
+		{0, 1, 0},
+		{0, 0, 1},
+	},
+};
+
+struct reg_rw {
+	u8 address;
+	u8 default_value;
+	u8 resume_value;
+};
+
+struct reg_r {
+	u8 address;
+	u8 value;
+};
+
+static struct status_registers {
+	struct reg_r who_am_i;
+	struct reg_rw cntrl0;
+	struct reg_rw cntrl1;
+	struct reg_rw cntrl2;
+	struct reg_rw cntrl3;
+	struct reg_rw cntrl4;
+	struct reg_rw cntrl5;
+	struct reg_rw cntrl6;
+	struct reg_rw cntrl7;
+	struct reg_rw int_ctrl_reg_m;
+	struct reg_rw int_mag_threshold_low;
+	struct reg_rw int_mag_threshold_high;
+	struct reg_rw int_gen1_reg;
+	struct reg_rw int_gen2_reg;
+	struct reg_rw int_gen1_duration;
+	struct reg_rw int_gen2_duration;
+	struct reg_rw int_gen1_threshold;
+	struct reg_rw int_gen2_threshold;
+	struct reg_r int_src_reg_m;
+	struct reg_r int_gen1_src;
+	struct reg_r int_gen2_src;
+	struct reg_r int_gen_mag_src;
+} status_registers = {
+	.who_am_i.address=REG_WHOAMI_ADDR, .who_am_i.value=WHOIAM_VALUE,
+	.cntrl0.address=REG_CNTRL0_ADDR, .cntrl0.default_value=REG_DEF_CNTRL0,
+	.cntrl1.address=REG_CNTRL1_ADDR, .cntrl1.default_value=REG_DEF_CNTRL1,
+	.cntrl2.address=REG_CNTRL2_ADDR, .cntrl2.default_value=REG_DEF_CNTRL2,
+	.cntrl3.address=REG_CNTRL3_ADDR, .cntrl3.default_value=REG_DEF_CNTRL3,
+	.cntrl4.address=REG_CNTRL4_ADDR, .cntrl4.default_value=REG_DEF_CNTRL4,
+	.cntrl5.address=REG_CNTRL5_ADDR, .cntrl5.default_value=REG_DEF_CNTRL5,
+	.cntrl6.address=REG_CNTRL6_ADDR, .cntrl6.default_value=REG_DEF_CNTRL6,
+	.cntrl7.address=REG_CNTRL7_ADDR, .cntrl7.default_value=REG_DEF_CNTRL7,
+	.int_ctrl_reg_m.address=REG_GEN_MAG_ADDR, 
+		.int_ctrl_reg_m.default_value=REG_DEF_INT_CNTRL_MAG,
+	.int_mag_threshold_low.address=REG_GEN_MAG_THR_ADDR,
+		.int_mag_threshold_low.default_value=REG_DEF_MIG_THRESHOLD_L,
+	.int_mag_threshold_low.address=MIG_THRESHOLD_ADDR_H,
+		.int_mag_threshold_low.default_value=REG_DEF_MIG_THRESHOLD_H,
+	.int_gen1_reg.address=REG_GEN1_AXIS_ADDR, 
+		.int_gen1_reg.default_value=REG_DEF_INT_GEN1,
+	.int_gen2_reg.address=REG_GEN2_AXIS_ADDR, 
+		.int_gen2_reg.default_value=REG_DEF_INT_GEN2,
+	.int_gen1_duration.address=REG_GEN1_DUR_ADDR,
+		.int_gen1_duration.default_value=REG_DEF_IIG1_DURATION,
+	.int_gen2_duration.address=REG_GEN2_DUR_ADDR,
+		.int_gen2_duration.default_value=REG_DEF_IIG2_DURATION,
+	.int_gen1_threshold.address=REG_GEN1_THR_ADDR,
+		.int_gen1_threshold.default_value=REG_DEF_IIG1_THRESHOLD,
+	.int_gen2_threshold.address=REG_GEN2_THR_ADDR,
+		.int_gen2_threshold.default_value=REG_DEF_IIG2_THRESHOLD,
+	.int_src_reg_m.address = INT_SRC_REG_M_ADDR,
+				.int_src_reg_m.value = REG_DEF_ALL_ZEROS,
+	.int_gen1_src.address = INT_GEN1_SRC_ADDR,
+				.int_gen1_src.value = REG_DEF_ALL_ZEROS,
+	.int_gen2_src.address = INT_GEN2_SRC_ADDR,
+				.int_gen2_src.value = REG_DEF_ALL_ZEROS,
+	.int_gen_mag_src.address = INT_SRC_REG_M_ADDR,
+				.int_gen_mag_src.value = REG_DEF_ALL_ZEROS,
+};
+
+static int lsm303d_i2c_read(struct lsm303d_status *stat, u8 *buf, int len)
+{
+	int ret;
+	u8 reg = buf[0];
+	u8 cmd = reg;
+#ifdef DEBUG
+	unsigned int ii;
+#endif
+
+
+	if (len > 1)
+		cmd = (I2C_AUTO_INCREMENT | reg);
+	if (stat->use_smbus) {
+		if (len == 1) {
+			ret = i2c_smbus_read_byte_data(stat->client, cmd);
+			buf[0] = ret & 0xff;
+#ifdef DEBUG
+			dev_warn(&stat->client->dev,
+				"i2c_smbus_read_byte_data: ret=0x%02x, len:%d ,"
+				"command=0x%02x, buf[0]=0x%02x\n",
+				ret, len, cmd , buf[0]);
+#endif
+		} else if (len > 1) {
+			ret = i2c_smbus_read_i2c_block_data(stat->client,
+								cmd, len, buf);
+#ifdef DEBUG
+			dev_warn(&stat->client->dev,
+				"i2c_smbus_read_i2c_block_data: ret:%d len:%d, "
+				"command=0x%02x, ",
+				ret, len, cmd);
+			for (ii = 0; ii < len; ii++)
+				printk(KERN_DEBUG "buf[%d]=0x%02x,",
+								ii, buf[ii]);
+
+			printk("\n");
+#endif
+		} else
+			ret = -1;
+
+		if (ret < 0) {
+			dev_err(&stat->client->dev,
+				"read transfer error: len:%d, command=0x%02x\n",
+				len, cmd);
+			return 0;
+		}
+		return len;
+	}
+
+	ret = i2c_master_send(stat->client, &cmd, sizeof(cmd));
+	if (ret != sizeof(cmd))
+		return ret;
+
+	return i2c_master_recv(stat->client, buf, len);
+}
+
+static int lsm303d_i2c_write(struct lsm303d_status *stat, u8 *buf, int len)
+{
+	int ret;
+	u8 reg, value;
+#ifdef DEBUG
+	unsigned int ii;
+#endif
+
+	if (len > 1)
+		buf[0] = (I2C_AUTO_INCREMENT | buf[0]);
+
+	reg = buf[0];
+	value = buf[1];
+
+	if (stat->use_smbus) {
+		if (len == 1) {
+			ret = i2c_smbus_write_byte_data(stat->client,
+								reg, value);
+#ifdef DEBUG
+			dev_warn(&stat->client->dev,
+				"i2c_smbus_write_byte_data: ret=%d, len:%d, "
+				"command=0x%02x, value=0x%02x\n",
+				ret, len, reg , value);
+#endif
+			return ret;
+		} else if (len > 1) {
+			ret = i2c_smbus_write_i2c_block_data(stat->client,
+							reg, len, buf + 1);
+#ifdef DEBUG
+			dev_warn(&stat->client->dev,
+				"i2c_smbus_write_i2c_block_data: ret=%d, "
+				"len:%d, command=0x%02x, ",
+				ret, len, reg);
+			for (ii = 0; ii < (len + 1); ii++)
+				printk(KERN_DEBUG "value[%d]=0x%02x,",
+								ii, buf[ii]);
+
+			printk("\n");
+#endif
+			return ret;
+		}
+	}
+
+	ret = i2c_master_send(stat->client, buf, len+1);
+	return (ret == len+1) ? 0 : ret;
+}
+
+static int lsm303d_hw_init(struct lsm303d_status *stat)
+{
+	int err = -1;
+	u8 buf[1];
+	int i;
+
+	pr_info("%s: hw init start\n", LSM303D_DEV_NAME);
+
+	buf[0] = status_registers.who_am_i.address;
+	err = lsm303d_i2c_read(stat, buf, 1);
+	
+	if (err < 0) {
+		dev_warn(&stat->client->dev, "Error reading WHO_AM_I: is device"
+		" available/working?\n");
+		goto err_firstread;
+	} else
+		stat->hw_working = 1;
+
+	if (buf[0] != status_registers.who_am_i.value) {
+	dev_err(&stat->client->dev,
+		"device unknown. Expected: 0x%02x,"
+		" Replies: 0x%02x\n", status_registers.who_am_i.value, buf[0]);
+		err = -1;
+		goto err_unknown_device;
+	}
+
+	status_registers.cntrl1.resume_value = 
+					status_registers.cntrl1.default_value;
+	status_registers.cntrl2.resume_value = 
+					status_registers.cntrl2.default_value;
+	status_registers.cntrl3.resume_value = 
+					status_registers.cntrl3.default_value;
+	status_registers.cntrl4.resume_value = 
+					status_registers.cntrl4.default_value;
+	status_registers.cntrl5.resume_value = 
+					status_registers.cntrl5.default_value;
+	status_registers.cntrl6.resume_value = 
+					status_registers.cntrl6.default_value;
+	status_registers.cntrl7.resume_value = 
+					status_registers.cntrl7.default_value;
+
+	status_registers.int_ctrl_reg_m.resume_value = 
+			status_registers.int_ctrl_reg_m.default_value;
+	status_registers.int_mag_threshold_low.resume_value = 
+			status_registers.int_mag_threshold_low.default_value;
+	status_registers.int_mag_threshold_high.resume_value = 
+			status_registers.int_mag_threshold_high.default_value;
+	status_registers.int_gen1_reg.resume_value = 
+			status_registers.int_gen1_reg.default_value;
+	status_registers.int_gen2_reg.resume_value = 
+			status_registers.int_gen2_reg.default_value;
+	status_registers.int_gen1_duration.resume_value = 
+			status_registers.int_gen1_duration.default_value;
+	status_registers.int_gen2_duration.resume_value = 
+			status_registers.int_gen2_duration.default_value;
+	status_registers.int_gen1_threshold.resume_value = 
+			status_registers.int_gen1_threshold.default_value;
+	status_registers.int_gen2_threshold.resume_value = 
+			status_registers.int_gen2_threshold.default_value;
+
+
+	stat->temp_value_dec = NDTEMP;
+
+	if((stat->pdata_acc->gpio_int1 >= 0) || 
+					(stat->pdata_acc->gpio_int2 >= 0)) {
+
+		stat->interrupt = kmalloc(sizeof(*stat->interrupt), 
+								GFP_KERNEL);
+
+		if(stat->interrupt == NULL)
+			goto error_interrupt;
+
+		stat->interrupt->gen1_pin1.address = REG_CNTRL3_ADDR;
+		stat->interrupt->gen1_pin2.address = REG_CNTRL4_ADDR;
+		stat->interrupt->gen2_pin1.address = REG_CNTRL3_ADDR;
+		stat->interrupt->gen2_pin2.address = REG_CNTRL4_ADDR;
+		stat->interrupt->gen_mag_pin1.address = REG_CNTRL3_ADDR;
+		stat->interrupt->gen_mag_pin2.address = REG_CNTRL4_ADDR;
+		stat->interrupt->gen_mag.address = REG_GEN_MAG_ADDR;
+		stat->interrupt->gen1_duration.address = REG_GEN1_DUR_ADDR;
+		stat->interrupt->gen2_duration.address = REG_GEN2_DUR_ADDR;
+		stat->interrupt->gen1_threshold.address = REG_GEN1_THR_ADDR;
+		stat->interrupt->gen2_threshold.address = REG_GEN2_THR_ADDR;
+		stat->interrupt->gen_mag_threshold.address = 
+							REG_GEN_MAG_THR_ADDR;
+
+		stat->interrupt->gen1_pin1.mask = GEN1_PIN1_MASK;
+		stat->interrupt->gen1_pin2.mask = GEN1_PIN2_MASK;
+		stat->interrupt->gen2_pin1.mask = GEN2_PIN1_MASK;
+		stat->interrupt->gen2_pin2.mask = GEN2_PIN2_MASK;
+		stat->interrupt->gen_mag_pin1.mask = GEN_MAG_PIN1_MASK;
+		stat->interrupt->gen_mag_pin2.mask = GEN_MAG_PIN2_MASK;
+		stat->interrupt->gen_mag.mask = GEN_MAG_EN_MASK;
+
+		atomic_set(&stat->interrupt->gen1_pin1.enable, 0);
+		atomic_set(&stat->interrupt->gen1_pin2.enable, 0);
+		atomic_set(&stat->interrupt->gen2_pin1.enable, 0);
+		atomic_set(&stat->interrupt->gen2_pin2.enable, 0);
+		atomic_set(&stat->interrupt->gen_mag_pin1.enable, 0);
+		atomic_set(&stat->interrupt->gen_mag_pin2.enable, 0);
+		atomic_set(&stat->interrupt->gen_mag.enable, 0);
+
+		stat->interrupt->gen1_threshold.value = 0;
+		stat->interrupt->gen2_threshold.value = 0;
+		stat->interrupt->gen1_duration.value = 0;
+		stat->interrupt->gen2_duration.value = 0;
+		stat->interrupt->gen_mag_threshold.value = 0;
+
+		for(i=0; i<6; i++) {
+			stat->interrupt->gen1_axis[i].address = 
+							REG_GEN1_AXIS_ADDR;
+			stat->interrupt->gen2_axis[i].address = 
+							REG_GEN2_AXIS_ADDR;
+
+			atomic_set(&stat->interrupt->gen1_axis[i].enable, 0);
+			atomic_set(&stat->interrupt->gen2_axis[i].enable, 0);
+		}
+		for(i=0; i<3; i++) {
+			stat->interrupt->gen_mag_axis[i].address = 
+							REG_GEN_MAG_ADDR;
+			atomic_set(&stat->interrupt->gen_mag_axis[i].enable, 0);
+		}
+
+		stat->interrupt->gen1_axis[0].mask = GEN_X_LOW_MASK;
+		stat->interrupt->gen1_axis[1].mask = GEN_Y_LOW_MASK;
+		stat->interrupt->gen1_axis[2].mask = GEN_Z_LOW_MASK;
+		stat->interrupt->gen1_axis[3].mask = GEN_X_HIGH_MASK;
+		stat->interrupt->gen1_axis[4].mask = GEN_Y_HIGH_MASK;
+		stat->interrupt->gen1_axis[5].mask = GEN_Z_HIGH_MASK;
+
+		stat->interrupt->gen2_axis[0].mask = GEN_X_LOW_MASK;
+		stat->interrupt->gen2_axis[1].mask = GEN_Y_LOW_MASK;
+		stat->interrupt->gen2_axis[2].mask = GEN_Z_LOW_MASK;
+		stat->interrupt->gen2_axis[3].mask = GEN_X_HIGH_MASK;
+		stat->interrupt->gen2_axis[4].mask = GEN_Y_HIGH_MASK;
+		stat->interrupt->gen2_axis[5].mask = GEN_Z_HIGH_MASK;
+
+		stat->interrupt->gen_mag_axis[0].mask = GEN_X_MAG_MASK;
+		stat->interrupt->gen_mag_axis[1].mask = GEN_Y_MAG_MASK;
+		stat->interrupt->gen_mag_axis[2].mask = GEN_Z_MAG_MASK;
+
+		stat->interrupt->gen1_and_or.address = REG_GEN1_AXIS_ADDR;
+		stat->interrupt->gen1_and_or.mask = GEN1_AND_OR_MASK;
+		atomic_set(&stat->interrupt->gen1_and_or.enable, 0);
+		stat->interrupt->gen2_and_or.address = REG_GEN1_DUR_ADDR;
+		stat->interrupt->gen2_and_or.mask = GEN2_AND_OR_MASK;
+		atomic_set(&stat->interrupt->gen2_and_or.enable, 0);
+
+		stat->interrupt->interrupt_pin_conf.address = REG_GEN_MAG_ADDR;
+		stat->interrupt->interrupt_pin_conf.mask = INT_PIN_CONF_MASK;
+		atomic_set(&stat->interrupt->interrupt_pin_conf.enable, 0);
+
+		stat->interrupt->interrupt_polarity.address = REG_GEN_MAG_ADDR;
+		stat->interrupt->interrupt_polarity.mask = INT_POLARITY_MASK;
+		atomic_set(&stat->interrupt->interrupt_polarity.enable, 0);
+	}
+
+	stat->hw_initialized = 1;
+	pr_info("%s: hw init done\n", LSM303D_DEV_NAME);
+
+	return 0;
+
+error_interrupt:
+err_unknown_device:
+err_firstread:
+	stat->hw_working = 0;
+	stat->hw_initialized = 0;
+	return err;
+}
+
+static irqreturn_t lsm303d_isr1(int irq, void *dev)
+{
+	struct lsm303d_status *stat = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(stat->irq1_work_queue, &stat->irq1_work);
+	pr_debug("%s: isr1 queued\n", LSM303D_DEV_NAME);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t lsm303d_isr2(int irq, void *dev)
+{
+	struct lsm303d_status *stat = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(stat->irq2_work_queue, &stat->irq2_work);
+	pr_debug("%s: isr2 queued\n", LSM303D_DEV_NAME);
+	return IRQ_HANDLED;
+}
+
+static void lsm303d_interrupt_catch(struct lsm303d_status *stat, int pin ) 
+{
+	u8 buf[2];
+	u8 val;
+
+	if(atomic_read(&stat->interrupt->gen1_pin1.enable) == 1) {
+		buf[0] = status_registers.int_gen1_src.address;
+		val = lsm303d_i2c_read(stat, buf, 1);
+		if(val < 0)
+			return;
+		status_registers.int_gen1_src.value = buf[0];
+
+		if(((int)status_registers.int_gen1_src.value) > 64)
+			pr_info("interrupt send by accelerometer interrupt "
+							"generator 1\n");
+	}
+	if(atomic_read(&stat->interrupt->gen_mag_pin1.enable) == 1) {
+		buf[0] = status_registers.int_gen_mag_src.address;
+		val = lsm303d_i2c_read(stat, buf, 1);
+		if(val < 0)
+			return;
+		status_registers.int_gen_mag_src.value = buf[0];
+
+		if(((int)status_registers.int_gen_mag_src.value) > 1)
+			pr_info("interrupt send by magnetometer interrupt "
+								"generator\n");
+	}
+
+}
+
+static void lsm303d_irq1_work_func(struct work_struct *work)
+{
+
+	struct lsm303d_status *stat =
+	container_of(work, struct lsm303d_status, irq1_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lsm303d_get_int1_source(stat); */
+	
+	lsm303d_interrupt_catch(stat,1);
+	pr_info("%s: IRQ1 triggered\n", LSM303D_DEV_NAME);
+	enable_irq(stat->irq1);
+}
+
+static void lsm303d_irq2_work_func(struct work_struct *work)
+{
+
+	struct lsm303d_status *stat =
+	container_of(work, struct lsm303d_status, irq2_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lsm303d_get_int2_source(stat); */
+	
+	lsm303d_interrupt_catch(stat,2);
+	pr_info("%s: IRQ2 triggered\n", LSM303D_DEV_NAME);
+	enable_irq(stat->irq2);
+}
+
+static int lsm303d_acc_device_power_off(struct lsm303d_status *stat)
+{
+	int err;
+	u8 buf[2];
+
+	buf[0] = status_registers.cntrl1.address;
+	buf[1] = ((ODR_ACC_MASK & LSM303D_ACC_ODR_OFF) | 
+		((~ODR_ACC_MASK) & status_registers.cntrl1.resume_value));
+
+	err = lsm303d_i2c_write(stat, buf, 1);
+	if (err < 0)
+		dev_err(&stat->client->dev, "accelerometer soft power off "
+							"failed: %d\n", err);
+
+	if (stat->pdata_acc->power_off) {
+		stat->pdata_acc->power_off();
+	}
+	
+	atomic_set(&stat->enabled_acc, 0);
+
+	return 0;
+}
+
+static int lsm303d_mag_device_power_off(struct lsm303d_status *stat)
+{
+	int err;
+	u8 buf[2];
+
+	buf[0] = status_registers.cntrl7.address;
+	buf[1] = ((MSMS_MASK & POWEROFF_MAG) | 
+		((~MSMS_MASK) & status_registers.cntrl7.resume_value));
+
+	err = lsm303d_i2c_write(stat, buf, 1);
+	if (err < 0)
+		dev_err(&stat->client->dev, "magnetometer soft power off "
+							"failed: %d\n", err);
+
+	if (stat->pdata_mag->power_off) {
+		stat->pdata_mag->power_off();
+	}
+
+	atomic_set(&stat->enabled_mag, 0);
+
+	return 0;
+}
+
+static int lsm303d_acc_device_power_on(struct lsm303d_status *stat)
+{
+	int err = -1;
+	u8 buf[5];
+
+	if (stat->pdata_acc->power_on) {
+		err = stat->pdata_acc->power_on();
+		if (err < 0) {
+			dev_err(&stat->client->dev,
+				"accelerometer power_on failed: %d\n", err);
+			return err;
+		}
+	}
+
+	buf[0] = status_registers.cntrl0.address;
+	buf[1] = status_registers.cntrl0.resume_value;
+	err = lsm303d_i2c_write(stat, buf, 1);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.cntrl1.address;
+	buf[1] = status_registers.cntrl1.resume_value;
+	buf[2] = status_registers.cntrl2.resume_value;
+	buf[3] = status_registers.cntrl3.resume_value;
+	buf[4] = status_registers.cntrl4.resume_value;
+	err = lsm303d_i2c_write(stat, buf, 4);
+	if (err < 0)
+		goto err_resume_state;	
+
+	buf[0] = status_registers.int_gen1_reg.address;
+	buf[1] = status_registers.int_gen1_reg.resume_value;
+	err = lsm303d_i2c_write(stat, buf, 1);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int_gen1_threshold.address;
+	buf[1] = status_registers.int_gen1_threshold.resume_value;
+	buf[2] = status_registers.int_gen1_duration.resume_value;
+	err = lsm303d_i2c_write(stat, buf, 2);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int_gen2_reg.address;
+	buf[1] = status_registers.int_gen2_reg.resume_value;
+	err = lsm303d_i2c_write(stat, buf, 1);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int_gen2_threshold.address;
+	buf[1] = status_registers.int_gen2_threshold.resume_value;
+	buf[2] = status_registers.int_gen2_duration.resume_value;
+	err = lsm303d_i2c_write(stat, buf, 2);
+	if (err < 0)
+		goto err_resume_state;
+
+	atomic_set(&stat->enabled_acc, 1);
+
+	return 0;
+
+err_resume_state:
+	atomic_set(&stat->enabled_acc, 0);
+	dev_err(&stat->client->dev, "accelerometer hw power on error "
+				"0x%02x,0x%02x: %d\n", buf[0], buf[1], err);
+	return err;
+}
+
+static int lsm303d_mag_device_power_on(struct lsm303d_status *stat)
+{
+	int err = -1;
+	u8 buf[6];
+
+	if (stat->pdata_mag->power_on) {
+		err = stat->pdata_mag->power_on();
+		if (err < 0) {
+			dev_err(&stat->client->dev,
+				"magnetometer power_on failed: %d\n", err);
+			return err;
+		}
+	}
+	
+	buf[0] = status_registers.cntrl0.address;
+	buf[1] = status_registers.cntrl0.resume_value;
+	err = lsm303d_i2c_write(stat, buf, 1);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.cntrl3.address;
+	buf[1] = status_registers.cntrl3.resume_value;
+	buf[2] = status_registers.cntrl4.resume_value;
+	buf[3] = status_registers.cntrl5.resume_value;
+	buf[4] = status_registers.cntrl6.resume_value;
+
+	err = lsm303d_i2c_write(stat, buf, 4);
+	if (err < 0)
+		goto err_resume_state;	
+
+	buf[0] = status_registers.int_ctrl_reg_m.address;
+	buf[1] = status_registers.int_ctrl_reg_m.resume_value;
+	err = lsm303d_i2c_write(stat, buf, 1);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int_mag_threshold_low.address;
+	buf[1] = status_registers.int_mag_threshold_low.resume_value;
+	buf[2] = status_registers.int_mag_threshold_high.resume_value;
+	err = lsm303d_i2c_write(stat, buf, 2);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.cntrl7.address;
+	buf[1] = ((MSMS_MASK & CONTINUOS_CONVERSION) |
+			((~MSMS_MASK) & status_registers.cntrl7.resume_value));
+	err = lsm303d_i2c_write(stat, buf, 1);
+	if (err < 0)
+		goto err_resume_state;
+
+	atomic_set(&stat->enabled_mag, 1);
+
+	return 0;
+
+err_resume_state:
+	atomic_set(&stat->enabled_mag, 0);
+	dev_err(&stat->client->dev, "magnetometer hw power on error "
+				"0x%02x,0x%02x: %d\n", buf[0], buf[1], err);
+	return err;
+}
+
+static int lsm303d_acc_update_filter(struct lsm303d_status *stat, 
+							u8 new_bandwidth)
+{
+	int err=-1;
+
+	u8 updated_val;
+	u8 buf[2];
+
+	switch (new_bandwidth) {
+	case ANTI_ALIASING_50:
+		break;
+	case ANTI_ALIASING_194:
+		break;
+	case ANTI_ALIASING_362:
+		break;
+	case ANTI_ALIASING_773:
+		break;
+	default:
+		dev_err(&stat->client->dev, "invalid accelerometer "
+			"update bandwidth requested: %u\n", new_bandwidth);
+		return -EINVAL;
+	}
+
+	buf[0] = status_registers.cntrl2.address;
+	err = lsm303d_i2c_read(stat, buf, 1);
+	if (err < 0)
+		goto error;
+
+	status_registers.cntrl2.resume_value = buf[0];	
+	updated_val = ((LSM303D_ACC_FILTER_MASK & new_bandwidth) | 
+					((~LSM303D_ACC_FILTER_MASK) & buf[0]));
+	buf[1] = updated_val;
+	buf[0] = status_registers.cntrl2.address;
+
+	err = lsm303d_i2c_write(stat, buf, 1);
+	if (err < 0)
+		goto error;
+	status_registers.cntrl2.resume_value = updated_val;
+
+	return err;
+	
+error:
+	dev_err(&stat->client->dev, "update accelerometer fs range failed "
+		"0x%02x,0x%02x: %d\n", buf[0], buf[1], err);
+	return err;
+}
+
+static int lsm303d_acc_update_fs_range(struct lsm303d_status *stat, 
+								u8 new_fs_range)
+{
+	int err=-1;
+
+	u16 sensitivity;
+	u8 updated_val;
+	u8 buf[2];
+
+	switch (new_fs_range) {
+	case LSM303D_ACC_FS_2G:
+		sensitivity = SENSITIVITY_ACC_2G;
+		break;
+	case LSM303D_ACC_FS_4G:
+		sensitivity = SENSITIVITY_ACC_4G;
+		break;
+	case LSM303D_ACC_FS_8G:
+		sensitivity = SENSITIVITY_ACC_8G;
+		break;
+	case LSM303D_ACC_FS_16G:
+		sensitivity = SENSITIVITY_ACC_16G;
+		break;
+	default:
+		dev_err(&stat->client->dev, "invalid accelerometer "
+				"fs range requested: %u\n", new_fs_range);
+		return -EINVAL;
+	}
+
+	buf[0] = status_registers.cntrl2.address;
+	err = lsm303d_i2c_read(stat, buf, 1);
+	if (err < 0)
+		goto error;
+
+	status_registers.cntrl2.resume_value = buf[0];	
+	updated_val = ((LSM303D_ACC_FS_MASK & new_fs_range) | 
+					((~LSM303D_ACC_FS_MASK) & buf[0]));
+	buf[1] = updated_val;
+	buf[0] = status_registers.cntrl2.address;
+
+	err = lsm303d_i2c_write(stat, buf, 1);
+	if (err < 0)
+		goto error;
+	status_registers.cntrl2.resume_value = updated_val;
+	stat->sensitivity_acc = sensitivity;
+
+	return err;
+	
+error:
+	dev_err(&stat->client->dev, "update accelerometer fs range failed "
+		"0x%02x,0x%02x: %d\n", buf[0], buf[1], err);
+	return err;
+}
+
+static int lsm303d_mag_update_fs_range(struct lsm303d_status *stat, 
+								u8 new_fs_range)
+{
+	int err=-1;
+
+	u16 sensitivity;
+	u8 updated_val;
+	u8 buf[2];
+
+	switch (new_fs_range) {
+	case LSM303D_MAG_FS_2G:
+		sensitivity = SENSITIVITY_MAG_2G;
+		break;
+	case LSM303D_MAG_FS_4G:
+		sensitivity = SENSITIVITY_MAG_4G;
+		break;
+	case LSM303D_MAG_FS_8G:
+		sensitivity = SENSITIVITY_MAG_8G;
+		break;
+	case LSM303D_MAG_FS_12G:
+		sensitivity = SENSITIVITY_MAG_12G;
+		break;
+	default:
+		dev_err(&stat->client->dev, "invalid magnetometer "
+				"fs range requested: %u\n", new_fs_range);
+		return -EINVAL;
+	}
+
+	buf[0] = status_registers.cntrl6.address;
+	err = lsm303d_i2c_read(stat, buf, 1);
+	if (err < 0)
+		goto error;
+
+	status_registers.cntrl6.resume_value = buf[0];	
+	updated_val = (LSM303D_MAG_FS_MASK & new_fs_range);
+	buf[1] = updated_val;
+	buf[0] = status_registers.cntrl6.address;
+
+	err = lsm303d_i2c_write(stat, buf, 1);
+	if (err < 0)
+		goto error;
+	status_registers.cntrl6.resume_value = updated_val;
+	stat->sensitivity_mag = sensitivity;
+
+	return err;
+	
+error:
+	dev_err(&stat->client->dev, "update magnetometer fs range failed "
+		"0x%02x,0x%02x: %d\n", buf[0], buf[1], err);
+	return err;
+}
+
+static int lsm303d_acc_update_odr(struct lsm303d_status *stat,
+						unsigned int poll_interval_ms)
+{
+	int err = -1;
+	u8 config[2];
+	int i;
+
+	for (i = ARRAY_SIZE(lsm303d_acc_odr_table) - 1; i >= 0; i--) {
+		if ((lsm303d_acc_odr_table[i].cutoff_us <= poll_interval_ms)
+								|| (i == 0))
+			break;
+	}
+
+	config[1] = ((ODR_ACC_MASK & lsm303d_acc_odr_table[i].value) | 
+		((~ODR_ACC_MASK) & status_registers.cntrl1.resume_value));
+
+	if (atomic_read(&stat->enabled_acc)) {
+		config[0] = status_registers.cntrl1.address;
+		err = lsm303d_i2c_write(stat, config, 1);
+		if (err < 0)
+			goto error;
+		status_registers.cntrl1.resume_value = config[1];
+		stat->ktime_acc = ktime_set(0, MS_TO_NS(poll_interval_ms));
+	}
+
+	return err;
+
+error:
+	dev_err(&stat->client->dev, "update accelerometer odr failed "
+			"0x%02x,0x%02x: %d\n", config[0], config[1], err);
+
+	return err;
+}
+
+static int lsm303d_mag_update_odr(struct lsm303d_status *stat,
+						unsigned int poll_interval_ms)
+{
+	int err = -1;
+	u8 config[2];
+	int i;
+
+	for (i = ARRAY_SIZE(lsm303d_mag_odr_table) - 1; i >= 0; i--) {
+		if ((lsm303d_mag_odr_table[i].cutoff_us <= poll_interval_ms)
+								|| (i == 0))
+			break;
+	}
+
+	config[1] = ((ODR_MAG_MASK & lsm303d_mag_odr_table[i].value) | 
+		((~ODR_MAG_MASK) & status_registers.cntrl5.resume_value));
+
+	if (atomic_read(&stat->enabled_mag)) {
+		config[0] = status_registers.cntrl5.address;
+		err = lsm303d_i2c_write(stat, config, 1);
+		if (err < 0)
+			goto error;
+		status_registers.cntrl5.resume_value = config[1];
+		stat->ktime_mag = ktime_set(0, MS_TO_NS(poll_interval_ms));
+	}
+
+	return err;
+
+error:
+	dev_err(&stat->client->dev, "update magnetometer odr failed "
+			"0x%02x,0x%02x: %d\n", config[0], config[1], err);
+
+	return err;
+}
+
+static void lsm303d_validate_polling(unsigned int *min_interval,
+					unsigned int *poll_interval, 
+					unsigned int min,
+					struct i2c_client *client)
+{
+	*min_interval = max(min, *min_interval);
+	*poll_interval = max(*poll_interval, *min_interval);
+}
+
+static int lsm303d_acc_validate_pdata(struct lsm303d_status *stat)
+{
+	int res = -EINVAL;
+
+	lsm303d_validate_polling(&stat->pdata_acc->min_interval,
+				&stat->pdata_acc->poll_interval,
+				(unsigned int)LSM303D_ACC_MIN_POLL_PERIOD_MS,
+				stat->client);
+
+	switch (stat->pdata_acc->aa_filter_bandwidth) {
+		case ANTI_ALIASING_50:
+			res = 1;
+			break;
+		case ANTI_ALIASING_194:
+			res = 1;
+			break;
+		case ANTI_ALIASING_362:
+			res = 1;
+			break;
+		case ANTI_ALIASING_773:
+			res = 1;
+			break;
+		default:
+			dev_err(&stat->client->dev, "invalid accelerometer "
+				"bandwidth selected: %u\n", 
+					stat->pdata_acc->aa_filter_bandwidth);
+	}
+
+	return res;
+}
+
+static int lsm303d_mag_validate_pdata(struct lsm303d_status *stat)
+{
+	lsm303d_validate_polling(&stat->pdata_mag->min_interval,
+				&stat->pdata_mag->poll_interval,
+				(unsigned int)LSM303D_MAG_MIN_POLL_PERIOD_MS,
+				stat->client);
+
+	return 0;
+}
+
+static int lsm303d_acc_enable(struct lsm303d_status *stat)
+{
+	int err;
+
+	if (!atomic_cmpxchg(&stat->enabled_acc, 0, 1)) {
+		err = lsm303d_acc_device_power_on(stat);
+		if (err < 0) {
+			atomic_set(&stat->enabled_acc, 0);
+			return err;
+		}
+		hrtimer_start(&stat->hr_timer_acc, stat->ktime_acc, HRTIMER_MODE_REL);
+		if(!atomic_read(&stat->enabled_mag)) {
+			if(stat->pdata_acc->gpio_int1 >= 0)
+				enable_irq(stat->irq1);
+			if(stat->pdata_acc->gpio_int2 >= 0)
+				enable_irq(stat->irq2);
+		}
+	}
+
+	return 0;
+}
+
+static int lsm303d_acc_disable(struct lsm303d_status *stat)
+{
+	if (atomic_cmpxchg(&stat->enabled_acc, 1, 0)) {
+		cancel_work_sync(&stat->input_work_acc);
+		hrtimer_cancel(&stat->hr_timer_acc);
+		lsm303d_acc_device_power_off(stat);
+
+		if(!atomic_read(&stat->enabled_mag)) {
+			if(stat->pdata_acc->gpio_int1 >= 0)
+				disable_irq_nosync(stat->irq1);
+			if(stat->pdata_acc->gpio_int2 >= 0)
+				disable_irq_nosync(stat->irq2);
+		}
+	}
+
+	return 0;
+}
+
+static int lsm303d_mag_enable(struct lsm303d_status *stat)
+{
+	int err;
+
+	if (!atomic_cmpxchg(&stat->enabled_mag, 0, 1)) {
+		err = lsm303d_mag_device_power_on(stat);
+		if (err < 0) {
+			atomic_set(&stat->enabled_mag, 0);
+			return err;
+		}
+		if(!atomic_read(&stat->enabled_temp)) {
+			hrtimer_start(&stat->hr_timer_mag, stat->ktime_mag, HRTIMER_MODE_REL);
+		}
+		if(!atomic_read(&stat->enabled_acc)) {
+			if(stat->pdata_acc->gpio_int1 >= 0)
+				enable_irq(stat->irq1);
+			if(stat->pdata_acc->gpio_int2 >= 0)
+				enable_irq(stat->irq2);
+		}
+	}
+
+	return 0;
+}
+
+static int lsm303d_mag_disable(struct lsm303d_status *stat)
+{
+	if (atomic_cmpxchg(&stat->enabled_mag, 1, 0)) {
+		if(!atomic_read(&stat->enabled_temp)) {
+			cancel_work_sync(&stat->input_work_mag);
+			hrtimer_cancel(&stat->hr_timer_mag);
+		}
+		lsm303d_mag_device_power_off(stat);
+		if(!atomic_read(&stat->enabled_acc)) {
+			if(stat->pdata_acc->gpio_int1 >= 0)
+				disable_irq(stat->irq1);
+			if(stat->pdata_acc->gpio_int2 >= 0)
+				disable_irq(stat->irq2);
+		}
+	}
+
+	return 0;
+}
+
+static int lsm303d_temperature_enable(struct lsm303d_status *stat)
+{
+	int err;
+	u8 buf[2];
+	u8 updated_val;
+
+	buf[0] = status_registers.cntrl5.address;
+	err = lsm303d_i2c_read(stat, buf, 1);
+	if (err < 0)
+		goto error;
+
+	status_registers.cntrl5.resume_value = buf[0];	
+	updated_val = ((TEMP_MASK & TEMP_ON) | 
+					((~TEMP_MASK) & buf[0]));
+	buf[1] = updated_val;
+	buf[0] = status_registers.cntrl5.address;
+
+	err = lsm303d_i2c_write(stat, buf, 1);
+	if (err < 0)
+		goto error;
+	status_registers.cntrl5.resume_value = updated_val;
+
+	if(!atomic_read(&stat->enabled_mag)) {
+		hrtimer_start(&stat->hr_timer_mag, stat->ktime_mag, HRTIMER_MODE_REL);
+	}
+	atomic_set(&stat->enabled_temp, 1);
+	return 0;
+
+error:
+	return -1;
+}
+
+static int lsm303d_temperature_disable(struct lsm303d_status *stat)
+{
+	int err;
+	u8 buf[2];
+	u8 updated_val;
+
+	buf[0] = status_registers.cntrl5.address;
+	err = lsm303d_i2c_read(stat, buf, 1);
+	if (err < 0)
+		goto error;
+
+	status_registers.cntrl5.resume_value = buf[0];	
+	updated_val = ((TEMP_MASK & TEMP_OFF) | 
+					((~TEMP_MASK) & buf[0]));
+	buf[1] = updated_val;
+	buf[0] = status_registers.cntrl5.address;
+
+	err = lsm303d_i2c_write(stat, buf, 1);
+	if (err < 0)
+		goto error;
+	status_registers.cntrl5.resume_value = updated_val;
+
+	if(!atomic_read(&stat->enabled_mag)) {
+		cancel_work_sync(&stat->input_work_mag);
+		hrtimer_cancel(&stat->hr_timer_mag);
+	}
+	atomic_set(&stat->enabled_temp, 0);
+	stat->temp_value_dec = NDTEMP;
+	return 0;
+
+error:
+	return -1;
+}
+
+static void lsm303d_acc_input_cleanup(struct lsm303d_status *stat)
+{
+	input_unregister_device(stat->input_dev_acc);
+	input_free_device(stat->input_dev_acc);
+}
+
+static void lsm303d_mag_input_cleanup(struct lsm303d_status *stat)
+{
+	input_unregister_device(stat->input_dev_mag);
+	input_free_device(stat->input_dev_mag);
+}
+
+static ssize_t attr_get_polling_rate_acc(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	unsigned int val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+	mutex_lock(&stat->lock);
+	val = stat->pdata_acc->poll_interval;
+	mutex_unlock(&stat->lock);
+	return sprintf(buf, "%u\n", val);
+}
+
+static ssize_t attr_get_polling_rate_mag(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	unsigned int val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+	mutex_lock(&stat->lock);
+	val = stat->pdata_mag->poll_interval;
+	mutex_unlock(&stat->lock);
+	return sprintf(buf, "%u\n", val);
+}
+
+static ssize_t attr_set_polling_rate_acc(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (kstrtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+	interval_ms = (unsigned int)max((unsigned int)interval_ms,
+						stat->pdata_acc->min_interval);
+	mutex_lock(&stat->lock);
+	stat->pdata_acc->poll_interval = (unsigned int)interval_ms;
+	lsm303d_acc_update_odr(stat, interval_ms);
+	mutex_unlock(&stat->lock);
+	return size;
+}
+
+static ssize_t attr_set_polling_rate_mag(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (kstrtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+	interval_ms = (unsigned int)max((unsigned int)interval_ms,
+						stat->pdata_mag->min_interval);
+	mutex_lock(&stat->lock);
+	stat->pdata_mag->poll_interval = (unsigned int)interval_ms;
+	lsm303d_mag_update_odr(stat, interval_ms);
+	mutex_unlock(&stat->lock);
+	return size;
+}
+
+static ssize_t attr_get_enable_acc(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+	int val = (int)atomic_read(&stat->enabled_acc);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_get_enable_mag(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+	int val = (int)atomic_read(&stat->enabled_mag);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable_acc(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lsm303d_acc_enable(stat);
+	else
+		lsm303d_acc_disable(stat);
+
+	return size;
+}
+
+static ssize_t attr_set_enable_mag(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lsm303d_mag_enable(stat);
+	else
+		lsm303d_mag_disable(stat);
+
+	return size;
+}
+
+static ssize_t attr_get_range_acc(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	struct device *dev = to_dev(kobj->parent);
+	u8 val;
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+	int range = 2;
+	mutex_lock(&stat->lock);
+	val = stat->pdata_acc->fs_range ;
+	switch (val) {
+	case LSM303D_ACC_FS_2G:
+		range = 2;
+		break;
+	case LSM303D_ACC_FS_4G:
+		range = 4;
+		break;
+	case LSM303D_ACC_FS_8G:
+		range = 8;
+		break;
+	case LSM303D_ACC_FS_16G:
+		range = 16;
+		break;
+	}
+	mutex_unlock(&stat->lock);
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_get_range_mag(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	struct device *dev = to_dev(kobj->parent);
+	u8 val;
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+	int range = 2;
+	mutex_lock(&stat->lock);
+	val = stat->pdata_mag->fs_range ;
+	switch (val) {
+	case LSM303D_MAG_FS_2G:
+		range = 2;
+		break;
+	case LSM303D_MAG_FS_4G:
+		range = 4;
+		break;
+	case LSM303D_MAG_FS_8G:
+		range = 8;
+		break;
+	case LSM303D_MAG_FS_12G:
+		range = 12;
+		break;
+	}
+	mutex_unlock(&stat->lock);
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range_acc(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+	u8 range;
+	int err;
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+	switch (val) {
+	case 2:
+		range = LSM303D_ACC_FS_2G;
+		break;
+	case 4:
+		range = LSM303D_ACC_FS_4G;
+		break;
+	case 8:
+		range = LSM303D_ACC_FS_8G;
+		break;
+	case 16:
+		range = LSM303D_ACC_FS_16G;
+		break;
+	default:
+		dev_err(&stat->client->dev, "accelerometer invalid range "
+					"request: %lu, discarded\n", val);
+		return -EINVAL;
+	}
+	mutex_lock(&stat->lock);
+	err = lsm303d_acc_update_fs_range(stat, range);
+	if (err < 0) {
+		mutex_unlock(&stat->lock);
+		return err;
+	}
+	stat->pdata_acc->fs_range = range;
+	mutex_unlock(&stat->lock);
+	dev_info(&stat->client->dev, "accelerometer range set to:"
+							" %lu g\n", val);
+
+	return size;
+}
+
+static ssize_t attr_set_range_mag(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+	u8 range;
+	int err;
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+	switch (val) {
+	case 2:
+		range = LSM303D_MAG_FS_2G;
+		break;
+	case 4:
+		range = LSM303D_MAG_FS_4G;
+		break;
+	case 8:
+		range = LSM303D_MAG_FS_8G;
+		break;
+	case 12:
+		range = LSM303D_MAG_FS_12G;
+		break;
+	default:
+		dev_err(&stat->client->dev, "magnetometer invalid range "
+					"request: %lu, discarded\n", val);
+		return -EINVAL;
+	}
+	mutex_lock(&stat->lock);
+	err = lsm303d_mag_update_fs_range(stat, range);
+	if (err < 0) {
+		mutex_unlock(&stat->lock);
+		return err;
+	}
+	stat->pdata_mag->fs_range = range;
+	mutex_unlock(&stat->lock);
+	dev_info(&stat->client->dev, "magnetometer range set to:"
+							" %lu g\n", val);
+
+	return size;
+}
+
+static ssize_t attr_get_aa_filter(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	struct device *dev = to_dev(kobj->parent);
+	u8 val;
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+	int frequency=FILTER_773;
+	mutex_lock(&stat->lock);
+	val = stat->pdata_acc->aa_filter_bandwidth;
+	switch (val) {
+	case ANTI_ALIASING_50:
+		frequency = FILTER_50;
+		break;
+	case ANTI_ALIASING_194:
+		frequency = FILTER_194;
+		break;
+	case ANTI_ALIASING_362:
+		frequency = FILTER_362;
+		break;
+	case ANTI_ALIASING_773:
+		frequency = FILTER_773;
+		break;
+	}
+	mutex_unlock(&stat->lock);
+	return sprintf(buf, "%d\n", frequency);
+}
+
+static ssize_t attr_set_aa_filter(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+	u8 frequency;
+	int err;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+	switch (val) {
+	case FILTER_50:
+		frequency = ANTI_ALIASING_50;
+		break;
+	case FILTER_194:
+		frequency = ANTI_ALIASING_194;
+		break;
+	case FILTER_362:
+		frequency = ANTI_ALIASING_362;
+		break;
+	case FILTER_773:
+		frequency = ANTI_ALIASING_773;
+		break;
+	default:
+		dev_err(&stat->client->dev, "accelerometer invalid filter "
+					"request: %lu, discarded\n", val);
+		return -EINVAL;
+	}
+	mutex_lock(&stat->lock);
+	err = lsm303d_acc_update_filter(stat, frequency);
+	if (err < 0) {
+		mutex_unlock(&stat->lock);
+		return err;
+	}
+	stat->pdata_acc->aa_filter_bandwidth = frequency;
+	mutex_unlock(&stat->lock);
+	dev_info(&stat->client->dev, "accelerometer anti-aliasing filter "
+					"set to: %lu Hz\n", val);
+
+	return size;
+}
+
+static ssize_t attr_get_temp_enable(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	int val = (int)atomic_read(&stat->enabled_temp);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_temp_enable(struct device *dev, 
+					struct device_attribute *attr,
+					const char *buf, size_t size)
+{
+	unsigned long val;
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	atomic_set(&stat->enabled_temp, (int)val);
+
+	if(val>0) {
+		lsm303d_temperature_enable(stat);
+	} else {
+		lsm303d_temperature_disable(stat);
+	}
+
+	return size;
+}
+
+static ssize_t attr_get_temp(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	int dec;
+	unsigned int flo;
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	dec = stat->temp_value_dec;
+	flo = stat->temp_value_flo;
+
+	if(dec==NDTEMP)
+		return sprintf(buf, "n.d.\n");
+	
+	return sprintf(buf, "%d.%u\n", dec, flo);
+}
+
+static struct kobj_attribute poll_attr_acc =
+__ATTR(pollrate_ms, 0664, attr_get_polling_rate_acc, attr_set_polling_rate_acc);
+static struct kobj_attribute enable_attr_acc =
+__ATTR(enable_device, 0664, attr_get_enable_acc, attr_set_enable_acc);
+static struct kobj_attribute fs_attr_acc = 
+__ATTR(full_scale, 0664, attr_get_range_acc, attr_set_range_acc);
+static struct kobj_attribute aa_filter_attr  =
+__ATTR(anti_aliasing_frequency, 0664, attr_get_aa_filter, attr_set_aa_filter);
+static struct kobj_attribute poll_attr_mag =
+__ATTR(pollrate_ms, 0664, attr_get_polling_rate_mag, attr_set_polling_rate_mag);
+static struct kobj_attribute enable_attr_mag =
+__ATTR(enable_device, 0664, attr_get_enable_mag, attr_set_enable_mag);
+static struct kobj_attribute fs_attr_mag =
+__ATTR(full_scale, 0664, attr_get_range_mag, attr_set_range_mag);
+
+static int write_bit_on_register(struct lsm303d_status *stat, u8 address, 
+					u8 *resume_value, u8 mask, int value)
+{
+	int err;
+	u8 updated_val;
+	u8 buf[2];
+	u8 val = 0x00;
+
+	buf[0] = address;
+	err = lsm303d_i2c_read(stat, buf, 1);
+	if (err < 0)
+		return -1;
+
+	if(resume_value != NULL)
+		*resume_value = buf[0];	
+
+	if(mask == 0)
+		updated_val = (u8)value;
+	else {
+		if(value>0)
+			val = 0xFF;
+		updated_val = (mask & val) | ((~mask) & buf[0]);
+	}
+
+	buf[1] = updated_val;
+	buf[0] = address;
+
+	err = lsm303d_i2c_write(stat, buf, 1);
+	if (err < 0)
+		return -1;
+
+	if(resume_value != NULL)
+		*resume_value = updated_val;
+
+	return err;
+}
+
+static int write_gen_int(struct lsm303d_status *stat, 
+					struct interrupt_enable *ie, int val) 
+{
+	int err;
+
+	if(val>0)
+		val = 1;
+	else
+		val = 0;
+
+	err = write_bit_on_register(stat, ie->address, NULL, ie->mask, val);
+	if(err < 0)
+		return -1;
+
+	atomic_set(&ie->enable, val);
+	return err;
+}
+
+static int write_duration_threshold_int(struct lsm303d_status *stat, 
+					struct interrupt_value *ie, int val) 
+{
+	int err;
+
+	if(val<0)
+		return -1;
+
+	if(val>MAX_DUR_TH)
+		return -1;
+
+	err = write_bit_on_register(stat, ie->address, NULL, 0, val);
+	if(err<0)
+		return -1;
+
+	ie->value = val;
+
+	return err;
+}
+
+static int write_threshold_mag_int(struct lsm303d_status *stat, 
+					struct interrupt_value *ie, int val) 
+{
+	int err;
+	u8 high;
+	u8 low;
+
+	if(val<0)
+		return -1;
+
+	if(val>MAX_TH_MAG)
+		return -1;
+
+	low = (u8)(0xff & val);
+
+	err = write_bit_on_register(stat, ie->address, NULL, 0, low);
+	if(err<0)
+		return -1;
+
+	high = (u8)(0xff & (val >> 8));
+
+	err = write_bit_on_register(stat, (ie->address)+1, NULL, 0, high);
+	if(err<0)
+		return -1;
+
+	ie->value = val;
+
+	return err;
+}
+
+static ssize_t attr_get_gen1_status(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val = -1;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	if(strcmp(attr->attr.name, "pin1_enable") == 0) {
+		val = atomic_read(&stat->interrupt->gen1_pin1.enable);
+	}
+	if(strcmp(attr->attr.name, "pin2_enable") == 0) {
+		val = atomic_read(&stat->interrupt->gen1_pin2.enable);
+	}
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen1_status(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err = -1;
+	unsigned long val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if(strcmp(attr->attr.name, "pin1_enable") == 0) {
+		err = write_gen_int(stat, 
+					&stat->interrupt->gen1_pin1, (int)val);
+	}
+	if(strcmp(attr->attr.name, "pin2_enable") == 0) {
+		err = write_gen_int(stat, 
+					&stat->interrupt->gen1_pin2, (int)val);
+	}
+	return size;
+}
+
+static ssize_t attr_get_gen2_status(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val = -1;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	if(strcmp(attr->attr.name, "pin1_enable") == 0) {
+		val = atomic_read(&stat->interrupt->gen2_pin1.enable);
+	}
+	if(strcmp(attr->attr.name, "pin2_enable") == 0) {
+		val = atomic_read(&stat->interrupt->gen2_pin2.enable);
+	}
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen2_status(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err = -1;
+	unsigned long val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if(strcmp(attr->attr.name, "pin1_enable") == 0) {
+		err = write_gen_int(stat, 
+					&stat->interrupt->gen2_pin1, (int)val);
+	}
+	if(strcmp(attr->attr.name, "pin2_enable") == 0) {
+		err = write_gen_int(stat, 
+					&stat->interrupt->gen2_pin2, (int)val);
+	}
+	return size;
+}
+
+static ssize_t attr_get_gen1_duration(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	val = stat->interrupt->gen1_duration.value;
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen1_duration(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err = -1;
+	unsigned long val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_duration_threshold_int(stat, 
+				&stat->interrupt->gen1_duration, (int)val);
+	
+	return size;
+}
+
+static ssize_t attr_get_gen2_duration(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	val = stat->interrupt->gen2_duration.value;
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen2_duration(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err = -1;
+	unsigned long val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_duration_threshold_int(stat, 
+				&stat->interrupt->gen2_duration, (int)val);
+	
+	return size;
+}
+
+static ssize_t attr_get_gen1_threshold(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	val = stat->interrupt->gen1_threshold.value;
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen1_threshold(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err = -1;
+	unsigned long val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_duration_threshold_int(stat, 
+				&stat->interrupt->gen1_threshold, (int)val);
+	
+	return size;
+}
+
+static ssize_t attr_get_gen2_threshold(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	val = stat->interrupt->gen2_threshold.value;
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen2_threshold(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err = -1;
+	unsigned long val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_duration_threshold_int(stat, 
+				&stat->interrupt->gen2_threshold, (int)val);
+	
+	return size;
+}
+
+static ssize_t attr_get_gen_mag_status(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val = -1;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	if(strcmp(attr->attr.name, "pin1_enable") == 0) {
+		val = atomic_read(&stat->interrupt->gen_mag_pin1.enable);
+	}
+	if(strcmp(attr->attr.name, "pin2_enable") == 0) {
+		val = atomic_read(&stat->interrupt->gen_mag_pin2.enable);
+	}
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen_mag_status(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err = -1;
+	unsigned long val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if(strcmp(attr->attr.name, "pin1_enable") == 0) {
+		err = write_gen_int(stat, 
+				&stat->interrupt->gen_mag_pin1, (int)val);
+		if(err >= 0) {
+		if((atomic_read(&stat->interrupt->gen_mag_pin2.enable))==0)
+			write_gen_int(stat, 
+					&stat->interrupt->gen_mag, (int)val);
+		}
+	}
+	if(strcmp(attr->attr.name, "pin2_enable") == 0) {
+		err = write_gen_int(stat, 
+				&stat->interrupt->gen_mag_pin2, (int)val);
+		if(err >= 0) {
+		if((atomic_read(&stat->interrupt->gen_mag_pin1.enable))==0)
+			write_gen_int(stat, 
+					&stat->interrupt->gen_mag, (int)val);
+		}
+	}
+	return size;
+}
+
+static ssize_t attr_get_gen_mag_threshold(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	val = stat->interrupt->gen_mag_threshold.value;
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen_mag_threshold(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err = -1;
+	unsigned long val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_threshold_mag_int(stat, 
+				&stat->interrupt->gen_mag_threshold, (int)val);
+	
+	return size;
+}
+
+static int get_axis(struct lsm303d_status *stat, 
+					int generator, const char *name) {
+
+	int val;
+	int axis;
+
+	if(strcmp(name, "x_high_enable") == 0) {
+		axis = 3;
+	}
+	if(strcmp(name, "x_low_enable") == 0) {
+		axis = 0;
+	}
+	if(strcmp(name, "y_high_enable") == 0) {
+		axis = 4;
+	}
+	if(strcmp(name, "y_low_enable") == 0) {
+		axis = 1;
+	}
+	if(strcmp(name, "z_high_enable") == 0) {
+		axis = 5;
+	}
+	if(strcmp(name, "z_low_enable") == 0) {
+		axis = 2;
+	}
+
+	if(generator == 1)
+		val = atomic_read(&stat->interrupt->gen1_axis[axis].enable);
+	else
+		val = atomic_read(&stat->interrupt->gen2_axis[axis].enable);
+
+	return val;
+}
+
+static int set_axis(struct lsm303d_status *stat, int generator, 
+					const char *name, unsigned long value) 
+{
+	int err = -1;
+	int axis;
+
+	if(strcmp(name, "x_high_enable") == 0) {
+		axis = 3;
+	}
+	if((strcmp(name, "x_low_enable") == 0) || 
+					(strcmp(name, "x_enable") == 0)) {
+		axis = 0;
+	}
+	if(strcmp(name, "y_high_enable") == 0) {
+		axis = 4;
+	}
+	if((strcmp(name, "y_low_enable") == 0) || 
+					(strcmp(name, "y_enable") == 0)) {
+		axis = 1;
+	}
+	if(strcmp(name, "z_high_enable") == 0) {
+		axis = 5;
+	}
+	if((strcmp(name, "z_low_enable") == 0) || 
+					(strcmp(name, "z_enable") == 0)) {
+		axis = 2;
+	}
+
+	if(generator == 1)
+		err = write_gen_int(stat, 
+			&(stat->interrupt->gen1_axis[axis]), (int)value);
+	if(generator == 2)
+		err = write_gen_int(stat, 
+			&(stat->interrupt->gen2_axis[axis]), (int)value);
+	if(generator == 3)
+		err = write_gen_int(stat, 
+			&(stat->interrupt->gen_mag_axis[axis]), (int)value);
+
+	if(err < 0)
+		return -1;
+
+	return err;
+}
+
+static ssize_t attr_get_gen1_axis(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	val = get_axis(stat,1,attr->attr.name);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen1_axis(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	unsigned long val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = set_axis(stat, 1, attr->attr.name, val);
+	if(err < 0)
+		return -1;
+
+	return size;
+}
+
+static ssize_t attr_get_gen2_axis(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	val = get_axis(stat,2,attr->attr.name);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen2_axis(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	unsigned long val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = set_axis(stat, 2, attr->attr.name, val);
+	if(err < 0)
+		return -1;
+
+	return size;
+}
+
+static ssize_t attr_get_gen_mag_axis(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	val = get_axis(stat, 3, attr->attr.name);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen_mag_axis(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	unsigned long val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = set_axis(stat, 3, attr->attr.name, val);
+	if(err < 0)
+		return -1;
+
+	return size;
+}
+
+static ssize_t attr_get_gen1_and_or(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	val = atomic_read(&stat->interrupt->gen1_and_or.enable);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen1_and_or(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	unsigned long val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_gen_int(stat, &(stat->interrupt->gen1_and_or), (int)val);
+	if(err < 0)
+		return -1;
+
+	return size;
+}
+
+static ssize_t attr_get_gen2_and_or(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	val = atomic_read(&stat->interrupt->gen2_and_or.enable);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen2_and_or(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	unsigned long val;
+	struct device *dev = to_dev(kobj->parent);
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_gen_int(stat, &(stat->interrupt->gen2_and_or), (int)val);
+	if(err < 0)
+		return -1;
+
+	return size;
+}
+
+static ssize_t attr_set_pin_conf(struct device *dev, 
+						struct device_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	unsigned long val;
+
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_gen_int(stat, 
+			&(stat->interrupt->interrupt_pin_conf), (int)val);
+	if(err < 0)
+		return -1;
+
+	return size;
+}
+
+static ssize_t attr_get_pin_conf(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	int val;
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	val = atomic_read(&stat->interrupt->interrupt_pin_conf.enable);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_interrupt_polarity(struct device *dev, 
+						struct device_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	unsigned long val;
+
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_gen_int(stat, 
+			&(stat->interrupt->interrupt_polarity), (int)val);
+	if(err < 0)
+		return -1;
+
+	return size;
+}
+
+static ssize_t attr_get_interrupt_polarity(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	int val;
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	val = atomic_read(&stat->interrupt->interrupt_polarity.enable);
+	return sprintf(buf, "%d\n", val);
+}
+
+static struct kobj_attribute gen1_interrupt_pin1_enable =
+__ATTR(pin1_enable, 0664, attr_get_gen1_status, attr_set_gen1_status);
+static struct kobj_attribute gen1_interrupt_pin2_enable =
+__ATTR(pin2_enable, 0664, attr_get_gen1_status, attr_set_gen1_status);
+
+static struct kobj_attribute gen2_interrupt_pin1_enable =
+__ATTR(pin1_enable, 0664, attr_get_gen2_status, attr_set_gen2_status);
+static struct kobj_attribute gen2_interrupt_pin2_enable =
+__ATTR(pin2_enable, 0664, attr_get_gen2_status, attr_set_gen2_status);
+
+static struct kobj_attribute gen1_duration =
+__ATTR(duration, 0664, attr_get_gen1_duration, attr_set_gen1_duration);
+static struct kobj_attribute gen2_duration =
+__ATTR(duration, 0664, attr_get_gen2_duration, attr_set_gen2_duration);
+
+static struct kobj_attribute gen1_threshold =
+__ATTR(threshold, 0664, attr_get_gen1_threshold, attr_set_gen1_threshold);
+static struct kobj_attribute gen2_threshold =
+__ATTR(threshold, 0664, attr_get_gen2_threshold, attr_set_gen2_threshold);
+
+static struct kobj_attribute mag_gen_interrupt_pin1 =
+__ATTR(pin1_enable, 0664, attr_get_gen_mag_status, attr_set_gen_mag_status);
+static struct kobj_attribute mag_gen_interrupt_pin2 =
+__ATTR(pin2_enable, 0664, attr_get_gen_mag_status, attr_set_gen_mag_status);
+
+static struct kobj_attribute mag_gen_threshold =
+__ATTR(threshold, 0664, attr_get_gen_mag_threshold, attr_set_gen_mag_threshold);
+
+static struct kobj_attribute gen1_x_high =
+__ATTR(x_high_enable, 0664, attr_get_gen1_axis, attr_set_gen1_axis);
+static struct kobj_attribute gen1_x_low =
+__ATTR(x_low_enable, 0664, attr_get_gen1_axis, attr_set_gen1_axis);
+
+static struct kobj_attribute gen2_x_high =
+__ATTR(x_high_enable, 0664, attr_get_gen2_axis, attr_set_gen2_axis);
+static struct kobj_attribute gen2_x_low =
+__ATTR(x_low_enable, 0664, attr_get_gen2_axis, attr_set_gen2_axis);
+
+static struct kobj_attribute gen1_y_high =
+__ATTR(y_high_enable, 0664, attr_get_gen1_axis, attr_set_gen1_axis);
+static struct kobj_attribute gen1_y_low =
+__ATTR(y_low_enable, 0664, attr_get_gen1_axis, attr_set_gen1_axis);
+
+static struct kobj_attribute gen2_y_high =
+__ATTR(y_high_enable, 0664, attr_get_gen2_axis, attr_set_gen2_axis);
+static struct kobj_attribute gen2_y_low =
+__ATTR(y_low_enable, 0664, attr_get_gen2_axis, attr_set_gen2_axis);
+
+static struct kobj_attribute gen1_z_high =
+__ATTR(z_high_enable, 0664, attr_get_gen1_axis, attr_set_gen1_axis);
+static struct kobj_attribute gen1_z_low =
+__ATTR(z_low_enable, 0664, attr_get_gen1_axis, attr_set_gen1_axis);
+
+static struct kobj_attribute gen2_z_high =
+__ATTR(z_high_enable, 0664, attr_get_gen2_axis, attr_set_gen2_axis);
+static struct kobj_attribute gen2_z_low =
+__ATTR(z_low_enable, 0664, attr_get_gen2_axis, attr_set_gen2_axis);
+
+static struct kobj_attribute gen_mag_x =
+__ATTR(x_enable, 0664, attr_get_gen_mag_axis, attr_set_gen_mag_axis);
+static struct kobj_attribute gen_mag_y =
+__ATTR(y_enable, 0664, attr_get_gen_mag_axis, attr_set_gen_mag_axis);
+static struct kobj_attribute gen_mag_z =
+__ATTR(z_enable, 0664, attr_get_gen_mag_axis, attr_set_gen_mag_axis);
+
+static struct kobj_attribute gen1_and_or =
+__ATTR(and(1)_or(0)_combination, 0664, attr_get_gen1_and_or, 
+							attr_set_gen1_and_or);
+static struct kobj_attribute gen2_and_or =
+__ATTR(and(1)_or(0)_combination, 0664, attr_get_gen2_and_or, 
+							attr_set_gen2_and_or);
+
+
+static struct attribute *attributes_acc_interrupt1[] = {
+	&gen1_interrupt_pin1_enable.attr,
+	&gen1_interrupt_pin2_enable.attr,
+	&gen1_duration.attr,
+	&gen1_threshold.attr,
+	&gen1_x_high.attr,
+	&gen1_x_low.attr,
+	&gen1_y_high.attr,
+	&gen1_y_low.attr,
+	&gen1_z_high.attr,
+	&gen1_z_low.attr,
+	&gen1_and_or.attr,
+	NULL,
+};
+
+static struct attribute *attributes_acc_interrupt2[] = {
+	&gen2_interrupt_pin1_enable.attr,
+	&gen2_interrupt_pin2_enable.attr,
+	&gen2_duration.attr,
+	&gen2_threshold.attr,
+	&gen2_x_high.attr,
+	&gen2_x_low.attr,
+	&gen2_y_high.attr,
+	&gen2_y_low.attr,
+	&gen2_z_high.attr,
+	&gen2_z_low.attr,
+	&gen2_and_or.attr,
+	NULL,
+};
+
+static struct attribute *attributes_mag_interrupt[] = {
+	&mag_gen_interrupt_pin1.attr,
+	&mag_gen_interrupt_pin2.attr,
+	&mag_gen_threshold.attr,
+	&gen_mag_x.attr,
+	&gen_mag_y.attr,
+	&gen_mag_z.attr,
+	NULL,
+};
+
+static struct attribute *attributes_acc[] = {
+	&poll_attr_acc.attr,
+	&enable_attr_acc.attr,
+	&fs_attr_acc.attr,
+	&aa_filter_attr.attr,
+	NULL,
+};
+
+static struct attribute *attributes_mag[] = {
+	&poll_attr_mag.attr,
+	&enable_attr_mag.attr,
+	&fs_attr_mag.attr,
+	NULL,
+};
+
+static struct attribute_group attr_group_acc = {
+	.attrs = attributes_acc,
+};
+
+static struct attribute_group attr_group_mag = {
+	.attrs = attributes_mag,
+};
+
+static struct attribute_group attr_group_int1_acc = {
+	.attrs = attributes_acc_interrupt1,
+	.name = "interrupt_generator1",
+};
+
+static struct attribute_group attr_group_int2_acc = {
+	.attrs = attributes_acc_interrupt2,
+	.name = "interrupt_generator2",
+};
+
+static struct attribute_group attr_group_int_mag = {
+	.attrs = attributes_mag_interrupt,
+	.name = "interrupt_generator",
+};
+
+static struct device_attribute attributes_com[] = {
+	__ATTR(enable_temperature, 0664, attr_get_temp_enable, 
+							attr_set_temp_enable),
+	__ATTR(read_temperature, 0444, attr_get_temp, NULL),
+};
+
+static struct device_attribute attributes_interrupt_com[] = {
+	__ATTR(interrupt_pin_configuration, 0664, attr_get_pin_conf, 
+						attr_set_pin_conf),
+	__ATTR(interrupt_polarity, 0664, attr_get_interrupt_polarity, 
+						attr_set_interrupt_polarity),
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int err;
+	int i,n;
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+
+	acc_kobj = kobject_create_and_add("accelerometer", &dev->kobj);
+	if(!acc_kobj)
+		return -ENOMEM;
+
+	mag_kobj = kobject_create_and_add("magnetometer", &dev->kobj);
+	if(!mag_kobj)
+		return -ENOMEM;
+
+	err = sysfs_create_group(acc_kobj, &attr_group_acc);
+	if (err)
+		kobject_put(acc_kobj);
+
+	err = sysfs_create_group(mag_kobj, &attr_group_mag);
+	if (err)
+		kobject_put(mag_kobj);
+
+	if((stat->pdata_acc->gpio_int1 >= 0)||
+					(stat->pdata_acc->gpio_int2 >= 0)) {
+		err = sysfs_create_group(acc_kobj, &attr_group_int1_acc);
+		if (err)
+			kobject_put(acc_kobj);
+
+		err = sysfs_create_group(acc_kobj, &attr_group_int2_acc);
+		if (err)
+			kobject_put(acc_kobj);
+
+		err = sysfs_create_group(mag_kobj, &attr_group_int_mag);
+		if (err)
+			kobject_put(mag_kobj);
+
+		for (n = 0; n < ARRAY_SIZE(attributes_interrupt_com); n++)
+		if (device_create_file(dev, attributes_interrupt_com + n))
+			goto error1;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(attributes_com); i++)
+		if (device_create_file(dev, attributes_com + i))
+			goto error;
+
+	
+
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attributes_com + i);
+
+error1:
+	for ( ; n >= 0; n--)
+		device_remove_file(dev, attributes_interrupt_com + n);
+
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static void remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	struct lsm303d_status *stat = dev_get_drvdata(dev);
+	kobject_put(acc_kobj);
+	kobject_put(mag_kobj);
+	for (i = 0; i < ARRAY_SIZE(attributes_com); i++)
+		device_remove_file(dev, attributes_com + i);
+	if((stat->pdata_acc->gpio_int1 >= 0)||
+					(stat->pdata_acc->gpio_int2 >= 0)) {
+		for (i = 0; i < ARRAY_SIZE(attributes_interrupt_com); i++)
+			device_remove_file(dev, attributes_interrupt_com + i);
+	}
+}
+
+int lsm303d_acc_input_open(struct input_dev *input)
+{
+	struct lsm303d_status *stat = input_get_drvdata(input);
+
+	return lsm303d_acc_enable(stat);
+}
+
+void lsm303d_acc_input_close(struct input_dev *dev)
+{
+	struct lsm303d_status *stat = input_get_drvdata(dev);
+
+	lsm303d_acc_disable(stat);
+}
+
+int lsm303d_mag_input_open(struct input_dev *input)
+{
+	struct lsm303d_status *stat = input_get_drvdata(input);
+
+	return lsm303d_mag_enable(stat);
+}
+
+void lsm303d_mag_input_close(struct input_dev *dev)
+{
+	struct lsm303d_status *stat = input_get_drvdata(dev);
+
+	lsm303d_mag_disable(stat);
+}
+
+static int lsm303d_acc_get_data(struct lsm303d_status *stat, int *xyz)
+{
+	int i, err = -1;
+	u8 acc_data[6];
+	s32 hw_d[3] = { 0 };
+
+	acc_data[0] = (REG_ACC_DATA_ADDR);
+	err = lsm303d_i2c_read(stat, acc_data, 6);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = ((s32)( (s16)((acc_data[1] << 8) | (acc_data[0]))));
+	hw_d[1] = ((s32)( (s16)((acc_data[3] << 8) | (acc_data[2]))));
+	hw_d[2] = ((s32)( (s16)((acc_data[5] << 8) | (acc_data[4]))));
+
+#ifdef DEBUG
+	pr_debug("%s read x=%X %X(regH regL), x=%d(dec) [ug]\n",
+		LSM303D_ACC_DEV_NAME, acc_data[1], acc_data[0], hw_d[0]);
+	pr_debug("%s read y=%X %X(regH regL), y=%d(dec) [ug]\n",
+		LSM303D_ACC_DEV_NAME, acc_data[3], acc_data[2], hw_d[1]);
+	pr_debug("%s read z=%X %X(regH regL), z=%d(dec) [ug]\n",
+		LSM303D_ACC_DEV_NAME, acc_data[5], acc_data[4], hw_d[2]);
+#endif
+
+	hw_d[0] = hw_d[0] * stat->sensitivity_acc;
+	hw_d[1] = hw_d[1] * stat->sensitivity_acc;
+	hw_d[2] = hw_d[2] * stat->sensitivity_acc;
+
+	for (i = 0; i < 3; i++) {
+		xyz[i] = stat->pdata_acc->rot_matrix[0][i] * hw_d[0] +
+				stat->pdata_acc->rot_matrix[1][i] * hw_d[1] +
+				stat->pdata_acc->rot_matrix[2][i] * hw_d[2];
+	}
+
+	return err;
+}
+
+static int lsm303d_mag_get_data(struct lsm303d_status *stat, int *xyz)
+{
+	int i, err = -1;
+	u8 mag_data[6];
+	s32 hw_d[3] = { 0 };
+
+	mag_data[0] = (REG_MAG_DATA_ADDR);
+	err = lsm303d_i2c_read(stat, mag_data, 6);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = ((s32)( (s16)((mag_data[1] << 8) | (mag_data[0]))));
+	hw_d[1] = ((s32)( (s16)((mag_data[3] << 8) | (mag_data[2]))));
+	hw_d[2] = ((s32)( (s16)((mag_data[5] << 8) | (mag_data[4]))));
+
+#ifdef DEBUG
+	pr_debug("%s read x=%X %X(regH regL), x=%d(dec) [ug]\n",
+		LSM303D_MAG_DEV_NAME, mag_data[1], mag_data[0], hw_d[0]);
+	pr_debug("%s read x=%X %X(regH regL), x=%d(dec) [ug]\n",
+		LSM303D_MAG_DEV_NAME, mag_data[3], mag_data[2], hw_d[1]);
+	pr_debug("%s read x=%X %X(regH regL), x=%d(dec) [ug]\n",
+		LSM303D_MAG_DEV_NAME, mag_data[5], mag_data[4], hw_d[2]);
+#endif
+
+	hw_d[0] = hw_d[0] * stat->sensitivity_mag;
+	hw_d[1] = hw_d[1] * stat->sensitivity_mag;
+	hw_d[2] = hw_d[2] * stat->sensitivity_mag;
+
+	for (i = 0; i < 3; i++) {
+		xyz[i] = stat->pdata_acc->rot_matrix[0][i] * hw_d[0] +
+				stat->pdata_acc->rot_matrix[1][i] * hw_d[1] +
+				stat->pdata_acc->rot_matrix[2][i] * hw_d[2];
+	}
+
+	return err;
+}
+
+static int lsm303d_temp_get_data(struct lsm303d_status *stat, 
+							int *dec, int *flo)
+{
+	int err = -1;
+	u8 temp_data[2];
+	s16 hw_d = 0;
+
+	temp_data[0] = (REG_TEMP_DATA_ADDR);
+	err = lsm303d_i2c_read(stat, temp_data, 2);
+	if (err < 0)
+		return err;
+
+	hw_d = (s16)((temp_data[1] << 8) | (temp_data[0]));
+	
+
+#ifdef DEBUG
+	pr_debug("%s read T=%X %X(regH regL), T=%d(dec) [C]\n",
+		LSM303D_DEV_NAME, temp_data[1], temp_data[0], hw_d);
+#endif
+
+	*dec = (int)(hw_d/TEMP_SENSITIVITY) + OFFSET_TEMP;
+	*flo = (((unsigned int)hw_d)%TEMP_SENSITIVITY);
+
+	return err;
+}
+
+static void lsm303d_acc_report_values(struct lsm303d_status *stat, int *xyz)
+{
+	input_report_abs(stat->input_dev_acc, ABS_X, xyz[0]);
+	input_report_abs(stat->input_dev_acc, ABS_Y, xyz[1]);
+	input_report_abs(stat->input_dev_acc, ABS_Z, xyz[2]);
+	input_sync(stat->input_dev_acc);
+}
+
+static void lsm303d_mag_report_values(struct lsm303d_status *stat, int *xyz)
+{
+	input_report_abs(stat->input_dev_mag, ABS_X, xyz[0]);
+	input_report_abs(stat->input_dev_mag, ABS_Y, xyz[1]);
+	input_report_abs(stat->input_dev_mag, ABS_Z, xyz[2]);
+	input_sync(stat->input_dev_mag);
+}
+
+static int lsm303d_acc_input_init(struct lsm303d_status *stat)
+{
+	int err;
+
+	stat->input_dev_acc = input_allocate_device();
+	if (!stat->input_dev_acc) {
+		err = -ENOMEM;
+		dev_err(&stat->client->dev, "accelerometer "
+					"input device allocation failed\n");
+		goto err0;
+	}
+
+	stat->input_dev_acc->open = lsm303d_acc_input_open;
+	stat->input_dev_acc->close = lsm303d_acc_input_close;
+	stat->input_dev_acc->name = LSM303D_ACC_DEV_NAME;
+	stat->input_dev_acc->id.bustype = BUS_I2C;
+	stat->input_dev_acc->dev.parent = &stat->client->dev;
+
+	input_set_drvdata(stat->input_dev_acc, stat);
+
+	set_bit(EV_ABS, stat->input_dev_acc->evbit);
+
+	input_set_abs_params(stat->input_dev_acc, ABS_X, 
+				-ACC_G_MAX_NEG, ACC_G_MAX_POS, FUZZ, FLAT);
+	input_set_abs_params(stat->input_dev_acc, ABS_Y, 
+				-ACC_G_MAX_NEG, ACC_G_MAX_POS, FUZZ, FLAT);
+	input_set_abs_params(stat->input_dev_acc, ABS_Z, 
+				-ACC_G_MAX_NEG, ACC_G_MAX_POS, FUZZ, FLAT);
+
+	err = input_register_device(stat->input_dev_acc);
+	if (err) {
+		dev_err(&stat->client->dev,
+			"unable to register accelerometer input device %s\n",
+				stat->input_dev_acc->name);
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	input_free_device(stat->input_dev_acc);
+err0:
+	return err;
+}
+
+static int lsm303d_mag_input_init(struct lsm303d_status *stat)
+{
+	int err;
+
+	stat->input_dev_mag = input_allocate_device();
+	if (!stat->input_dev_mag) {
+		err = -ENOMEM;
+		dev_err(&stat->client->dev, "magnetometer "
+					"input device allocation failed\n");
+		goto err0;
+	}
+
+	stat->input_dev_mag->open = lsm303d_mag_input_open;
+	stat->input_dev_mag->close = lsm303d_mag_input_close;
+	stat->input_dev_mag->name = LSM303D_MAG_DEV_NAME;
+	stat->input_dev_mag->id.bustype = BUS_I2C;
+	stat->input_dev_mag->dev.parent = &stat->client->dev;
+
+	input_set_drvdata(stat->input_dev_mag, stat);
+
+	set_bit(EV_ABS, stat->input_dev_mag->evbit);
+
+	input_set_abs_params(stat->input_dev_mag, ABS_X, 
+				-MAG_G_MAX_NEG, MAG_G_MAX_POS, FUZZ, FLAT);
+	input_set_abs_params(stat->input_dev_mag, ABS_Y, 
+				-MAG_G_MAX_NEG, MAG_G_MAX_POS, FUZZ, FLAT);
+	input_set_abs_params(stat->input_dev_mag, ABS_Z, 
+				-MAG_G_MAX_NEG, MAG_G_MAX_POS, FUZZ, FLAT);
+
+	err = input_register_device(stat->input_dev_mag);
+	if (err) {
+		dev_err(&stat->client->dev,
+			"unable to register magnetometer input device %s\n",
+				stat->input_dev_mag->name);
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	input_free_device(stat->input_dev_mag);
+err0:
+	return err;
+}
+
+static void lsm303d_input_cleanup(struct lsm303d_status *stat)
+{
+	input_unregister_device(stat->input_dev_acc);
+	input_free_device(stat->input_dev_acc);
+
+	input_unregister_device(stat->input_dev_mag);
+	input_free_device(stat->input_dev_mag);
+}
+
+static void poll_function_work_acc(struct work_struct *input_work_acc)
+{
+	struct lsm303d_status *stat;
+	int xyz[3] = { 0 };
+	int err;
+
+	stat = container_of((struct work_struct *)input_work_acc,
+			struct lsm303d_status, input_work_acc);
+
+	err = lsm303d_acc_get_data(stat, xyz);
+	if (err < 0)
+		dev_err(&stat->client->dev, "get_accelerometer_data failed\n");
+	else
+		lsm303d_acc_report_values(stat, xyz);
+
+	hrtimer_start(&stat->hr_timer_acc, stat->ktime_acc, HRTIMER_MODE_REL);
+}
+
+static void poll_function_work_mag(struct work_struct *input_work_mag)
+{
+	struct lsm303d_status *stat;
+	int xyz[3] = { 0 };
+	int err;
+	int dec;
+	int flo;
+
+	stat = container_of((struct work_struct *)input_work_mag,
+			struct lsm303d_status, input_work_mag);
+
+	if(atomic_read(&stat->enabled_temp)) {
+		err = lsm303d_temp_get_data(stat, &dec, &flo);
+		if (err < 0)
+			dev_err(&stat->client->dev, "get_temperature_data"
+								" failed\n");
+		else {
+			stat->temp_value_dec = dec;
+			stat->temp_value_flo = flo;
+		}
+	}
+
+	if(atomic_read(&stat->enabled_mag)) {
+		err = lsm303d_mag_get_data(stat, xyz);
+		if (err < 0)
+			dev_err(&stat->client->dev, "get_magnetometer_data"
+								" failed\n");
+		else
+			lsm303d_mag_report_values(stat, xyz);
+	}
+
+	hrtimer_start(&stat->hr_timer_mag, stat->ktime_mag, HRTIMER_MODE_REL);
+}
+
+enum hrtimer_restart poll_function_read_acc(struct hrtimer *timer)
+{
+	struct lsm303d_status *stat;
+
+
+	stat = container_of((struct hrtimer *)timer,
+				struct lsm303d_status, hr_timer_acc);
+
+	queue_work(lsm303d_workqueue, &stat->input_work_acc);
+	return HRTIMER_NORESTART;
+}
+
+enum hrtimer_restart poll_function_read_mag(struct hrtimer *timer)
+{
+	struct lsm303d_status *stat;
+
+
+	stat = container_of((struct hrtimer *)timer,
+				struct lsm303d_status, hr_timer_mag);
+
+	queue_work(lsm303d_workqueue, &stat->input_work_mag);
+	return HRTIMER_NORESTART;
+}
+
+static int lsm303d_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	struct lsm303d_status *stat;
+	int gpio1 = 0, gpio2 = 0;
+
+	u32 smbus_func = I2C_FUNC_SMBUS_BYTE_DATA | 
+			I2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_I2C_BLOCK;
+
+	int err = -1;
+	dev_info(&client->dev, "probe start.\n");
+	stat = kzalloc(sizeof(struct lsm303d_status), GFP_KERNEL);
+	if (stat == NULL) {
+		err = -ENOMEM;
+		dev_err(&client->dev,
+				"failed to allocate memory for module data: "
+					"%d\n", err);
+		goto exit_check_functionality_failed;
+	}
+
+	stat->use_smbus = 0;
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_warn(&client->dev, "client not i2c capable\n");
+		if (i2c_check_functionality(client->adapter, smbus_func)){
+			stat->use_smbus = 1;
+			dev_warn(&client->dev, "client using SMBUS\n");
+		} else {			
+			err = -ENODEV;
+			dev_err(&client->dev, "client nor SMBUS capable\n");
+			goto exit_check_functionality_failed;
+		}
+	}
+
+	if(lsm303d_workqueue == 0)
+		lsm303d_workqueue = create_workqueue("lsm303d_workqueue");
+
+	hrtimer_init(&stat->hr_timer_acc, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	stat->hr_timer_acc.function = &poll_function_read_acc;
+	hrtimer_init(&stat->hr_timer_mag, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	stat->hr_timer_mag.function = &poll_function_read_mag;
+
+	mutex_init(&stat->lock);
+	mutex_lock(&stat->lock);
+
+	stat->client = client;
+	i2c_set_clientdata(client, stat);
+
+	stat->pdata_acc = kmalloc(sizeof(*stat->pdata_acc), GFP_KERNEL);
+	stat->pdata_mag = kmalloc(sizeof(*stat->pdata_mag), GFP_KERNEL);
+	if ((stat->pdata_acc == NULL)||(stat->pdata_mag == NULL)) {
+		err = -ENOMEM;
+		dev_err(&client->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		goto err_mutexunlock;
+	}
+
+	if (IS_ENABLED(CONFIG_OF) && client->dev.of_node) {
+		struct device_node *np;
+		np = client->dev.of_node;
+		if (np) {
+			gpio1 = of_get_named_gpio(np, "int1-gpio", 0);
+			gpio2 = of_get_named_gpio(np, "int2-gpio", 0);
+		}
+	}
+
+	if (client->dev.platform_data == NULL) {
+		memcpy(stat->pdata_acc, &default_lsm303d_acc_pdata,
+						sizeof(*stat->pdata_acc));
+		memcpy(stat->pdata_mag, &default_lsm303d_mag_pdata,
+						sizeof(*stat->pdata_mag));
+
+		if (gpio1 > 0 && gpio2 > 0) {
+			stat->pdata_acc->gpio_int1 = gpio1;
+			stat->pdata_acc->gpio_int2 = gpio2;
+		}
+		else
+			dev_info(&client->dev, "using default plaform_data for "
+						"accelerometer and magnetometer\n");
+	} else {
+		struct lsm303d_main_platform_data *tmp;
+		tmp = kzalloc(sizeof(struct lsm303d_main_platform_data), 
+								GFP_KERNEL);
+		if(tmp == NULL)
+			goto exit_kfree_pdata;
+		memcpy(tmp, client->dev.platform_data, sizeof(*tmp));
+		if(tmp->pdata_acc == NULL) {
+			memcpy(stat->pdata_acc, &default_lsm303d_acc_pdata,
+						sizeof(*stat->pdata_acc));
+			dev_info(&client->dev, "using default plaform_data for "
+							"accelerometer\n");
+		} else {
+			memcpy(stat->pdata_acc, tmp->pdata_acc, 
+						sizeof(*stat->pdata_acc));
+		}
+		if(tmp->pdata_mag == NULL) {
+			memcpy(stat->pdata_mag, &default_lsm303d_mag_pdata,
+						sizeof(*stat->pdata_mag));
+			dev_info(&client->dev, "using default plaform_data for "
+							"magnetometer\n");
+		} else {
+			memcpy(stat->pdata_mag, tmp->pdata_mag, 
+						sizeof(*stat->pdata_mag));
+		}
+		kfree(tmp);
+	}
+
+	err = lsm303d_acc_validate_pdata(stat);
+	if (err < 0) {
+		dev_err(&client->dev, "failed to validate platform data for "
+							"accelerometer \n");
+		goto exit_kfree_pdata;
+	}
+
+	err = lsm303d_mag_validate_pdata(stat);
+	if (err < 0) {
+		dev_err(&client->dev, "failed to validate platform data for "
+							"magnetometer\n");
+		goto exit_kfree_pdata;
+	}
+
+	if (stat->pdata_acc->init) {
+		err = stat->pdata_acc->init();
+		if (err < 0) {
+			dev_err(&client->dev, "accelerometer init failed: "
+								"%d\n", err);
+			goto err_pdata_acc_init;
+		}
+	}
+	if (stat->pdata_mag->init) {
+		err = stat->pdata_mag->init();
+		if (err < 0) {
+			dev_err(&client->dev, "magnetometer init failed: "
+								"%d\n", err);
+			goto err_pdata_mag_init;
+		}
+	}
+
+	if(stat->pdata_acc->gpio_int1 >= 0) {
+		if (!gpio_is_valid(stat->pdata_acc->gpio_int1)) {
+  			dev_err(&client->dev, "The requested GPIO [%d] is not "
+				"available\n", stat->pdata_acc->gpio_int1);
+			err = -EINVAL;
+  			goto err_gpio1_valid;
+		}
+		
+		err = gpio_request(stat->pdata_acc->gpio_int1, 
+						"INTERRUPT_PIN1_LSM303D");
+		if(err < 0) {
+			dev_err(&client->dev, "Unable to request GPIO [%d].\n",
+						stat->pdata_acc->gpio_int1);
+  			err = -EINVAL;
+			goto err_gpio1_valid;
+		}
+		gpio_direction_input(stat->pdata_acc->gpio_int1);
+		stat->irq1 = gpio_to_irq(stat->pdata_acc->gpio_int1);
+		if(stat->irq1 < 0) {
+			dev_err(&client->dev, "GPIO [%d] cannot be used as "
+				"interrupt.\n",	stat->pdata_acc->gpio_int1);
+			err = -EINVAL;
+			goto err_gpio1_irq;
+		}
+		pr_info("%s: %s has set irq1 to irq: %d, mapped on gpio:%d\n",
+			LSM303D_DEV_NAME, __func__, stat->irq1,
+						stat->pdata_acc->gpio_int1);
+	}
+
+	if(stat->pdata_acc->gpio_int2 >= 0) {
+		if (!gpio_is_valid(stat->pdata_acc->gpio_int2)) {
+  			dev_err(&client->dev, "The requested GPIO [%d] is not "
+				"available\n", stat->pdata_acc->gpio_int2);
+			err = -EINVAL;
+  			goto err_gpio2_valid;
+		}
+		
+		err = gpio_request(stat->pdata_acc->gpio_int2, 
+						"INTERRUPT_PIN2_LSM303D");
+		if(err < 0) {
+			dev_err(&client->dev, "Unable to request GPIO [%d].\n",
+						stat->pdata_acc->gpio_int2);
+  			err = -EINVAL;
+			goto err_gpio2_valid;
+		}
+		gpio_direction_input(stat->pdata_acc->gpio_int2);
+		stat->irq2 = gpio_to_irq(stat->pdata_acc->gpio_int2);
+		if(stat->irq2 < 0) {
+			dev_err(&client->dev, "GPIO [%d] cannot be used as "
+				"interrupt.\n", stat->pdata_acc->gpio_int2);
+			err = -EINVAL;
+			goto err_gpio2_irq;
+		}
+		pr_info("%s: %s has set irq2 to irq: %d, "
+							"mapped on gpio:%d\n",
+			LSM303D_DEV_NAME, __func__, stat->irq2,
+						stat->pdata_acc->gpio_int2);
+	}
+
+	err = lsm303d_hw_init(stat);
+	if (err < 0) {
+		dev_err(&client->dev, "hw init failed: %d\n", err);
+		goto err_hw_init;
+	}
+
+	err = lsm303d_acc_device_power_on(stat);
+	if (err < 0) {
+		dev_err(&client->dev, "accelerometer power on failed: "
+								"%d\n", err);
+		goto err_pdata_init;
+	}
+	err = lsm303d_mag_device_power_on(stat);
+	if (err < 0) {
+		dev_err(&client->dev, "magnetometer power on failed: "
+								"%d\n", err);
+		goto err_pdata_init;
+	}
+
+	err = lsm303d_acc_update_fs_range(stat, stat->pdata_acc->fs_range);
+	if (err < 0) {
+		dev_err(&client->dev, "update_fs_range on accelerometer "
+								"failed\n");
+		goto  err_power_off_acc;
+	}
+
+	err = lsm303d_mag_update_fs_range(stat, stat->pdata_mag->fs_range);
+	if (err < 0) {
+		dev_err(&client->dev, "update_fs_range on magnetometer "
+								"failed\n");
+		goto  err_power_off_mag;
+	}
+
+	err = lsm303d_acc_update_odr(stat, stat->pdata_acc->poll_interval);
+	if (err < 0) {
+		dev_err(&client->dev, "update_odr on accelerometer failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm303d_mag_update_odr(stat, stat->pdata_mag->poll_interval);
+	if (err < 0) {
+		dev_err(&client->dev, "update_odr on magnetometer failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm303d_acc_update_filter(stat, 
+					stat->pdata_acc->aa_filter_bandwidth);
+	if (err < 0) {
+		dev_err(&client->dev, "update_filter on accelerometer "
+								"failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm303d_acc_input_init(stat);
+	if (err < 0) {
+		dev_err(&client->dev, "accelerometer input init failed\n");
+		goto err_power_off;
+	}
+
+	err = lsm303d_mag_input_init(stat);
+	if (err < 0) {
+		dev_err(&client->dev, "magnetometer input init failed\n");
+		goto err_power_off;
+	}
+
+	err = create_sysfs_interfaces(&client->dev);
+	if (err < 0) {
+		dev_err(&client->dev,
+		"device LSM303D_DEV_NAME sysfs register failed\n");
+		goto err_input_cleanup;
+	}
+
+	lsm303d_acc_device_power_off(stat);
+	lsm303d_mag_device_power_off(stat);
+
+	if(stat->pdata_acc->gpio_int1 >= 0){
+		INIT_WORK(&stat->irq1_work, lsm303d_irq1_work_func);
+		stat->irq1_work_queue =
+				create_singlethread_workqueue("lsm303d_wq1");
+		if (!stat->irq1_work_queue) {
+			err = -ENOMEM;
+			dev_err(&client->dev,
+					"cannot create work queue1: %d\n", err);
+			goto err_remove_sysfs_int;
+		}
+		err = request_irq(stat->irq1, lsm303d_isr1,
+				IRQF_TRIGGER_RISING, "lsm303d_irq1", stat);
+		if (err < 0) {
+			dev_err(&client->dev, "request irq1 failed: %d\n", err);
+			goto err_destoyworkqueue1;
+		}
+		disable_irq_nosync(stat->irq1);
+	}
+
+	if(stat->pdata_acc->gpio_int2 >= 0){
+		INIT_WORK(&stat->irq2_work, lsm303d_irq2_work_func);
+		stat->irq2_work_queue =
+				create_singlethread_workqueue("lsm303d_wq2");
+		if (!stat->irq2_work_queue) {
+			err = -ENOMEM;
+			dev_err(&client->dev,
+					"cannot create work queue2: %d\n", err);
+			goto err_free_irq1;
+		}
+		err = request_irq(stat->irq2, lsm303d_isr2,
+				IRQF_TRIGGER_RISING, "lsm303d_irq2", stat);
+		if (err < 0) {
+			dev_err(&client->dev, "request irq2 failed: %d\n", err);
+			goto err_destoyworkqueue2;
+		}
+		disable_irq_nosync(stat->irq2);
+	}
+
+	
+	
+	INIT_WORK(&stat->input_work_acc, poll_function_work_acc);
+	INIT_WORK(&stat->input_work_mag, poll_function_work_mag);
+	
+	mutex_unlock(&stat->lock);
+	dev_info(&client->dev, "%s: probed\n", LSM303D_DEV_NAME);
+	
+	return 0;
+
+err_destoyworkqueue2:
+	destroy_workqueue(stat->irq2_work_queue);
+err_free_irq1:
+	free_irq(stat->irq1, stat);
+err_destoyworkqueue1:
+	destroy_workqueue(stat->irq1_work_queue);
+err_remove_sysfs_int:
+	remove_sysfs_interfaces(&client->dev);
+err_input_cleanup:
+	lsm303d_input_cleanup(stat);
+err_power_off:
+err_power_off_mag:
+	lsm303d_mag_device_power_off(stat);
+err_power_off_acc:
+	lsm303d_acc_device_power_off(stat);
+	kfree(stat->interrupt);
+err_hw_init:
+err_gpio2_irq:
+	gpio_free(stat->pdata_acc->gpio_int2);
+err_gpio2_valid:
+err_gpio1_irq:
+	gpio_free(stat->pdata_acc->gpio_int1);
+err_gpio1_valid:
+err_pdata_init:
+err_pdata_mag_init:
+	if (stat->pdata_mag->exit)
+		stat->pdata_mag->exit();
+err_pdata_acc_init:
+	if (stat->pdata_acc->exit)
+		stat->pdata_acc->exit();
+exit_kfree_pdata:
+	kfree(stat->pdata_acc);
+	kfree(stat->pdata_mag);
+err_mutexunlock:
+	mutex_unlock(&stat->lock);
+	kfree(stat);
+	if(!lsm303d_workqueue) {
+		flush_workqueue(lsm303d_workqueue);
+		destroy_workqueue(lsm303d_workqueue);
+	}
+exit_check_functionality_failed:
+	pr_err("%s: Driver Init failed\n", LSM303D_DEV_NAME);
+	return err;
+}
+
+static int lsm303d_remove(struct i2c_client *client)
+{
+	struct lsm303d_status *stat = i2c_get_clientdata(client);
+
+	lsm303d_acc_disable(stat);
+	lsm303d_mag_disable(stat);
+	lsm303d_temperature_disable(stat);
+
+	if(stat->pdata_acc->gpio_int1 >= 0) {
+		free_irq(stat->irq1, stat);
+		gpio_free(stat->pdata_acc->gpio_int1);
+		destroy_workqueue(stat->irq1_work_queue);
+	}
+
+	if(stat->pdata_acc->gpio_int2 >= 0) {
+		free_irq(stat->irq2, stat);
+		gpio_free(stat->pdata_acc->gpio_int2);
+		destroy_workqueue(stat->irq2_work_queue);
+	}
+
+	lsm303d_acc_input_cleanup(stat);
+	lsm303d_mag_input_cleanup(stat);
+
+	remove_sysfs_interfaces(&client->dev);
+
+	if (stat->pdata_acc->exit)
+		stat->pdata_acc->exit();
+
+	if (stat->pdata_mag->exit)
+		stat->pdata_mag->exit();
+
+	if((stat->pdata_acc->gpio_int1 >= 0)||
+					(stat->pdata_acc->gpio_int2 >= 0)) {
+		kfree(stat->interrupt);
+	}
+
+	if(!lsm303d_workqueue) {
+		flush_workqueue(lsm303d_workqueue);
+		destroy_workqueue(lsm303d_workqueue);
+	}
+
+	kfree(stat->pdata_acc);
+	kfree(stat->pdata_mag);
+	kfree(stat);
+	return 0;
+}
+
+static const struct i2c_device_id lsm303d_id[] 
+					= { { LSM303D_DEV_NAME, 0 }, { }, };
+
+MODULE_DEVICE_TABLE(i2c, lsm303d_id);
+
+static const struct of_device_id lsm303d_of_match[] = {
+	{ .compatible = "lsm303d" },
+	{ /* Sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, lsm303d_of_match);
+
+static struct i2c_driver lsm303d_driver = {
+	.driver = {
+			.owner = THIS_MODULE,
+			.name = LSM303D_DEV_NAME,
+			.of_match_table = of_match_ptr(lsm303d_of_match),
+		  },
+	.probe = lsm303d_probe,
+	.remove = lsm303d_remove,
+	.id_table = lsm303d_id,
+};
+
+static int __init lsm303d_init(void)
+{
+	pr_info("%s driver: init\n", LSM303D_DEV_NAME);
+	return i2c_add_driver(&lsm303d_driver);
+}
+
+static void __exit lsm303d_exit(void)
+{
+	pr_info("%s driver exit\n", LSM303D_DEV_NAME);
+	i2c_del_driver(&lsm303d_driver);
+}
+
+module_init(lsm303d_init);
+module_exit(lsm303d_exit);
+
+MODULE_DESCRIPTION("lsm303d accelerometer and magnetometer driver");
+MODULE_AUTHOR("Matteo Dameno, Denis Ciocca, STMicroelectronics");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/misc/lsm303d.h b/drivers/input/misc/lsm303d.h
new file mode 100644
index 0000000..d6bb9a0
--- /dev/null
+++ b/drivers/input/misc/lsm303d.h
@@ -0,0 +1,138 @@
+/******************** (C) COPYRIGHT 2013 STMicroelectronics *******************
+*
+* File Name          : lsm303d.h
+* Authors            : AMS - MSH Div - Application Team
+*		     : Matteo Dameno (matteo.dameno@st.com)
+*		     : Denis Ciocca (denis.ciocca@st.com)
+* Version            : V.1.0.5
+* Date               : 2013/Oct/23
+*
+*******************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+******************************************************************************/
+
+#ifndef	__LSM303D_H__
+#define	__LSM303D_H__
+
+#define	LSM303D_DEV_NAME	"lsm303d"
+#define	LSM303D_ACC_DEV_NAME	"lsm303d_acc"	/* Input file name */
+#define	LSM303D_MAG_DEV_NAME	"lsm303d_mag"	/* Input file name */
+
+#define LSM303D_SAD0L			(0x02)
+#define LSM303D_SAD0H			(0x01)
+#define LSM303D_I2C_SADROOT		(0x07)
+#define LSM303D_I2C_SAD_L		((LSM303D_I2C_SADROOT<<2) | \
+								LSM303D_SAD0L)
+#define LSM303D_I2C_SAD_H		((LSM303D_I2C_SADROOT<<2) | \
+								LSM303D_SAD0H)
+
+/************************************************/
+/* 	Output data			 	*/
+/*************************************************
+accelerometer: ug
+magnetometer: ugauss
+*************************************************/
+
+/************************************************/
+/* 	sysfs data			 	*/
+/*************************************************
+accelerometer:
+	- pollrate->ms
+	- fullscale->g
+magnetometer:
+	- pollrate->ms
+	- fullscale->gauss
+*************************************************/
+
+/************************************************/
+/* 	Accelerometer section defines	 	*/
+/************************************************/
+
+/* Accelerometer Sensor Full Scale */
+#define	LSM303D_ACC_FS_MASK	(0x18)
+#define LSM303D_ACC_FS_2G 	(0x00)	/* Full scale 2g */
+#define LSM303D_ACC_FS_4G 	(0x08)	/* Full scale 4g */
+#define LSM303D_ACC_FS_8G 	(0x10)	/* Full scale 8g */
+#define LSM303D_ACC_FS_16G	(0x18)	/* Full scale 16g */
+
+/* Accelerometer Anti-Aliasing Filter */
+#define ANTI_ALIASING_773	(0X00)
+#define ANTI_ALIASING_362	(0X40)
+#define ANTI_ALIASING_194	(0X80)
+#define ANTI_ALIASING_50	(0XC0)
+
+/************************************************/
+/* 	Magnetometer section defines	 	*/
+/************************************************/
+
+/* Magnetometer Sensor Full Scale */
+#define LSM303D_MAG_FS_MASK	(0x60)
+#define LSM303D_MAG_FS_2G	(0x00)	/* Full scale 2 gauss */
+#define LSM303D_MAG_FS_4G	(0x20)	/* Full scale 4 gauss */
+#define LSM303D_MAG_FS_8G	(0x40)	/* Full scale 8 gauss */
+#define LSM303D_MAG_FS_12G	(0x60)	/* Full scale 12 gauss */
+
+
+#ifdef	__KERNEL__
+
+#define DEFAULT_INT1_GPIO		(-EINVAL)
+#define DEFAULT_INT2_GPIO		(-EINVAL)
+
+#define	LSM303D_ACC_MIN_POLL_PERIOD_MS	1
+#define LSM303D_MAG_MIN_POLL_PERIOD_MS	5
+
+struct lsm303d_acc_platform_data {
+	
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	short rot_matrix[3][3];
+
+	u8 aa_filter_bandwidth;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+
+	int gpio_int1;
+	int gpio_int2;
+};
+
+struct lsm303d_mag_platform_data {
+
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	short rot_matrix[3][3];
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+};
+
+struct lsm303d_main_platform_data {
+	
+	struct lsm303d_acc_platform_data *pdata_acc;
+	struct lsm303d_mag_platform_data *pdata_mag;
+};
+
+#endif	/* __KERNEL__ */
+#endif	/* __LSM303D_H__ */
diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index f94dfed..cb0e8d5 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -565,6 +565,35 @@ config VIDEO_OV5693
 	  To compile this driver as a module, choose M here: the module
 	  will be called ov5693.
 
+config VIDEO_OV5670
+	tristate "OV5670 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the OmniVision
+	  OV5670 camera.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called ov5670.
+
+config VIDEO_OV5640
+	tristate "OV5640 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the OmniVision
+	  OV5640 camera.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called ov5640.
+
+config VIDEO_IMX214
+        tristate "IMX214 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	---help---
+	  This driver supports IMX214 camera sensor from Sony
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called imx214.
+
 config VIDEO_IMX219
         tristate "IMX219 camera sensor support"
 	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index 5f3a2fa..fc5ddc9 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -88,6 +88,9 @@ obj-$(CONFIG_VIDEO_OV10823) += ov10823.o
 obj-$(CONFIG_VIDEO_OV23850) += ov23850.o
 obj-$(CONFIG_VIDEO_LC898212) += lc898212.o
 obj-$(CONFIG_VIDEO_OV5693) += ov5693.o
+obj-$(CONFIG_VIDEO_OV5670) += ov5670.o
+obj-$(CONFIG_VIDEO_OV5640) += ov5640.o
+obj-$(CONFIG_VIDEO_IMX214) += imx214.o
 obj-$(CONFIG_VIDEO_IMX219) += imx219.o
 obj-$(CONFIG_VIDEO_IMX274) += imx274.o
 obj-$(CONFIG_VIDEO_TC358840)	+= tc358840.o
diff --git a/drivers/media/i2c/imx214.c b/drivers/media/i2c/imx214.c
index 9725608..64b16b4 100644
--- a/drivers/media/i2c/imx214.c
+++ b/drivers/media/i2c/imx214.c
@@ -1,5 +1,5 @@
 /*
- * imx214.c - imx214 sensor driver
+ * imx214_v4l2.c - imx214 sensor driver
  *
  * Copyright (c) 2013-2017, NVIDIA CORPORATION.  All rights reserved.
  *
@@ -16,6 +16,8 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#define DEBUG
+
 #include <linux/slab.h>
 #include <linux/uaccess.h>
 #include <linux/gpio.h>
@@ -30,29 +32,37 @@
 #include <media/camera_common.h>
 #include <media/imx214.h>
 
+#include "../platform/tegra/camera/camera_gpio.h"
+
 #include "imx214_mode_tbls.h"
 
-#define IMX214_MAX_COARSE_DIFF		10
+#define IMX214_MAX_COARSE_DIFF		6
 
 #define IMX214_GAIN_SHIFT		8
 #define IMX214_MIN_GAIN		(1 << IMX214_GAIN_SHIFT)
 #define IMX214_MAX_GAIN		(16 << IMX214_GAIN_SHIFT)
+#define IMX214_MAX_UNREAL_GAIN	(0x0F80)
 #define IMX214_MIN_FRAME_LENGTH	(0x0)
-#define IMX214_MAX_FRAME_LENGTH	(0xffff)
-#define IMX214_MIN_EXPOSURE_COARSE	(0x0001)
+#define IMX214_MAX_FRAME_LENGTH	(0x7fff)
+#define IMX214_MIN_EXPOSURE_COARSE	(0x0002)
 #define IMX214_MAX_EXPOSURE_COARSE	\
 	(IMX214_MAX_FRAME_LENGTH-IMX214_MAX_COARSE_DIFF)
+#define IMX214_DEFAULT_LINE_LENGTH	(0x10CC)
+//#define IMX214_DEFAULT_PIXEL_CLOCK	(108)
+#define IMX214_DEFAULT_PIXEL_CLOCK	(480)
+//#define IMX214_DEFAULT_PIXEL_CLOCK	(160)
 
 #define IMX214_DEFAULT_GAIN		IMX214_MIN_GAIN
-#define IMX214_DEFAULT_FRAME_LENGTH	(0x0C7A)
+#define IMX214_DEFAULT_FRAME_LENGTH	(0x07C0)
 #define IMX214_DEFAULT_EXPOSURE_COARSE	\
 	(IMX214_DEFAULT_FRAME_LENGTH-IMX214_MAX_COARSE_DIFF)
 
-#define IMX214_DEFAULT_MODE	IMX214_MODE_4096X3072
-#define IMX214_DEFAULT_HDR_MODE	IMX214_MODE_4096X3072_HDR
-#define IMX214_DEFAULT_WIDTH	4096
-#define IMX214_DEFAULT_HEIGHT	3072
-#define IMX214_DEFAULT_DATAFMT	V4L2_MBUS_FMT_SRGGB10_1X10
+#define IMX214_DEFAULT_MODE	IMX214_MODE_4208X3120
+//#define IMX214_DEFAULT_MODE	IMX214_MODE_4096X2304
+//#define IMX214_DEFAULT_HDR_MODE	IMX214_MODE_2592X1944_HDR
+#define IMX214_DEFAULT_WIDTH	4208
+#define IMX214_DEFAULT_HEIGHT	3120
+#define IMX214_DEFAULT_DATAFMT	MEDIA_BUS_FMT_SBGGR10_1X10
 #define IMX214_DEFAULT_CLK_FREQ	24000000
 
 struct imx214 {
@@ -66,6 +76,7 @@ struct imx214 {
 	struct media_pad		pad;
 
 	s32				group_hold_prev;
+	u32				frame_length;
 	bool				group_hold_en;
 	struct regmap			*regmap;
 	struct camera_common_data	*s_data;
@@ -73,14 +84,14 @@ struct imx214 {
 	struct v4l2_ctrl		*ctrls[];
 };
 
-static const struct regmap_config sensor_regmap_config = {
+static struct regmap_config imx214_regmap_config = {
 	.reg_bits = 16,
 	.val_bits = 8,
-	.cache_type = REGCACHE_RBTREE,
 };
 
 static int imx214_g_volatile_ctrl(struct v4l2_ctrl *ctrl);
 static int imx214_s_ctrl(struct v4l2_ctrl *ctrl);
+static void imx214_update_ctrl_range(struct imx214 *priv, s32 frame_length);
 
 static const struct v4l2_ctrl_ops imx214_ctrl_ops = {
 	.g_volatile_ctrl = imx214_g_volatile_ctrl,
@@ -175,20 +186,10 @@ static struct v4l2_ctrl_config ctrl_config_list[] = {
 		.max = IMX214_OTP_STR_SIZE,
 		.step = 2,
 	},
-	{
-		.ops = &imx214_ctrl_ops,
-		.id = TEGRA_CAMERA_CID_FUSE_ID,
-		.name = "Fuse ID",
-		.type = V4L2_CTRL_TYPE_STRING,
-		.flags = V4L2_CTRL_FLAG_READ_ONLY,
-		.min = 0,
-		.max = IMX214_FUSE_ID_STR_SIZE,
-		.step = 2,
-	},
 };
 
 static inline void imx214_get_frame_length_regs(imx214_reg *regs,
-				u16 frame_length)
+				u32 frame_length)
 {
 	regs->addr = IMX214_FRAME_LENGTH_ADDR_MSB;
 	regs->val = (frame_length >> 8) & 0xff;
@@ -196,21 +197,22 @@ static inline void imx214_get_frame_length_regs(imx214_reg *regs,
 	(regs + 1)->val = (frame_length) & 0xff;
 }
 
+
 static inline void imx214_get_coarse_time_regs(imx214_reg *regs,
-				u16 coarse_time)
+				u32 coarse_time)
 {
-	regs->addr = IMX214_COARSE_TIME_ADDR_MSB;
+	regs->addr = IMX214_COARSE_TIME_ADDR_1;
 	regs->val = (coarse_time >> 8) & 0xff;
-	(regs + 1)->addr = IMX214_COARSE_TIME_ADDR_LSB;
+	(regs + 1)->addr = IMX214_COARSE_TIME_ADDR_2;
 	(regs + 1)->val = (coarse_time) & 0xff;
 }
 
 static inline void imx214_get_coarse_time_short_regs(imx214_reg *regs,
-				u16 coarse_time)
+				u32 coarse_time)
 {
-	regs->addr = IMX214_COARSE_TIME_SHORT_ADDR_MSB;
+	regs->addr = IMX214_COARSE_TIME_SHORT_ADDR_1;
 	regs->val = (coarse_time >> 8) & 0xff;
-	(regs + 1)->addr = IMX214_COARSE_TIME_SHORT_ADDR_LSB;
+	(regs + 1)->addr = IMX214_COARSE_TIME_SHORT_ADDR_2;
 	(regs + 1)->val = (coarse_time) & 0xff;
 }
 
@@ -219,16 +221,8 @@ static inline void imx214_get_gain_regs(imx214_reg *regs,
 {
 	regs->addr = IMX214_GAIN_ADDR_MSB;
 	regs->val = (gain >> 8) & 0xff;
-	(regs + 1)->addr = IMX214_GAIN_ADDR_LSB;
-	(regs + 1)->val = (gain) & 0xff;
-}
 
-static inline void imx214_get_gain_short_reg(imx214_reg *regs,
-				u16 gain)
-{
-	regs->addr = IMX214_GAIN_SHORT_ADDR_MSB;
-	regs->val = (gain >> 8) & 0xff;
-	(regs + 1)->addr = IMX214_GAIN_SHORT_ADDR_LSB;
+	(regs + 1)->addr = IMX214_GAIN_ADDR_LSB;
 	(regs + 1)->val = (gain) & 0xff;
 }
 
@@ -239,8 +233,13 @@ static inline int imx214_read_reg(struct camera_common_data *s_data,
 				u16 addr, u8 *val)
 {
 	struct imx214 *priv = (struct imx214 *)s_data->priv;
+	int err = 0;
+	u32 reg_val = 0;
 
-	return regmap_read(priv->regmap, addr, (unsigned int *) val);
+	err = regmap_read(priv->regmap, addr, &reg_val);
+	*val = reg_val & 0xFF;
+
+	return err;
 }
 
 static int imx214_write_reg(struct camera_common_data *s_data, u16 addr, u8 val)
@@ -257,7 +256,7 @@ static int imx214_write_reg(struct camera_common_data *s_data, u16 addr, u8 val)
 }
 
 static int imx214_write_table(struct imx214 *priv,
-				const imx214_reg table[])
+			      const imx214_reg table[])
 {
 	return regmap_util_write_table_8(priv->regmap,
 					 table,
@@ -266,11 +265,25 @@ static int imx214_write_table(struct imx214 *priv,
 					 IMX214_TABLE_END);
 }
 
+static void imx214_gpio_set(struct imx214 *priv,
+			    unsigned int gpio, int val)
+{
+	if (priv->pdata && priv->pdata->use_cam_gpio)
+		cam_gpio_ctrl(&priv->i2c_client->dev, gpio, val, 1);
+	else {
+		if (gpio_cansleep(gpio))
+			gpio_set_value_cansleep(gpio, val);
+		else
+			gpio_set_value(gpio, val);
+	}
+}
+
 static int imx214_power_on(struct camera_common_data *s_data)
 {
 	int err = 0;
 	struct imx214 *priv = (struct imx214 *)s_data->priv;
 	struct camera_common_power_rail *pw = &priv->power;
+	u32 frame_time;
 
 	dev_dbg(&priv->i2c_client->dev, "%s: power on\n", __func__);
 
@@ -283,45 +296,55 @@ static int imx214_power_on(struct camera_common_data *s_data)
 		return err;
 	}
 
-	/* sleep calls in the sequence below are for internal device
+	/* sleeps calls in the sequence below are for internal device
 	 * signal propagation as specified by sensor vendor */
 
-	if (pw->reset_gpio)
-		gpio_set_value(pw->reset_gpio, 0);
-	if (pw->af_gpio)
-		gpio_set_value(pw->af_gpio, 1);
-	if (pw->pwdn_gpio)
-		gpio_set_value(pw->pwdn_gpio, 0);
-	usleep_range(10, 20);
-
 	if (pw->avdd)
 		err = regulator_enable(pw->avdd);
 	if (err)
 		goto imx214_avdd_fail;
 
-	if (pw->iovdd)
-		err = regulator_enable(pw->iovdd);
+	if (pw->dvdd)
+		err = regulator_enable(pw->dvdd);
 	if (err)
-		goto imx214_iovdd_fail;
+		goto imx214_dvdd_fail;
+
+	/*
+	 * datasheet 2.9: reset requires ~2ms settling time
+	 * a power on reset is generated after core power becomes stable
+	 */
+	usleep_range(2000, 2010);
 
-	udelay(1);
 	if (pw->reset_gpio)
-		gpio_set_value(pw->reset_gpio, 1);
+		imx214_gpio_set(priv, pw->reset_gpio, 1);
+
 	if (pw->pwdn_gpio)
-		gpio_set_value(pw->pwdn_gpio, 1);
+		imx214_gpio_set(priv, pw->pwdn_gpio, 1);
+	
+	/* datasheet fig 18: t7 */
 
+	pw->state = SWITCH_ON;
+
+	/* need SW standby LP11 for mipical.
+	 * sensor default is LP00, this will transition to LP11 */
+
+	/*
+	 * Sleep to allow SW reset to settle into LP11. After writing
+	 * 0x1, according to the datasheet, it could take the remainder
+	 * of the frame time to settle.  Streaming too soon after this
+	 * may have unintended consequences.
+	 */
+	frame_time = IMX214_DEFAULT_FRAME_LENGTH *
+			IMX214_DEFAULT_LINE_LENGTH / IMX214_DEFAULT_PIXEL_CLOCK;
 	usleep_range(300, 310);
+	
 
-	pw->state = SWITCH_ON;
 	return 0;
 
-imx214_iovdd_fail:
+imx214_dvdd_fail:
 	regulator_disable(pw->avdd);
 
 imx214_avdd_fail:
-	if (pw->af_gpio)
-		gpio_set_value(pw->af_gpio, 0);
-
 	pr_err("%s failed.\n", __func__);
 	return -ENODEV;
 }
@@ -334,30 +357,33 @@ static int imx214_power_off(struct camera_common_data *s_data)
 
 	dev_dbg(&priv->i2c_client->dev, "%s: power off\n", __func__);
 
-	if (priv->pdata && priv->pdata->power_on) {
+	if (priv->pdata && priv->pdata->power_off) {
 		err = priv->pdata->power_off(pw);
-		if (err) {
+		if (!err) {
+			goto power_off_done;
+		} else {
 			pr_err("%s failed.\n", __func__);
 			return err;
-		} else {
-			goto power_off_done;
 		}
 	}
 
 	/* sleeps calls in the sequence below are for internal device
 	 * signal propagation as specified by sensor vendor */
-
-	usleep_range(1, 2);
+	
+	usleep_range(21, 25);
 	if (pw->reset_gpio)
-		gpio_set_value(pw->reset_gpio, 0);
-	if (pw->af_gpio)
-		gpio_set_value(pw->af_gpio, 0);
+		imx214_gpio_set(priv, pw->reset_gpio, 0);
+
+	usleep_range(1000, 2000);
 	if (pw->pwdn_gpio)
-		gpio_set_value(pw->pwdn_gpio, 0);
-	usleep_range(1, 2);
+		imx214_gpio_set(priv, pw->pwdn_gpio, 0);
+
+	/* datasheet 2.9: reset requires ~2ms settling time*/
+	usleep_range(2000, 2010);
+
+	if (pw->dvdd)
+		regulator_disable(pw->dvdd);
 
-	if (pw->iovdd)
-		regulator_disable(pw->iovdd);
 	if (pw->avdd)
 		regulator_disable(pw->avdd);
 
@@ -369,22 +395,26 @@ power_off_done:
 static int imx214_power_put(struct imx214 *priv)
 {
 	struct camera_common_power_rail *pw = &priv->power;
+
 	if (unlikely(!pw))
 		return -EFAULT;
 
 	if (likely(pw->avdd))
 		regulator_put(pw->avdd);
 
-	if (likely(pw->iovdd))
-		regulator_put(pw->iovdd);
-
 	if (likely(pw->dvdd))
 		regulator_put(pw->dvdd);
 
 	pw->avdd = NULL;
-	pw->iovdd = NULL;
 	pw->dvdd = NULL;
 
+	if (priv->pdata && priv->pdata->use_cam_gpio)
+		cam_gpio_deregister(&priv->i2c_client->dev, pw->pwdn_gpio);
+	else {
+		gpio_free(pw->pwdn_gpio);
+		gpio_free(pw->reset_gpio);
+	}
+
 	return 0;
 }
 
@@ -393,10 +423,17 @@ static int imx214_power_get(struct imx214 *priv)
 	struct camera_common_power_rail *pw = &priv->power;
 	struct camera_common_pdata *pdata = priv->pdata;
 	const char *mclk_name;
-	int err = 0;
+	const char *parentclk_name;
+	struct clk *parent;
+	int err = 0, ret = 0;
+
+	if (!pdata) {
+		dev_err(&priv->i2c_client->dev, "pdata missing\n");
+		return -EFAULT;
+	}
 
-	mclk_name = priv->pdata->mclk_name ?
-		    priv->pdata->mclk_name : "cam_mclk1";
+	mclk_name = pdata->mclk_name ?
+		    pdata->mclk_name : "cam_mclk1";
 	pw->mclk = devm_clk_get(&priv->i2c_client->dev, mclk_name);
 	if (IS_ERR(pw->mclk)) {
 		dev_err(&priv->i2c_client->dev,
@@ -404,22 +441,50 @@ static int imx214_power_get(struct imx214 *priv)
 		return PTR_ERR(pw->mclk);
 	}
 
-	/* analog 2.7v */
-	err |= camera_common_regulator_get(priv->i2c_client,
+	parentclk_name = pdata->parentclk_name;
+	if (parentclk_name) {
+		parent = devm_clk_get(&priv->i2c_client->dev, parentclk_name);
+		if (IS_ERR(parent)) {
+			dev_err(&priv->i2c_client->dev,
+				"unable to get parent clcok %s",
+				parentclk_name);
+		} else
+			clk_set_parent(pw->mclk, parent);
+	}
+
+
+	/* analog 2.8v */
+	err |= camera_common_regulator_get(&priv->i2c_client->dev,
 			&pw->avdd, pdata->regulators.avdd);
-	/* digital 1.2v */
-	err |= camera_common_regulator_get(priv->i2c_client,
+	/* IO 1.2v */
+	err |= camera_common_regulator_get(&priv->i2c_client->dev,
 			&pw->dvdd, pdata->regulators.dvdd);
-	/* IO 1.8v */
-	err |= camera_common_regulator_get(priv->i2c_client,
-			&pw->iovdd, pdata->regulators.iovdd);
 
 	if (!err) {
 		pw->reset_gpio = pdata->reset_gpio;
-		pw->af_gpio = pdata->af_gpio;
 		pw->pwdn_gpio = pdata->pwdn_gpio;
 	}
 
+	if (pdata->use_cam_gpio) {
+		err = cam_gpio_register(&priv->i2c_client->dev, pw->pwdn_gpio);
+		if (err)
+			dev_err(&priv->i2c_client->dev,
+				"%s ERR can't register cam gpio %u!\n",
+				 __func__, pw->pwdn_gpio);
+	} else {
+		ret = gpio_request(pw->pwdn_gpio, "cam_pwdn_gpio");
+		if (ret < 0)
+			dev_dbg(&priv->i2c_client->dev,
+				"%s can't request pwdn_gpio %d\n",
+				__func__, ret);
+		ret = gpio_request(pw->reset_gpio, "cam_reset_gpio");
+		if (ret < 0)
+			dev_dbg(&priv->i2c_client->dev,
+				"%s can't request reset_gpio %d\n",
+				__func__, ret);
+	}
+
+
 	pw->state = SWITCH_OFF;
 	return err;
 }
@@ -432,26 +497,52 @@ static int imx214_set_coarse_time_short(struct imx214 *priv, s32 val);
 static int imx214_s_stream(struct v4l2_subdev *sd, int enable)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct camera_common_data *s_data = to_camera_common_data(client);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
 	struct imx214 *priv = (struct imx214 *)s_data->priv;
 	struct v4l2_control control;
 	int err;
+	u32 frame_time;
+	u8 val;
+
+	dev_dbg(&client->dev, "%s++\n", __func__);
+
+	if (!enable) {
+		imx214_update_ctrl_range(priv, IMX214_MAX_FRAME_LENGTH);
 
-	dev_dbg(&client->dev, "%s++ enable %d\n", __func__, enable);
-	if (!enable)
-		return imx214_write_table(priv,
+		err = imx214_write_table(priv,
 			mode_table[IMX214_MODE_STOP_STREAM]);
+		if (err)
+			return err;
+
+		/*
+		 * Wait for one frame to make sure sensor is set to
+		 * software standby in V-blank
+		 *
+		 * frame_time = frame length rows * Tline
+		 * Tline = line length / pixel clock (in MHz)
+		 */
+		frame_time = priv->frame_length *
+			IMX214_DEFAULT_LINE_LENGTH / IMX214_DEFAULT_PIXEL_CLOCK;
+
+		usleep_range(frame_time, frame_time + 1000);
+		return 0;
+	}
 
-	err = imx214_write_table(priv, mode_table[IMX214_MODE_COMMON]);
+	// write the pll register
+	//err = imx214_write_table(priv, imx214_pll_1080mbps);
+	err = imx214_write_table(priv, imx214_pll_1200mbps);
+	//err = imx214_write_table(priv, mode_table_common);
 	if (err)
 		goto exit;
+
 	err = imx214_write_table(priv, mode_table[s_data->mode]);
 	if (err)
 		goto exit;
 
+
 	if (s_data->override_enable) {
-		/* write list of override regs for the asking frame length, */
 		/*
+		 * write list of override regs for the asking frame length,
 		 * coarse integration time, and gain. Failures to write
 		 * overrides are non-fatal
 		 */
@@ -467,14 +558,16 @@ static int imx214_s_stream(struct v4l2_subdev *sd, int enable)
 		err |= imx214_set_frame_length(priv, control.value);
 		if (err)
 			dev_dbg(&client->dev,
-				"%s: frame length override failed\n", __func__);
+				"%s: warning frame length override failed\n",
+				__func__);
 
 		control.id = TEGRA_CAMERA_CID_COARSE_TIME;
 		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
 		err |= imx214_set_coarse_time(priv, control.value);
 		if (err)
 			dev_dbg(&client->dev,
-				"%s: coarse time override failed\n", __func__);
+				"%s: warning coarse time override failed\n",
+				__func__);
 
 		control.id = TEGRA_CAMERA_CID_COARSE_TIME_SHORT;
 		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
@@ -489,31 +582,80 @@ static int imx214_s_stream(struct v4l2_subdev *sd, int enable)
 	if (err)
 		goto exit;
 
+	if (priv->pdata->v_flip) {
+		imx214_read_reg(priv->s_data, IMX214_TIMING_REG20, &val);
+		imx214_write_reg(priv->s_data, IMX214_TIMING_REG20,
+				 val | VERTICAL_FLIP);
+	}
+
+	if (priv->pdata->h_mirror) {
+		imx214_read_reg(priv->s_data, IMX214_TIMING_REG21, &val);
+		imx214_write_reg(priv->s_data, IMX214_TIMING_REG21,
+				 val | HORIZONTAL_MIRROR_MASK);
+	} else {
+		imx214_read_reg(priv->s_data, IMX214_TIMING_REG21, &val);
+		imx214_write_reg(priv->s_data, IMX214_TIMING_REG21,
+				 val & (~HORIZONTAL_MIRROR_MASK));
+	}
 	if (test_mode)
 		err = imx214_write_table(priv,
 			mode_table[IMX214_MODE_TEST_PATTERN]);
 
+	dev_dbg(&client->dev, "%s--\n", __func__);
 	return 0;
 exit:
 	dev_dbg(&client->dev, "%s: error setting stream\n", __func__);
 	return err;
 }
 
+static int imx214_g_input_status(struct v4l2_subdev *sd, u32 *status)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct imx214 *priv = (struct imx214 *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+
+	*status = pw->state == SWITCH_ON;
+	return 0;
+}
+
 static struct v4l2_subdev_video_ops imx214_subdev_video_ops = {
 	.s_stream	= imx214_s_stream,
-	.s_mbus_fmt	= camera_common_s_fmt,
-	.g_mbus_fmt	= camera_common_g_fmt,
-	.try_mbus_fmt	= camera_common_try_fmt,
-	.enum_mbus_fmt	= camera_common_enum_fmt,
 	.g_mbus_config	= camera_common_g_mbus_config,
+	.g_input_status = imx214_g_input_status,
 };
 
 static struct v4l2_subdev_core_ops imx214_subdev_core_ops = {
 	.s_power	= camera_common_s_power,
 };
 
+static int imx214_get_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	return camera_common_g_fmt(sd, &format->format);
+}
+
+static int imx214_set_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	int ret;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		ret = camera_common_try_fmt(sd, &format->format);
+	else
+		ret = camera_common_s_fmt(sd, &format->format);
+
+	return ret;
+}
+
 static struct v4l2_subdev_pad_ops imx214_subdev_pad_ops = {
+	.set_fmt = imx214_set_fmt,
+	.get_fmt = imx214_get_fmt,
 	.enum_mbus_code = camera_common_enum_mbus_code,
+	.enum_frame_size	= camera_common_enum_framesizes,
+	.enum_frame_interval	= camera_common_enum_frameintervals,
 };
 
 static struct v4l2_subdev_ops imx214_subdev_ops = {
@@ -523,7 +665,7 @@ static struct v4l2_subdev_ops imx214_subdev_ops = {
 };
 
 static struct of_device_id imx214_of_match[] = {
-	{ .compatible = "nvidia,imx214", },
+	{ .compatible = "sony,imx214", },
 	{ },
 };
 
@@ -540,17 +682,34 @@ static int imx214_set_group_hold(struct imx214 *priv)
 	int gh_prev = switch_ctrl_qmenu[priv->group_hold_prev];
 
 	if (priv->group_hold_en == true && gh_prev == SWITCH_OFF) {
+		/* enter group hold */
+
 		err = imx214_write_reg(priv->s_data,
 				       IMX214_GROUP_HOLD_ADDR, 0x1);
 		if (err)
 			goto fail;
+
 		priv->group_hold_prev = 1;
+
+		dev_dbg(&priv->i2c_client->dev,
+			 "%s: enter group hold\n", __func__);
 	} else if (priv->group_hold_en == false && gh_prev == SWITCH_ON) {
+		/* leave group hold */
+
 		err = imx214_write_reg(priv->s_data,
 				       IMX214_GROUP_HOLD_ADDR, 0x0);
 		if (err)
 			goto fail;
+/*
+		err = imx214_write_reg(priv->s_data,
+				       IMX214_GROUP_HOLD_ADDR, 0x61);
+		if (err)
+			goto fail;
+*/
 		priv->group_hold_prev = 0;
+
+		dev_dbg(&priv->i2c_client->dev,
+			 "%s: leave group hold\n", __func__);
 	}
 
 	return 0;
@@ -561,21 +720,23 @@ fail:
 	return err;
 }
 
-static int imx214_calculate_gain(u32 rep, int shift)
+static u16 imx214_to_real_gain(u32 rep, int shift)
 {
-	int gain;
+	u16 gain;
 	int gain_int;
 	int gain_dec;
 	int min_int = (1 << shift);
-	int denom;
 
-	/* shift indicates number of least significant bits
-	 * used for decimal representation of gain */
+	if (rep < IMX214_MIN_GAIN)
+		rep = IMX214_MIN_GAIN;
+	else if (rep > IMX214_MAX_GAIN)
+		rep = IMX214_MAX_GAIN;
+
 	gain_int = (int)(rep >> shift);
 	gain_dec = (int)(rep & ~(0xffff << shift));
 
-	denom = gain_int * min_int + gain_dec;
-	gain = 512 - ((512 * min_int + (denom - 1)) / denom);
+	/* derived from formulat gain = (x * 16 + 0.5) */
+	gain = ((gain_int * min_int + gain_dec) * 32 + min_int) / (2 * min_int);
 
 	return gain;
 }
@@ -583,35 +744,26 @@ static int imx214_calculate_gain(u32 rep, int shift)
 static int imx214_set_gain(struct imx214 *priv, s32 val)
 {
 	imx214_reg reg_list[2];
-	imx214_reg reg_list_short[2];
 	int err;
 	u16 gain;
-	int i = 0;
+	int i;
 
-	/* translate value */
-	gain = (u16)imx214_calculate_gain(val, IMX214_GAIN_SHIFT);
+	if (!priv->group_hold_prev)
+		imx214_set_group_hold(priv);
 
-	dev_dbg(&priv->i2c_client->dev,
-		 "%s: val: %d\n", __func__, gain);
+	/* translate value */
+	gain = imx214_to_real_gain((u32)val, IMX214_GAIN_SHIFT);
 
 	imx214_get_gain_regs(reg_list, gain);
-	imx214_get_gain_short_reg(reg_list_short, gain);
-	imx214_set_group_hold(priv);
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: gain %04x val: %04x\n", __func__, val, gain);
 
-	/* writing long gain */
 	for (i = 0; i < 2; i++) {
 		err = imx214_write_reg(priv->s_data, reg_list[i].addr,
 			 reg_list[i].val);
 		if (err)
 			goto fail;
 	}
-	/* writing short gain */
-	for (i = 0; i < 2; i++) {
-		err = imx214_write_reg(priv->s_data, reg_list_short[i].addr,
-			 reg_list_short[i].val);
-		if (err)
-			goto fail;
-	}
 
 	return 0;
 
@@ -621,20 +773,58 @@ fail:
 	return err;
 }
 
+static void imx214_update_ctrl_range(struct imx214 *priv, s32 frame_length)
+{
+	struct v4l2_ctrl *ctrl = NULL;
+	int ctrl_ids[2] = {TEGRA_CAMERA_CID_COARSE_TIME,
+			TEGRA_CAMERA_CID_COARSE_TIME_SHORT};
+	s32 max, min, def;
+	int i, j;
+
+	for (i = 0; i < ARRAY_SIZE(ctrl_ids); i++) {
+		for (j = 0; j < priv->numctrls; j++) {
+			if (priv->ctrls[j]->id == ctrl_ids[i]) {
+				ctrl = priv->ctrls[j];
+				break;
+			}
+		}
+
+		if (j == priv->numctrls) {
+			dev_err(&priv->i2c_client->dev,
+				"could not find ctrl %x\n",
+				ctrl_ids[i]);
+			continue;
+		}
+
+		max = frame_length - IMX214_MAX_COARSE_DIFF;
+		/* clamp the value in case above is negative */
+		max = clamp_val(max, IMX214_MIN_EXPOSURE_COARSE,
+			IMX214_MAX_EXPOSURE_COARSE);
+		min = IMX214_MIN_EXPOSURE_COARSE;
+		def = clamp_val(IMX214_DEFAULT_EXPOSURE_COARSE, min, max);
+		if (__v4l2_ctrl_modify_range(ctrl, min, max, 1, def))
+			dev_err(&priv->i2c_client->dev,
+				"ctrl %x: range update failed\n",
+				ctrl_ids[i]);
+	}
+
+}
+
 static int imx214_set_frame_length(struct imx214 *priv, s32 val)
 {
 	imx214_reg reg_list[2];
 	int err;
-	u16 frame_length;
-	int i = 0;
+	u32 frame_length;
+	int i;
 
-	frame_length = (u16)val;
+	if (!priv->group_hold_prev)
+		imx214_set_group_hold(priv);
 
-	dev_dbg(&priv->i2c_client->dev,
-		 "%s: val: %d\n", __func__, frame_length);
+	frame_length = (u32)val;
 
 	imx214_get_frame_length_regs(reg_list, frame_length);
-	imx214_set_group_hold(priv);
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: val: %d\n", __func__, frame_length);
 
 	for (i = 0; i < 2; i++) {
 		err = imx214_write_reg(priv->s_data, reg_list[i].addr,
@@ -643,6 +833,9 @@ static int imx214_set_frame_length(struct imx214 *priv, s32 val)
 			goto fail;
 	}
 
+	priv->frame_length = frame_length;
+
+	imx214_update_ctrl_range(priv, val);
 	return 0;
 
 fail:
@@ -653,20 +846,21 @@ fail:
 
 static int imx214_set_coarse_time(struct imx214 *priv, s32 val)
 {
-	imx214_reg reg_list[2];
+	imx214_reg reg_list[3];
 	int err;
-	u16 coarse_time;
-	int i = 0;
+	u32 coarse_time;
+	int i;
 
-	coarse_time = (u16)val;
+	if (!priv->group_hold_prev)
+		imx214_set_group_hold(priv);
 
-	dev_dbg(&priv->i2c_client->dev,
-		 "%s: val: %d\n", __func__, coarse_time);
+	coarse_time = (u32)val;
 
 	imx214_get_coarse_time_regs(reg_list, coarse_time);
-	imx214_set_group_hold(priv);
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: val: %d\n", __func__, coarse_time);
 
-	for (i = 0; i < 2; i++) {
+	for (i = 0; i < 3; i++) {
 		err = imx214_write_reg(priv->s_data, reg_list[i].addr,
 			 reg_list[i].val);
 		if (err)
@@ -683,12 +877,15 @@ fail:
 
 static int imx214_set_coarse_time_short(struct imx214 *priv, s32 val)
 {
-	imx214_reg reg_list[2];
+	imx214_reg reg_list[3];
 	int err;
 	struct v4l2_control hdr_control;
 	int hdr_en;
-	u16 coarse_time_short;
-	int i = 0;
+	u32 coarse_time_short;
+	int i;
+
+	if (!priv->group_hold_prev)
+		imx214_set_group_hold(priv);
 
 	/* check hdr enable ctrl */
 	hdr_control.id = TEGRA_CAMERA_CID_HDR_EN;
@@ -704,16 +901,14 @@ static int imx214_set_coarse_time_short(struct imx214 *priv, s32 val)
 	if (hdr_en == SWITCH_OFF)
 		return 0;
 
-	coarse_time_short = (u16)val;
+	coarse_time_short = (u32)val;
 
+	imx214_get_coarse_time_short_regs(reg_list, coarse_time_short);
 	dev_dbg(&priv->i2c_client->dev,
 		 "%s: val: %d\n", __func__, coarse_time_short);
 
-	imx214_get_coarse_time_short_regs(reg_list, coarse_time_short);
-	imx214_set_group_hold(priv);
-
-	for (i = 0; i < 2; i++) {
-		err  = imx214_write_reg(priv->s_data, reg_list[i].addr,
+	for (i = 0; i < 3; i++) {
+		err = imx214_write_reg(priv->s_data, reg_list[i].addr,
 			 reg_list[i].val);
 		if (err)
 			goto fail;
@@ -750,15 +945,9 @@ static int imx214_eeprom_device_init(struct imx214 *priv)
 	};
 	int i;
 	int err;
-	struct v4l2_ctrl *ctrl;
 
-	ctrl = v4l2_ctrl_find(&priv->ctrl_handler,
-			TEGRA_CAMERA_CID_EEPROM_DATA);
-	if (!ctrl) {
-		dev_err(&priv->i2c_client->dev,
-			"could not find device ctrl.\n");
+	if (!priv->pdata->has_eeprom)
 		return -EINVAL;
-	}
 
 	for (i = 0; i < IMX214_EEPROM_NUM_BLOCKS; i++) {
 		priv->eeprom[i].adap = i2c_get_adapter(
@@ -775,7 +964,6 @@ static int imx214_eeprom_device_init(struct imx214 *priv)
 		if (IS_ERR(priv->eeprom[i].regmap)) {
 			err = PTR_ERR(priv->eeprom[i].regmap);
 			imx214_eeprom_device_release(priv);
-			ctrl->flags = V4L2_CTRL_FLAG_DISABLED;
 			return err;
 		}
 	}
@@ -797,7 +985,7 @@ static int imx214_read_eeprom(struct imx214 *priv,
 	}
 
 	for (i = 0; i < IMX214_EEPROM_SIZE; i++)
-		sprintf(&ctrl->string[i*2], "%02x",
+		sprintf(&ctrl->p_new.p_char[i*2], "%02x",
 			priv->eeprom_buf[i]);
 	return 0;
 }
@@ -832,116 +1020,6 @@ static int imx214_write_eeprom(struct imx214 *priv,
 	return 0;
 }
 
-static int imx214_read_otp_page(struct imx214 *priv,
-				u8 *buf, int page, u16 addr, int size)
-{
-	u8 status;
-	int err;
-
-	err = imx214_write_reg(priv->s_data, IMX214_OTP_PAGE_NUM_ADDR, page);
-	if (err)
-		return err;
-	err = imx214_write_reg(priv->s_data, IMX214_OTP_CTRL_ADDR, 0x01);
-	if (err)
-		return err;
-	err = imx214_read_reg(priv->s_data, IMX214_OTP_STATUS_ADDR, &status);
-	if (err)
-		return err;
-	if (status == IMX214_OTP_STATUS_IN_PROGRESS) {
-		dev_err(&priv->i2c_client->dev,
-			"another OTP read in progress\n");
-		return err;
-	}
-
-	err = regmap_bulk_read(priv->regmap, addr, buf, size);
-	if (err)
-		return err;
-
-	err = imx214_read_reg(priv->s_data, IMX214_OTP_STATUS_ADDR, &status);
-	if (err)
-		return err;
-	if (status == IMX214_OTP_STATUS_READ_FAIL) {
-		dev_err(&priv->i2c_client->dev, "fuse id read error\n");
-		return err;
-	}
-
-	return 0;
-}
-
-static int imx214_otp_setup(struct imx214 *priv)
-{
-	int err;
-	int i;
-	struct v4l2_ctrl *ctrl;
-	u8 otp_buf[IMX214_OTP_SIZE];
-
-	err = camera_common_s_power(priv->subdev, true);
-	if (err)
-		return -ENODEV;
-
-	for (i = 0; i < IMX214_OTP_NUM_PAGES; i++) {
-		imx214_read_otp_page(priv,
-				   &otp_buf[i * IMX214_OTP_PAGE_SIZE],
-				   i,
-				   IMX214_OTP_PAGE_START_ADDR,
-				   IMX214_OTP_PAGE_SIZE);
-	}
-
-	ctrl = v4l2_ctrl_find(&priv->ctrl_handler, TEGRA_CAMERA_CID_OTP_DATA);
-	if (!ctrl) {
-		dev_err(&priv->i2c_client->dev,
-			"could not find device ctrl.\n");
-		return -EINVAL;
-	}
-
-	for (i = 0; i < IMX214_OTP_SIZE; i++)
-		sprintf(&ctrl->string[i*2], "%02x",
-			otp_buf[i]);
-	ctrl->cur.string = ctrl->string;
-
-	err = camera_common_s_power(priv->subdev, false);
-	if (err)
-		return -ENODEV;
-
-	return 0;
-}
-
-static int imx214_fuse_id_setup(struct imx214 *priv)
-{
-	int err;
-	int i;
-	struct v4l2_ctrl *ctrl;
-	u8 fuse_id[IMX214_FUSE_ID_SIZE];
-
-	err = camera_common_s_power(priv->subdev, true);
-	if (err)
-		return -ENODEV;
-
-	imx214_read_otp_page(priv,
-			   &fuse_id[0],
-			   IMX214_FUSE_ID_OTP_PAGE,
-			   IMX214_FUSE_ID_OTP_ROW_ADDR,
-			   IMX214_FUSE_ID_SIZE);
-
-	ctrl = v4l2_ctrl_find(&priv->ctrl_handler, TEGRA_CAMERA_CID_FUSE_ID);
-	if (!ctrl) {
-		dev_err(&priv->i2c_client->dev,
-			"could not find device ctrl.\n");
-		return -EINVAL;
-	}
-
-	for (i = 0; i < IMX214_FUSE_ID_SIZE; i++)
-		sprintf(&ctrl->string[i*2], "%02x",
-			fuse_id[i]);
-	ctrl->cur.string = ctrl->string;
-
-	err = camera_common_s_power(priv->subdev, false);
-	if (err)
-		return -ENODEV;
-
-	return 0;
-}
-
 static int imx214_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct imx214 *priv =
@@ -996,9 +1074,9 @@ static int imx214_s_ctrl(struct v4l2_ctrl *ctrl)
 		}
 		break;
 	case TEGRA_CAMERA_CID_EEPROM_DATA:
-		if (!ctrl->string[0])
+		if (!ctrl->p_new.p_char[0])
 			break;
-		err = imx214_write_eeprom(priv, ctrl->string);
+		err = imx214_write_eeprom(priv, ctrl->p_new.p_char);
 		if (err)
 			return err;
 		break;
@@ -1012,9 +1090,10 @@ static int imx214_s_ctrl(struct v4l2_ctrl *ctrl)
 	return err;
 }
 
-static int imx214_ctrls_init(struct imx214 *priv)
+static int imx214_ctrls_init(struct imx214 *priv, bool eeprom_ctrl)
 {
 	struct i2c_client *client = priv->i2c_client;
+	struct camera_common_data *common_data = priv->s_data;
 	struct v4l2_ctrl *ctrl;
 	int numctrls;
 	int err;
@@ -1026,6 +1105,17 @@ static int imx214_ctrls_init(struct imx214 *priv)
 	v4l2_ctrl_handler_init(&priv->ctrl_handler, numctrls);
 
 	for (i = 0; i < numctrls; i++) {
+		/*
+		 * Skip control 'TEGRA_CAMERA_CID_EEPROM_DATA'
+		 * if eeprom inint err
+		 */
+		if (ctrl_config_list[i].id == TEGRA_CAMERA_CID_EEPROM_DATA) {
+			if (!eeprom_ctrl) {
+				common_data->numctrls -= 1;
+				continue;
+			}
+		}
+
 		ctrl = v4l2_ctrl_new_custom(&priv->ctrl_handler,
 			&ctrl_config_list[i], NULL);
 		if (ctrl == NULL) {
@@ -1036,13 +1126,10 @@ static int imx214_ctrls_init(struct imx214 *priv)
 
 		if (ctrl_config_list[i].type == V4L2_CTRL_TYPE_STRING &&
 			ctrl_config_list[i].flags & V4L2_CTRL_FLAG_READ_ONLY) {
-			ctrl->string = devm_kzalloc(&client->dev,
+			ctrl->p_new.p_char = devm_kzalloc(&client->dev,
 				ctrl_config_list[i].max + 1, GFP_KERNEL);
-			if (!ctrl->string) {
-				dev_err(&client->dev,
-					"Failed to allocate otp data\n");
+			if (!ctrl->p_new.p_char)
 				return -ENOMEM;
-			}
 		}
 		priv->ctrls[i] = ctrl;
 	}
@@ -1063,20 +1150,6 @@ static int imx214_ctrls_init(struct imx214 *priv)
 		goto error;
 	}
 
-	err = imx214_otp_setup(priv);
-	if (err) {
-		dev_err(&client->dev,
-			"Error %d reading otp data\n", err);
-		goto error;
-	}
-
-	err = imx214_fuse_id_setup(priv);
-	if (err) {
-		dev_err(&client->dev,
-			"Error %d reading fuse id data\n", err);
-		goto error;
-	}
-
 	return 0;
 
 error:
@@ -1088,9 +1161,15 @@ MODULE_DEVICE_TABLE(of, imx214_of_match);
 
 static struct camera_common_pdata *imx214_parse_dt(struct i2c_client *client)
 {
-	struct device_node *np = client->dev.of_node;
+	struct device_node *node = client->dev.of_node;
 	struct camera_common_pdata *board_priv_pdata;
 	const struct of_device_id *match;
+	int gpio;
+	int err;
+	struct camera_common_pdata *ret = NULL;
+
+	if (!node)
+		return NULL;
 
 	match = of_match_device(imx214_of_match, &client->dev);
 	if (!match) {
@@ -1100,32 +1179,71 @@ static struct camera_common_pdata *imx214_parse_dt(struct i2c_client *client)
 
 	board_priv_pdata = devm_kzalloc(&client->dev,
 			   sizeof(*board_priv_pdata), GFP_KERNEL);
-	if (!board_priv_pdata) {
-		dev_err(&client->dev, "Failed to allocate pdata\n");
+	if (!board_priv_pdata)
 		return NULL;
+
+	err = camera_common_parse_clocks(&client->dev, board_priv_pdata);
+	if (err) {
+		dev_err(&client->dev, "Failed to find clocks\n");
+		goto error;
+	}
+
+	gpio = of_get_named_gpio(node, "pwdn-gpios", 0);
+	if (gpio < 0) {
+		if (gpio == -EPROBE_DEFER) {
+			ret = ERR_PTR(-EPROBE_DEFER);
+			goto error;
+		}
+		dev_err(&client->dev, "pwdn gpios not in DT\n");
+		goto error;
+	}
+	board_priv_pdata->pwdn_gpio = (unsigned int)gpio;
+
+	gpio = of_get_named_gpio(node, "reset-gpios", 0);
+	if (gpio < 0) {
+		/* reset-gpio is not absolutely needed */
+		if (gpio == -EPROBE_DEFER) {
+			ret = ERR_PTR(-EPROBE_DEFER);
+			goto error;
+		}
+		dev_dbg(&client->dev, "reset gpios not in DT\n");
+		gpio = 0;
 	}
+	board_priv_pdata->reset_gpio = (unsigned int)gpio;
 
-	of_property_read_string(np, "mclk", &board_priv_pdata->mclk_name);
-	board_priv_pdata->pwdn_gpio = of_get_named_gpio(np, "pwdn-gpios", 0);
-	board_priv_pdata->reset_gpio = of_get_named_gpio(np, "reset-gpios", 0);
-	board_priv_pdata->af_gpio = of_get_named_gpio(np, "af-gpios", 0);
+	board_priv_pdata->use_cam_gpio =
+		of_property_read_bool(node, "cam,use-cam-gpio");
 
-	of_property_read_string(np, "avdd-reg",
+	err = of_property_read_string(node, "avdd-reg",
 			&board_priv_pdata->regulators.avdd);
-	of_property_read_string(np, "dvdd-reg",
+	if (err) {
+		dev_err(&client->dev, "avdd-reg not in DT\n");
+		goto error;
+	}
+	err = of_property_read_string(node, "dvdd-reg",
 			&board_priv_pdata->regulators.dvdd);
-	of_property_read_string(np, "iovdd-reg",
-			&board_priv_pdata->regulators.iovdd);
+	if (err) {
+		dev_err(&client->dev, "dvdd-reg not in DT\n");
+		goto error;
+	}
 
+	board_priv_pdata->has_eeprom =
+		of_property_read_bool(node, "has-eeprom");
+	board_priv_pdata->v_flip = of_property_read_bool(node, "vertical-flip");
+	board_priv_pdata->h_mirror = of_property_read_bool(node,
+							 "horizontal-mirror");
 	return board_priv_pdata;
+
+error:
+	devm_kfree(&client->dev, board_priv_pdata);
+	return ret;
 }
 
 static int imx214_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	dev_dbg(&client->dev, "%s:\n", __func__);
-
 
+	dev_dbg(&client->dev, "%s:\n", __func__);
 	return 0;
 }
 
@@ -1152,21 +1270,17 @@ static int imx214_probe(struct i2c_client *client,
 
 	common_data = devm_kzalloc(&client->dev,
 			    sizeof(struct camera_common_data), GFP_KERNEL);
-	if (!common_data) {
-		dev_err(&client->dev, "unable to allocate memory!\n");
+	if (!common_data)
 		return -ENOMEM;
-	}
 
 	priv = devm_kzalloc(&client->dev,
 			    sizeof(struct imx214) + sizeof(struct v4l2_ctrl *) *
 			    ARRAY_SIZE(ctrl_config_list),
 			    GFP_KERNEL);
-	if (!priv) {
-		dev_err(&client->dev, "unable to allocate memory!\n");
+	if (!priv)
 		return -ENOMEM;
-	}
 
-	priv->regmap = devm_regmap_init_i2c(client, &sensor_regmap_config);
+	priv->regmap = devm_regmap_init_i2c(client, &imx214_regmap_config);
 	if (IS_ERR(priv->regmap)) {
 		dev_err(&client->dev,
 			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
@@ -1174,6 +1288,8 @@ static int imx214_probe(struct i2c_client *client,
 	}
 
 	priv->pdata = imx214_parse_dt(client);
+	if (PTR_ERR(priv->pdata) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
 	if (!priv->pdata) {
 		dev_err(&client->dev, "unable to get platform data\n");
 		return -EFAULT;
@@ -1181,12 +1297,12 @@ static int imx214_probe(struct i2c_client *client,
 
 	common_data->ops		= &imx214_common_ops;
 	common_data->ctrl_handler	= &priv->ctrl_handler;
-	common_data->i2c_client		= client;
-	common_data->frmfmt		= &imx214_frmfmt[0];
+	common_data->dev		= &client->dev;
+	common_data->frmfmt		= imx214_frmfmt;
 	common_data->colorfmt		= camera_common_find_datafmt(
 					  IMX214_DEFAULT_DATAFMT);
-	common_data->ctrls		= priv->ctrls;
 	common_data->power		= &priv->power;
+	common_data->ctrls		= priv->ctrls;
 	common_data->priv		= (void *)priv;
 	common_data->numctrls		= ARRAY_SIZE(ctrl_config_list);
 	common_data->numfmts		= ARRAY_SIZE(imx214_frmfmt);
@@ -1197,7 +1313,7 @@ static int imx214_probe(struct i2c_client *client,
 	common_data->fmt_height		= common_data->def_height;
 	common_data->def_clk_freq	= IMX214_DEFAULT_CLK_FREQ;
 
-	priv->i2c_client		= client;
+	priv->i2c_client = client;
 	priv->s_data			= common_data;
 	priv->subdev			= &common_data->subdev;
 	priv->subdev->dev		= &client->dev;
@@ -1213,21 +1329,22 @@ static int imx214_probe(struct i2c_client *client,
 		return err;
 	}
 
-	v4l2_i2c_subdev_init(priv->subdev, client, &imx214_subdev_ops);
 
-	err = imx214_ctrls_init(priv);
-	if (err)
-		return err;
+	v4l2_i2c_subdev_init(priv->subdev, client, &imx214_subdev_ops);
 
 	/* eeprom interface */
 	err = imx214_eeprom_device_init(priv);
-	if (err)
+	if (err && priv->pdata->has_eeprom)
 		dev_err(&client->dev,
-			"Failed to allocate eeprom register map: %d\n", err);
+			"Failed to allocate eeprom reg map: %d\n", err);
+
+	err = imx214_ctrls_init(priv, !err);
+	if (err)
+		return err;
 
 	priv->subdev->internal_ops = &imx214_subdev_internal_ops;
 	priv->subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
-		     V4L2_SUBDEV_FL_HAS_EVENTS;
+			       V4L2_SUBDEV_FL_HAS_EVENTS;
 
 #if defined(CONFIG_MEDIA_CONTROLLER)
 	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
@@ -1246,19 +1363,21 @@ static int imx214_probe(struct i2c_client *client,
 
 	dev_dbg(&client->dev, "Detected IMX214 sensor\n");
 
+
 	return 0;
 }
 
 static int
 imx214_remove(struct i2c_client *client)
 {
-	struct camera_common_data *s_data = to_camera_common_data(client);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
 	struct imx214 *priv = (struct imx214 *)s_data->priv;
 
 	v4l2_async_unregister_subdev(priv->subdev);
 #if defined(CONFIG_MEDIA_CONTROLLER)
 	media_entity_cleanup(&priv->subdev->entity);
 #endif
+
 	v4l2_ctrl_handler_free(&priv->ctrl_handler);
 	imx214_power_put(priv);
 	camera_common_cleanup(s_data);
diff --git a/drivers/media/i2c/imx214_mode_tbls.h b/drivers/media/i2c/imx214_mode_tbls.h
new file mode 100755
index 0000000..5abc1f5
--- /dev/null
+++ b/drivers/media/i2c/imx214_mode_tbls.h
@@ -0,0 +1,2888 @@
+/*
+ * imx214_mode_tbls.h - imx214 sensor mode tables
+ *
+ * Copyright (c) 2015-2017, NVIDIA CORPORATION, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __IMX214_TABLES__
+#define __IMX214_TABLES__
+
+#include <media/camera_common.h>
+
+#define IMX214_TABLE_WAIT_MS	0
+#define IMX214_TABLE_END	1
+#define IMX214_MAX_RETRIES	3
+#define IMX214_WAIT_MS		100
+
+#define imx214_reg struct reg_8
+
+static const imx214_reg imx214_start[] = {
+	{0x0100, 0x01}, /* mode select streaming on */
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg imx214_stop[] = {
+	{0x0100, 0x00}, /* mode select streaming on */
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg tp_colorbars[] = {
+	{0x0600, 0xff},
+	{0x0601, 0xff},
+
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg mode_table_common[] = {
+	/* software reset */
+
+	/* software standby settings */
+	{0x0100, 0x00},
+
+	/* ATR setting */
+	{0x9300, 0x02},
+
+	/* external clock setting */
+	{0x0136, 0x18},
+	{0x0137, 0x00},
+
+	/* global setting */
+	/* basic config */
+	{0x0101, 0x00},
+	{0x0105, 0x01},
+	{0x0106, 0x01},
+	{0x4550, 0x02},
+	{0x4601, 0x00},
+	{0x4642, 0x05},
+	{0x6227, 0x11},
+	{0x6276, 0x00},
+	{0x900E, 0x06},
+	{0xA802, 0x90},
+	{0xA803, 0x11},
+	{0xA804, 0x62},
+	{0xA805, 0x77},
+	{0xA806, 0xAE},
+	{0xA807, 0x34},
+	{0xA808, 0xAE},
+	{0xA809, 0x35},
+	{0xA80A, 0x62},
+	{0xA80B, 0x83},
+	{0xAE33, 0x00},
+
+  /* analog setting */
+	{0x4174, 0x00},
+	{0x4175, 0x11},
+	{0x4612, 0x29},
+	{0x461B, 0x12},
+	{0x461F, 0x06},
+	{0x4635, 0x07},
+	{0x4637, 0x30},
+	{0x463F, 0x18},
+	{0x4641, 0x0D},
+	{0x465B, 0x12},
+	{0x465F, 0x11},
+	{0x4663, 0x11},
+	{0x4667, 0x0F},
+	{0x466F, 0x0F},
+	{0x470E, 0x09},
+	{0x4909, 0xAB},
+	{0x490B, 0x95},
+	{0x4915, 0x5D},
+	{0x4A5F, 0xFF},
+	{0x4A61, 0xFF},
+	{0x4A73, 0x62},
+	{0x4A85, 0x00},
+	{0x4A87, 0xFF},
+
+	/* embedded data */
+	{0x5041, 0x04},
+	{0x583C, 0x04},
+	{0x620E, 0x04},
+	{0x6EB2, 0x01},
+	{0x6EB3, 0x00},
+	{0x9300, 0x02},
+
+	/* imagequality */
+	/* HDR setting */
+	{0x3001, 0x07},
+	{0x6D12, 0x3F},
+	{0x6D13, 0xFF},
+	{0x9344, 0x03},
+	{0x9706, 0x10},
+	{0x9707, 0x03},
+	{0x9708, 0x03},
+	{0x9E04, 0x01},
+	{0x9E05, 0x00},
+	{0x9E0C, 0x01},
+	{0x9E0D, 0x02},
+	{0x9E24, 0x00},
+	{0x9E25, 0x8C},
+	{0x9E26, 0x00},
+	{0x9E27, 0x94},
+	{0x9E28, 0x00},
+	{0x9E29, 0x96},
+
+	/* CNR parameter setting */
+	{0x69DB, 0x01},
+
+	/* Moire reduction */
+	{0x6957, 0x01},
+
+	/* image enhancment */
+	{0x6987, 0x17},
+	{0x698A, 0x03},
+	{0x698B, 0x03},
+
+	/* white balanace */
+	{0x0B8E, 0x01},
+	{0x0B8F, 0x00},
+	{0x0B90, 0x01},
+	{0x0B91, 0x00},
+	{0x0B92, 0x01},
+	{0x0B93, 0x00},
+	{0x0B94, 0x01},
+	{0x0B95, 0x00},
+
+	/* ATR setting */
+	{0x6E50, 0x00},
+	{0x6E51, 0x32},
+	{0x9340, 0x00},
+	{0x9341, 0x3C},
+	{0x9342, 0x03},
+	{0x9343, 0xFF},
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg imx214_pll_1080mbps[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{ 0x0301, 0x05 }, // vt pixel clock divider = 5
+	{ 0x0303, 0x02 }, // vt system clock divider = 2
+	{ 0x0305, 0x03 }, // pre pll clock divider = 3
+	{ 0x0306, 0x00 }, // pll mult 10:8 = 0
+	{ 0x0307, 0x87 }, // pll mult 0:7 = 135
+	{ 0x0309, 0x0a }, // output pixel clock divider = 10
+	{ 0x030B, 0x01 }, // output system clock div = 1 .. OPCLK = 24 / 3(pre_vt) * 135(mpy_vt) / 1(op_sys_div) / 10(op_x_div) = 108MHz
+	{ 0x0310, 0x00 }, // PLL multiple driver = 0 -> 1 PLL control
+	{ 0x0820, 0x10 }, // target freq 31:24 = 16
+	{ 0x0821, 0xe0 }, // 23:16 = 224
+	{ 0x0822, 0x66 }, // 15:8 = 102
+	{ 0x0823, 0x66 }, // 7:0 = 102 ... target freq = 283141734
+	{ 0x3A03, 0x09 },
+	{ 0x3A04, 0x40 },
+	{ 0x3A05, 0x01 },
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg imx214_pll_1200mbps[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{ 0x0301, 0x05 }, // vt pixel clock divider = 5
+	{ 0x0303, 0x02 }, // vt system clock divider = 2
+	{ 0x0305, 0x03 }, // pre pll clock divider = 3
+	{ 0x0306, 0x00 }, // pll mult 10:8 = 0
+	{ 0x0307, 0x96 }, // pll mult 0:7 = 150
+	{ 0x0309, 0x0a }, // output pixel clock divider = 10
+	{ 0x030B, 0x01 }, // output system clock div = 1 .. OPCLK = 24 / 3(pre_vt) * 150(mpy_vt) / 1(op_sys_div) / 10(op_x_div) = 120MHz
+	{ 0x0310, 0x00 }, // PLL multiple driver = 0 -> 1 PLL control
+	{ 0x0820, 0x12 }, // target freq 31:24 = 18
+	{ 0x0821, 0xc0 }, // 23:16 = 192
+	{ 0x0822, 0x66 }, // 15:8 = 102
+	{ 0x0823, 0x66 }, // 7:0 = 102 ... target freq = 314599014
+	{ 0x3A03, 0x09 },
+	{ 0x3A04, 0x40 },
+	{ 0x3A05, 0x01 },
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg mode_4096x2304[] = {
+	{0x0114, 0x03},
+	{0x0220, 0x00},
+	{0x0221, 0x11},
+	{0x0222, 0x01},
+	{0x0340, 0x0C},
+	{0x0341, 0x7A},
+	{0x0342, 0x13},
+	{0x0343, 0x90},
+	{0x0344, 0x00},
+	{0x0345, 0x38},
+	{0x0346, 0x01},
+	{0x0347, 0x98},
+	{0x0348, 0x10},
+	{0x0349, 0x37},
+	{0x034A, 0x0A},
+	{0x034B, 0x97},
+	{0x0381, 0x01},
+	{0x0383, 0x01},
+	{0x0385, 0x01},
+	{0x0387, 0x01},
+	{0x0900, 0x00},
+	{0x0901, 0x00},
+	{0x0902, 0x00},
+	{0x3000, 0x35},
+	{0x3054, 0x01},
+	{0x305C, 0x11},
+
+	{0x0112, 0x0A},
+	{0x0113, 0x0A},
+	{0x034C, 0x10},
+	{0x034D, 0x00},
+	{0x034E, 0x09},
+	{0x034F, 0x00},
+	{0x0401, 0x00},
+	{0x0404, 0x00},
+	{0x0405, 0x10},
+	{0x0408, 0x00},
+	{0x0409, 0x00},
+	{0x040A, 0x00},
+	{0x040B, 0x00},
+	{0x040C, 0x10},
+	{0x040D, 0x00},
+	{0x040E, 0x09},
+	{0x040F, 0x00},
+
+	{0x0301, 0x05},
+	{0x0303, 0x02},
+	{0x0305, 0x03},
+	{0x0306, 0x00},
+	{0x0307, 0x96},
+	{0x0309, 0x0A},
+	{0x030B, 0x01},
+	{0x0310, 0x00},
+
+	{0x0820, 0x12},
+	{0x0821, 0xC0},
+	{0x0822, 0x00},
+	{0x0823, 0x00},
+
+	{0x3A03, 0x09},
+	{0x3A04, 0x50},
+	{0x3A05, 0x01},
+
+	{0x0B06, 0x01},
+	{0x30A2, 0x00},
+
+	{0x30B4, 0x00},
+
+	{0x3A02, 0xFF},
+
+	{0x3011, 0x00},
+	{0x3013, 0x01},
+
+	{0x0202, 0x0C},
+	{0x0203, 0x70},
+	{0x0224, 0x01},
+	{0x0225, 0xF4},
+
+	{0x0204, 0x00},
+	{0x0205, 0x00},
+	{0x020E, 0x01},
+	{0x020F, 0x00},
+	{0x0210, 0x01},
+	{0x0211, 0x00},
+	{0x0212, 0x01},
+	{0x0213, 0x00},
+	{0x0214, 0x01},
+	{0x0215, 0x00},
+	{0x0216, 0x00},
+	{0x0217, 0x00},
+
+	{0x4170, 0x00},
+	{0x4171, 0x10},
+	{0x4176, 0x00},
+	{0x4177, 0x3C},
+	{0xAE20, 0x04},
+	{0xAE21, 0x5C},
+
+	{IMX214_TABLE_WAIT_MS, 10},
+	{0x0138, 0x01},
+
+	/* stream on */
+	{0x0100, 0x01},
+	{IMX214_TABLE_END, 0x00}
+};
+
+//	{ 0x0103, 0x01 },
+static const imx214_reg mode_4208x3120[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{ 0x0100, 0x00 },
+	{ 0x0136, 0x18 }, /*24Mhz*/
+	{ 0x0137, 0x00 },
+	{ 0x0101, 0x00 },
+	{ 0x0105, 0x01 }, // switched from 0x01 to 0x00
+	{ 0x5041, 0x04 }, // no EMD
+	{ 0x0138, 0x01 },
+	{ 0x0106, 0x01 },
+	{ 0x4550, 0x02 },
+	{ 0x4601, 0x00 },
+	{ 0x4642, 0x05 },
+	{ 0x6227, 0x11 },
+	{ 0x6276, 0x00 },
+	{ 0x900E, 0x06 },
+	{ 0xA802, 0x90 },
+	{ 0xA803, 0x11 },
+	{ 0xA804, 0x62 },
+	{ 0xA805, 0x77 },
+	{ 0xA806, 0xAE },
+	{ 0xA807, 0x34 },
+	{ 0xA808, 0xAE },
+	{ 0xA809, 0x35 },
+	{ 0xA80A, 0x62 },
+	{ 0xA80B, 0x83 },
+	{ 0xAE33, 0x00 },
+	{ 0x4174, 0x00 },
+	{ 0x4175, 0x11 },
+	{ 0x4612, 0x29 },
+	{ 0x461B, 0x12 },
+	{ 0x461F, 0x06 },
+	{ 0x4635, 0x07 },
+	{ 0x4637, 0x30 },
+	{ 0x463F, 0x18 },
+	{ 0x4641, 0x0D },
+	{ 0x465B, 0x12 },
+	{ 0x465F, 0x11 },
+	{ 0x4663, 0x11 },
+	{ 0x4667, 0x0F },
+	{ 0x466F, 0x0F },
+	{ 0x470E, 0x09 },
+	{ 0x4909, 0xAB },
+	{ 0x490B, 0x95 },
+	{ 0x4915, 0x5D },
+	{ 0x4A5F, 0xFF },
+	{ 0x4A61, 0xFF },
+	{ 0x4A73, 0x62 },
+	{ 0x4A85, 0x00 },
+	{ 0x4A87, 0xFF },
+	{ 0x583C, 0x04 },
+	{ 0x620E, 0x04 },
+	{ 0x6EB2, 0x01 },
+	{ 0x6EB3, 0x00 },
+	{ 0x9300, 0x02 }, // end of power up
+	{ 0x0114, 0x03 },
+	{ 0x0220, 0x00 },
+	{ 0x0221, 0x11 },
+	{ 0x0222, 0x01 },
+	{ 0x0344, 0x00 },
+	{ 0x0345, 0x00 },
+	{ 0x0346, 0x00 },
+	{ 0x0347, 0x00 },
+	{ 0x0348, 0x10 },
+	{ 0x0349, 0x6F },
+	{ 0x034A, 0x0C },
+	{ 0x034B, 0x2F },
+	{ 0x0381, 0x01 },
+	{ 0x0383, 0x01 },
+	{ 0x0385, 0x01 },
+	{ 0x0387, 0x01 },
+	{ 0x0900, 0x00 },
+	{ 0x0901, 0x00 },
+	{ 0x0902, 0x00 },
+	{ 0x3000, 0x35 },
+	{ 0x3054, 0x01 },
+	{ 0x305C, 0x11 },
+	{ 0x034C, 0x10 },
+	{ 0x034D, 0x70 },
+	{ 0x034E, 0x0C },
+	{ 0x034F, 0x30 },
+	{ 0x0401, 0x00 },
+	{ 0x0404, 0x00 },
+	{ 0x0405, 0x10 },
+	{ 0x0408, 0x00 },
+	{ 0x0409, 0x00 },
+	{ 0x040A, 0x00 },
+	{ 0x040B, 0x00 },
+	{ 0x040C, 0x10 },
+	{ 0x040D, 0x70 },
+	{ 0x040E, 0x0C },
+	{ 0x040F, 0x30 },
+	{ 0x3A03, 0x09 },
+	{ 0x3A04, 0x40 },
+	{ 0x3A05, 0x01 },
+	{ 0x0B06, 0x01 },
+	{ 0x30A2, 0x00 },
+	{ 0x30B4, 0x00 },
+	{ 0x3A02, 0xFF },
+	{ 0x3011, 0x00 },
+	{ 0x3013, 0x01 },
+	{ 0x0224, 0x01 },
+	{ 0x0225, 0xF4 },
+	{ 0x020E, 0x01 },
+	{ 0x020F, 0x00 },
+	{ 0x0210, 0x01 },
+	{ 0x0211, 0x00 },
+	{ 0x0212, 0x01 },
+	{ 0x0213, 0x00 },
+	{ 0x0214, 0x01 },
+	{ 0x0215, 0x00 },
+	{ 0x0216, 0x00 },
+	{ 0x0217, 0x00 },
+	{ 0x4170, 0x00 },
+	{ 0x4171, 0x10 },
+	{ 0x4176, 0x00 },
+	{ 0x4177, 0x3C },
+	{ 0xAE20, 0x04 },
+	{ 0xAE21, 0x5C },
+	{ 0x0138, 0x01 },
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg mode_2104x1560[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{ 0x0100, 0x00 },
+	{ 0x0136, 0x18 }, /*24Mhz*/
+	{ 0x0137, 0x00 },
+	{ 0x0101, 0x00 },
+	{ 0x0105, 0x01 }, // switched from 0x01 to 0x00
+	{ 0x5041, 0x04 }, // no EMD
+	{ 0x0138, 0x01 },
+	{ 0x0106, 0x01 },
+	{ 0x4550, 0x02 },
+	{ 0x4601, 0x00 },
+	{ 0x4642, 0x05 },
+	{ 0x6227, 0x11 },
+	{ 0x6276, 0x00 },
+	{ 0x900E, 0x06 },
+	{ 0xA802, 0x90 },
+	{ 0xA803, 0x11 },
+	{ 0xA804, 0x62 },
+	{ 0xA805, 0x77 },
+	{ 0xA806, 0xAE },
+	{ 0xA807, 0x34 },
+	{ 0xA808, 0xAE },
+	{ 0xA809, 0x35 },
+	{ 0xA80A, 0x62 },
+	{ 0xA80B, 0x83 },
+	{ 0xAE33, 0x00 },
+	{ 0x4174, 0x00 },
+	{ 0x4175, 0x11 },
+	{ 0x4612, 0x29 },
+	{ 0x461B, 0x12 },
+	{ 0x461F, 0x06 },
+	{ 0x4635, 0x07 },
+	{ 0x4637, 0x30 },
+	{ 0x463F, 0x18 },
+	{ 0x4641, 0x0D },
+	{ 0x465B, 0x12 },
+	{ 0x465F, 0x11 },
+	{ 0x4663, 0x11 },
+	{ 0x4667, 0x0F },
+	{ 0x466F, 0x0F },
+	{ 0x470E, 0x09 },
+	{ 0x4909, 0xAB },
+	{ 0x490B, 0x95 },
+	{ 0x4915, 0x5D },
+	{ 0x4A5F, 0xFF },
+	{ 0x4A61, 0xFF },
+	{ 0x4A73, 0x62 },
+	{ 0x4A85, 0x00 },
+	{ 0x4A87, 0xFF },
+	{ 0x583C, 0x04 },
+	{ 0x620E, 0x04 },
+	{ 0x6EB2, 0x01 },
+	{ 0x6EB3, 0x00 },
+	{ 0x9300, 0x02 }, // end of power up
+	{ 0x0114, 0x03 },
+	{ 0x0220, 0x00 },
+	{ 0x0221, 0x11 },
+	{ 0x0222, 0x01 },
+	{ 0x0344, 0x00 },
+	{ 0x0345, 0x00 },
+	{ 0x0346, 0x00 },
+	{ 0x0347, 0x00 },
+	{ 0x0348, 0x10 },
+	{ 0x0349, 0x6F },
+	{ 0x034A, 0x0C },
+	{ 0x034B, 0x2F },
+	{ 0x0381, 0x01 },
+	{ 0x0383, 0x01 },
+	{ 0x0385, 0x01 },
+	{ 0x0387, 0x01 },
+	{ 0x0900, 0x01 },
+	{ 0x0901, 0x22 },
+	{ 0x0902, 0x02 },
+	{ 0x3000, 0x35 },
+	{ 0x3054, 0x01 },
+	{ 0x305C, 0x11 },
+	{ 0x034C, 0x08 },
+	{ 0x034D, 0x38 },
+	{ 0x034E, 0x06 },
+	{ 0x034F, 0x18 },
+	{ 0x0401, 0x00 },
+	{ 0x0404, 0x00 },
+	{ 0x0405, 0x10 },
+	{ 0x0408, 0x00 },
+	{ 0x0409, 0x00 },
+	{ 0x040A, 0x00 },
+	{ 0x040B, 0x00 },
+	{ 0x040C, 0x08 },
+	{ 0x040D, 0x38 },
+	{ 0x040E, 0x06 },
+	{ 0x040F, 0x18 },
+	{ 0x0B06, 0x01 },
+	{ 0x30A2, 0x00 },
+	{ 0x30B4, 0x00 },
+	{ 0x3A02, 0xFF },
+	{ 0x3011, 0x00 },
+	{ 0x3013, 0x01 },
+	{ 0x0224, 0x01 },
+	{ 0x0225, 0xF4 },
+	{ 0x020E, 0x01 },
+	{ 0x020F, 0x00 },
+	{ 0x0210, 0x01 },
+	{ 0x0211, 0x00 },
+	{ 0x0212, 0x01 },
+	{ 0x0213, 0x00 },
+	{ 0x0214, 0x01 },
+	{ 0x0215, 0x00 },
+	{ 0x0216, 0x00 },
+	{ 0x0217, 0x00 },
+	{ 0x4170, 0x00 },
+	{ 0x4171, 0x10 },
+	{ 0x4176, 0x00 },
+	{ 0x4177, 0x3C },
+	{ 0xAE20, 0x04 },
+	{ 0xAE21, 0x5C },
+	{ 0x0138, 0x01 },
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg mode_1920x1080[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{ 0x0100, 0x00 },
+	{ 0x0136, 0x18 }, /*24Mhz*/
+	{ 0x0137, 0x00 },
+	{ 0x0101, 0x00 },
+	{ 0x0105, 0x01 }, // switched from 0x01 to 0x00
+	{ 0x5041, 0x04 }, // no EMD
+	{ 0x0138, 0x01 },
+	{ 0x0106, 0x01 },
+	{ 0x4550, 0x02 },
+	{ 0x4601, 0x00 },
+	{ 0x4642, 0x05 },
+	{ 0x6227, 0x11 },
+	{ 0x6276, 0x00 },
+	{ 0x900E, 0x06 },
+	{ 0xA802, 0x90 },
+	{ 0xA803, 0x11 },
+	{ 0xA804, 0x62 },
+	{ 0xA805, 0x77 },
+	{ 0xA806, 0xAE },
+	{ 0xA807, 0x34 },
+	{ 0xA808, 0xAE },
+	{ 0xA809, 0x35 },
+	{ 0xA80A, 0x62 },
+	{ 0xA80B, 0x83 },
+	{ 0xAE33, 0x00 },
+	{ 0x4174, 0x00 },
+	{ 0x4175, 0x11 },
+	{ 0x4612, 0x29 },
+	{ 0x461B, 0x12 },
+	{ 0x461F, 0x06 },
+	{ 0x4635, 0x07 },
+	{ 0x4637, 0x30 },
+	{ 0x463F, 0x18 },
+	{ 0x4641, 0x0D },
+	{ 0x465B, 0x12 },
+	{ 0x465F, 0x11 },
+	{ 0x4663, 0x11 },
+	{ 0x4667, 0x0F },
+	{ 0x466F, 0x0F },
+	{ 0x470E, 0x09 },
+	{ 0x4909, 0xAB },
+	{ 0x490B, 0x95 },
+	{ 0x4915, 0x5D },
+	{ 0x4A5F, 0xFF },
+	{ 0x4A61, 0xFF },
+	{ 0x4A73, 0x62 },
+	{ 0x4A85, 0x00 },
+	{ 0x4A87, 0xFF },
+	{ 0x583C, 0x04 },
+	{ 0x620E, 0x04 },
+	{ 0x6EB2, 0x01 },
+	{ 0x6EB3, 0x00 },
+	{ 0x9300, 0x02 }, // end of power up
+	{ 0x0114, 0x03 },
+	{ 0x0220, 0x00 },
+	{ 0x0221, 0x11 },
+	{ 0x0222, 0x01 },
+	{ 0x0344, 0x00 }, // image size
+	{ 0x0345, 0xB8 },
+	{ 0x0346, 0x01 },
+	{ 0x0347, 0xE0 },
+	{ 0x0348, 0x0F },
+	{ 0x0349, 0xB7 },
+	{ 0x034A, 0x0A },
+	{ 0x034B, 0x4F },
+	{ 0x0381, 0x01 },
+	{ 0x0383, 0x01 },
+	{ 0x0385, 0x01 },
+	{ 0x0387, 0x01 },
+	{ 0x0900, 0x01 }, // 2x2 binning
+	{ 0x0901, 0x22 },
+	{ 0x0902, 0x02 },
+	{ 0x3000, 0x35 },
+	{ 0x3054, 0x01 },
+	{ 0x305C, 0x11 },
+	{ 0x034C, 0x07 },
+	{ 0x034D, 0x80 },
+	{ 0x034E, 0x04 },
+	{ 0x034F, 0x38 },
+	{ 0x0401, 0x00 },
+	{ 0x0404, 0x00 },
+	{ 0x0405, 0x10 },
+	{ 0x0408, 0x00 },
+	{ 0x0409, 0x00 },
+	{ 0x040A, 0x00 },
+	{ 0x040B, 0x00 },
+	{ 0x040C, 0x07 },
+	{ 0x040D, 0x80 },
+	{ 0x040E, 0x04 },
+	{ 0x040F, 0x38 },
+	{ 0x3A03, 0x08 },
+	{ 0x3A04, 0x68 },
+	{ 0x3A05, 0x01 },
+	{ 0x0B06, 0x01 },
+	{ 0x30A2, 0x00 },
+	{ 0x30B4, 0x00 },
+	{ 0x3A02, 0xFF },
+	{ 0x3011, 0x00 },
+	{ 0x3013, 0x01 },
+	{ 0x0224, 0x01 },
+	{ 0x0225, 0xF4 },
+	{ 0x020E, 0x01 },
+	{ 0x020F, 0x00 },
+	{ 0x0210, 0x01 },
+	{ 0x0211, 0x00 },
+	{ 0x0212, 0x01 },
+	{ 0x0213, 0x00 },
+	{ 0x0214, 0x01 },
+	{ 0x0215, 0x00 },
+	{ 0x0216, 0x00 },
+	{ 0x0217, 0x00 },
+	{ 0x4170, 0x00 },
+	{ 0x4171, 0x10 },
+	{ 0x4176, 0x00 },
+	{ 0x4177, 0x3C },
+	{ 0xAE20, 0x04 },
+	{ 0xAE21, 0x5C },
+	{ 0x0138, 0x01 },
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg mode_1280x720[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{ 0x0100, 0x00 },
+	{ 0x0136, 0x18 }, /*24Mhz*/
+	{ 0x0137, 0x00 },
+	{ 0x0101, 0x00 },
+	{ 0x0105, 0x01 }, // switched from 0x01 to 0x00
+	{ 0x5041, 0x04 }, // no EMD
+	{ 0x0138, 0x01 },
+	{ 0x0106, 0x01 },
+	{ 0x4550, 0x02 },
+	{ 0x4601, 0x00 },
+	{ 0x4642, 0x05 },
+	{ 0x6227, 0x11 },
+	{ 0x6276, 0x00 },
+	{ 0x900E, 0x06 },
+	{ 0xA802, 0x90 },
+	{ 0xA803, 0x11 },
+	{ 0xA804, 0x62 },
+	{ 0xA805, 0x77 },
+	{ 0xA806, 0xAE },
+	{ 0xA807, 0x34 },
+	{ 0xA808, 0xAE },
+	{ 0xA809, 0x35 },
+	{ 0xA80A, 0x62 },
+	{ 0xA80B, 0x83 },
+	{ 0xAE33, 0x00 },
+	{ 0x4174, 0x00 },
+	{ 0x4175, 0x11 },
+	{ 0x4612, 0x29 },
+	{ 0x461B, 0x12 },
+	{ 0x461F, 0x06 },
+	{ 0x4635, 0x07 },
+	{ 0x4637, 0x30 },
+	{ 0x463F, 0x18 },
+	{ 0x4641, 0x0D },
+	{ 0x465B, 0x12 },
+	{ 0x465F, 0x11 },
+	{ 0x4663, 0x11 },
+	{ 0x4667, 0x0F },
+	{ 0x466F, 0x0F },
+	{ 0x470E, 0x09 },
+	{ 0x4909, 0xAB },
+	{ 0x490B, 0x95 },
+	{ 0x4915, 0x5D },
+	{ 0x4A5F, 0xFF },
+	{ 0x4A61, 0xFF },
+	{ 0x4A73, 0x62 },
+	{ 0x4A85, 0x00 },
+	{ 0x4A87, 0xFF },
+	{ 0x583C, 0x04 },
+	{ 0x620E, 0x04 },
+	{ 0x6EB2, 0x01 },
+	{ 0x6EB3, 0x00 },
+	{ 0x9300, 0x02 }, // end of power up
+	{ 0x0114, 0x03 },
+	{ 0x0220, 0x00 },
+	{ 0x0221, 0x11 },
+	{ 0x0222, 0x01 },
+    { 0x0344, 0x05 }, // image size
+	{ 0x0345, 0xB8 },
+	{ 0x0346, 0x04 },
+	{ 0x0347, 0xB0 },
+	{ 0x0348, 0x0A },
+	{ 0x0349, 0xB7 },
+	{ 0x034A, 0x07 },
+	{ 0x034B, 0x7F },
+	{ 0x0381, 0x01 },
+	{ 0x0383, 0x01 },
+	{ 0x0385, 0x01 },
+	{ 0x0387, 0x01 },
+	{ 0x0900, 0x00 }, // no binning
+	{ 0x0901, 0x00 },
+	{ 0x0902, 0x00 },
+	{ 0x3000, 0x35 },
+	{ 0x3054, 0x01 },
+	{ 0x305C, 0x11 },
+	{ 0x034C, 0x05 },
+	{ 0x034D, 0x00 },
+	{ 0x034E, 0x02 },
+	{ 0x034F, 0xD0 },
+	{ 0x0401, 0x00 },
+	{ 0x0404, 0x00 },
+	{ 0x0405, 0x10 },
+	{ 0x0408, 0x00 },
+	{ 0x0409, 0x00 },
+	{ 0x040A, 0x00 },
+	{ 0x040B, 0x00 },
+	{ 0x040C, 0x05 },
+	{ 0x040D, 0x00 },
+	{ 0x040E, 0x02 },
+	{ 0x040F, 0xD0 },
+	{ 0x3A03, 0x02 },
+	{ 0x3A04, 0xF8 },
+	{ 0x3A05, 0x00 },
+	{ 0x0B06, 0x01 },
+	{ 0x30A2, 0x00 },
+	{ 0x30B4, 0x00 },
+	{ 0x3A02, 0xFF },
+	{ 0x3011, 0x00 },
+	{ 0x3013, 0x01 },
+	{ 0x0224, 0x01 },
+	{ 0x0225, 0xF4 },
+	{ 0x020E, 0x01 },
+	{ 0x020F, 0x00 },
+	{ 0x0210, 0x01 },
+	{ 0x0211, 0x00 },
+	{ 0x0212, 0x01 },
+	{ 0x0213, 0x00 },
+	{ 0x0214, 0x01 },
+	{ 0x0215, 0x00 },
+	{ 0x0216, 0x00 },
+	{ 0x0217, 0x00 },
+	{ 0x4170, 0x00 },
+	{ 0x4171, 0x10 },
+	{ 0x4176, 0x00 },
+	{ 0x4177, 0x3C },
+	{ 0xAE20, 0x04 },
+	{ 0xAE21, 0x5C },
+	{ 0x0138, 0x01 },
+	{IMX214_TABLE_END, 0x00},
+};
+
+static const imx214_reg mode_2592x1944[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3090, 0x02},
+	{0x3091, 0x0e},
+	{0x3092, 0x00},
+	{0x3093, 0x00},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x18},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x02},
+	{0x3802, 0x00},
+	{0x3803, 0x02},
+	{0x3804, 0x0a},
+	{0x3805, 0x41},
+	{0x3806, 0x07},
+	{0x3807, 0xa5},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x07},
+	{0x380b, 0x98},
+	{0x380c, 0x0a},
+	{0x380d, 0x80},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x1e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3d00, 0x00},
+	{0x3d01, 0x00},
+	{0x3d02, 0x00},
+	{0x3d03, 0x00},
+	{0x3d04, 0x00},
+	{0x3d05, 0x00},
+	{0x3d06, 0x00},
+	{0x3d07, 0x00},
+	{0x3d08, 0x00},
+	{0x3d09, 0x00},
+	{0x3d0a, 0x00},
+	{0x3d0b, 0x00},
+	{0x3d0c, 0x00},
+	{0x3d0d, 0x00},
+	{0x3d0e, 0x00},
+	{0x3d0f, 0x00},
+	{0x3d80, 0x00},
+	{0x3d81, 0x00},
+	{0x3d84, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{IMX214_TABLE_END, 0x0000}
+};
+
+static const imx214_reg mode_2592x1458[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3400, 0x04},
+	{0x3401, 0x00},
+	{0x3402, 0x04},
+	{0x3403, 0x00},
+	{0x3404, 0x04},
+	{0x3405, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3600, 0xbc},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x44},
+	{0x3621, 0xb5},
+	{0x3622, 0x0c},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0xf4},
+	{0x3804, 0x0a},
+	{0x3805, 0x3f},
+	{0x3806, 0x06},
+	{0x3807, 0xb1},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x05},
+	{0x380b, 0xb2},
+	{0x380c, 0x0a},
+	{0x380d, 0x80},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x10},
+	{0x3812, 0x00},
+	{0x3813, 0x06},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x1e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0xfc},
+	{0x5781, 0x13},
+	{0x5782, 0x03},
+	{0x5786, 0x20},
+	{0x5787, 0x40},
+	{0x5788, 0x08},
+	{0x5789, 0x08},
+	{0x578a, 0x02},
+	{0x578b, 0x01},
+	{0x578c, 0x01},
+	{0x578d, 0x0c},
+	{0x578e, 0x02},
+	{0x578f, 0x01},
+	{0x5790, 0x01},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{IMX214_TABLE_END, 0x0000}
+};
+
+static const imx214_reg mode_1920x1080_old[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{0x0100, 0x00},/*, 0xIncluding, 0xsw, 0xreset, 0x*/
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0xf8},
+	{0x3804, 0x0a},
+	{0x3805, 0x3f},
+	{0x3806, 0x06},
+	{0x3807, 0xab},
+	{0x3808, 0x07},
+	{0x3809, 0x80},
+	{0x380a, 0x04},
+	{0x380b, 0x38},
+	{0x380c, 0x0a},
+	{0x380d, 0x80},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x1e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x80},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{IMX214_TABLE_END, 0x0000}
+};
+
+static const imx214_reg mode_1280x720_120fps[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x2e},
+	{0x3502, 0x80},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe6},
+	{0x3709, 0xc7},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0xf4},
+	{0x3804, 0x0a},
+	{0x3805, 0x3f},
+	{0x3806, 0x06},
+	{0x3807, 0xab},
+	{0x3808, 0x05},
+	{0x3809, 0x00},
+	{0x380a, 0x02},
+	{0x380b, 0xd0},
+	{0x380c, 0x06},
+	{0x380d, 0xd8},
+	{0x380e, 0x02},
+	{0x380f, 0xf8},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x31},
+	{0x3815, 0x31},
+	{0x3820, 0x04},
+	{0x3821, 0x1f},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x00},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{IMX214_TABLE_END, 0x0000}
+};
+
+static const imx214_reg mode_2592x1944_HDR_24fps[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x0103, 0x01},
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x02},
+	{0x3099, 0x16},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30b2, 0x00},
+	{0x30b3, 0x6e},
+	{0x30b4, 0x03},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x80},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x01},
+	{0x3508, 0x80},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x05},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xa8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x0c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x02},
+	{0x3802, 0x00},
+	{0x3803, 0x06},
+	{0x3804, 0x0a},
+	{0x3805, 0x41},
+	{0x3806, 0x07},
+	{0x3807, 0xa1},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x07},
+	{0x380b, 0x98},
+	{0x380c, 0x0e},
+	{0x380d, 0x70},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x10},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x9e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x09},
+	{0x3a05, 0xa9},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{IMX214_TABLE_END, 0x0000}
+};
+
+static const imx214_reg mode_1920x1080_HDR_30fps[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x0103, 0x01},
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x72},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x01},
+	{0x3508, 0x80},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x01},
+	{0x3801, 0x70},
+	{0x3802, 0x01},
+	{0x3803, 0xbc},
+	{0x3804, 0x09},
+	{0x3805, 0x0f},
+	{0x3806, 0x05},
+	{0x3807, 0xff},
+	{0x3808, 0x07},
+	{0x3809, 0x80},
+	{0x380a, 0x04},
+	{0x380b, 0x38},
+	{0x380c, 0x0b},
+	{0x380d, 0x40},
+	{0x380e, 0x07},
+	{0x380f, 0x3a},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x9e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x09},
+	{0x3a05, 0xa9},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{IMX214_TABLE_END, 0x0000}
+};
+
+static const imx214_reg mode_1280x720_HDR_60fps[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x0103, 0x01},
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x39},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x01},
+	{0x3508, 0x80},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x02},
+	{0x3801, 0xa8},
+	{0x3802, 0x02},
+	{0x3803, 0x68},
+	{0x3804, 0x07},
+	{0x3805, 0xb7},
+	{0x3806, 0x05},
+	{0x3807, 0x3b},
+	{0x3808, 0x05},
+	{0x3809, 0x00},
+	{0x380a, 0x02},
+	{0x380b, 0xd0},
+	{0x380c, 0x0b},
+	{0x380d, 0x40},
+	{0x380e, 0x03},
+	{0x380f, 0x9e},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x9e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x09},
+	{0x3a05, 0xa9},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{IMX214_TABLE_END, 0x0000}
+};
+
+static const imx214_reg mode_2592x1944_one_lane_15fps[] = {
+	{0x0100, 0x00},/* Including sw reset */
+	{0x0103, 0x01},
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x11},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x28},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x05},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x64},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3400, 0x04},
+	{0x3401, 0x00},
+	{0x3402, 0x04},
+	{0x3403, 0x00},
+	{0x3404, 0x04},
+	{0x3405, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x20},
+	{0x3600, 0xbc},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x44},
+	{0x3621, 0xb5},
+	{0x3622, 0x0c},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x0a},
+	{0x3805, 0x3f},
+	{0x3806, 0x07},
+	{0x3807, 0xa3},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x07},
+	{0x380b, 0x98},
+	{0x380c, 0x0a},
+	{0x380d, 0x80},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x1e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x2c},
+	{0x4831, 0x64},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0xfc},
+	{0x5781, 0x13},
+	{0x5782, 0x03},
+	{0x5786, 0x20},
+	{0x5787, 0x40},
+	{0x5788, 0x08},
+	{0x5789, 0x08},
+	{0x578a, 0x02},
+	{0x578b, 0x01},
+	{0x578c, 0x01},
+	{0x578d, 0x0c},
+	{0x578e, 0x02},
+	{0x578f, 0x01},
+	{0x5790, 0x01},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{0x0100, 0x01},
+	{0x3810, 0x00},
+	{0x3811, 0x10},
+	{0x3812, 0x00},
+	{0x3813, 0x06},
+	{IMX214_TABLE_END, 0x0000}
+};
+
+enum {
+	IMX214_MODE_4208X3120,
+	IMX214_MODE_2104X1560,
+	IMX214_MODE_1920X1080,
+	IMX214_MODE_1280X720,
+
+	IMX214_MODE_START_STREAM,
+	IMX214_MODE_STOP_STREAM,
+	IMX214_MODE_TEST_PATTERN
+};
+
+static const imx214_reg *mode_table[] = {
+	[IMX214_MODE_4208X3120]			= mode_4208x3120,
+	[IMX214_MODE_2104X1560]			= mode_2104x1560,
+	[IMX214_MODE_1920X1080]			= mode_1920x1080,
+	[IMX214_MODE_1280X720]			= mode_1280x720,
+
+	[IMX214_MODE_START_STREAM]		= imx214_start,
+	[IMX214_MODE_STOP_STREAM]		= imx214_stop,
+	[IMX214_MODE_TEST_PATTERN]		= tp_colorbars,
+};
+
+static const int imx214_15fps[] = {
+	15,
+};
+
+static const int imx214_24fps[] = {
+	24,
+};
+
+static const int imx214_30fps[] = {
+	30,
+};
+
+static const int imx214_60fps[] = {
+	60,
+};
+
+static const int imx214_120fps[] = {
+	120,
+};
+
+static const struct camera_common_frmfmt imx214_frmfmt[] = {
+	{{4208, 3120},	imx214_30fps,	1, 0,	IMX214_MODE_4208X3120},
+	{{2104, 1560},	imx214_30fps,	1, 0,	IMX214_MODE_2104X1560},
+	{{1920, 1080},	imx214_60fps,	1, 0,	IMX214_MODE_1920X1080},
+	{{1280, 720},	imx214_30fps,	1, 0,	IMX214_MODE_1280X720},
+};
+#endif  /* __IMX214_TABLES__ */
+
+	
\ No newline at end of file
diff --git a/drivers/media/i2c/ov5640.c b/drivers/media/i2c/ov5640.c
new file mode 100755
index 0000000..7864ee3
--- /dev/null
+++ b/drivers/media/i2c/ov5640.c
@@ -0,0 +1,1558 @@
+/*
+ * ov5640_v4l2.c - ov5640 sensor driver
+ *
+ * Copyright (c) 2013-2017, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#define DEBUG
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+
+#include <linux/seq_file.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+
+#include <media/tegra-v4l2-camera.h>
+#include <media/camera_common.h>
+#include <media/ov5640.h>
+
+#include "../platform/tegra/camera/camera_gpio.h"
+
+#include "ov5640_mode_tbls.h"
+
+#define OV5640_MAX_COARSE_DIFF		6
+
+#define OV5640_GAIN_SHIFT		8
+#define OV5640_MIN_GAIN		(1 << OV5640_GAIN_SHIFT)
+#define OV5640_MAX_GAIN		(16 << OV5640_GAIN_SHIFT)
+#define OV5640_MAX_UNREAL_GAIN	(0x0F80)
+#define OV5640_MIN_FRAME_LENGTH	(0x0)
+#define OV5640_MAX_FRAME_LENGTH	(0x7fff)
+#define OV5640_MIN_EXPOSURE_COARSE	(0x0002)
+#define OV5640_MAX_EXPOSURE_COARSE	\
+	(OV5640_MAX_FRAME_LENGTH-OV5640_MAX_COARSE_DIFF)
+
+#define OV5640_DEFAULT_LINE_LENGTH	(0x9c4)
+// #define OV5640_DEFAULT_PIXEL_CLOCK	(168)
+//#define OV5640_DEFAULT_PIXEL_CLOCK	(84)
+#define OV5640_DEFAULT_PIXEL_CLOCK	(420)
+
+#define OV5640_DEFAULT_GAIN		OV5640_MIN_GAIN
+#define OV5640_DEFAULT_FRAME_LENGTH	(0x0460)
+#define OV5640_DEFAULT_EXPOSURE_COARSE	\
+	(OV5640_DEFAULT_FRAME_LENGTH-OV5640_MAX_COARSE_DIFF)
+
+#define OV5640_DEFAULT_MODE	OV5640_MODE_1920X1080
+//#define OV5640_DEFAULT_HDR_MODE	OV5640_MODE_2592X1944_HDR
+#define OV5640_DEFAULT_WIDTH	1920
+#define OV5640_DEFAULT_HEIGHT	1080	
+//#define OV5640_DEFAULT_DATAFMT	MEDIA_BUS_FMT_UYVY8_2X8	
+#define OV5640_DEFAULT_DATAFMT	MEDIA_BUS_FMT_SBGGR10_1X10
+#define OV5640_DEFAULT_CLK_FREQ	24000000
+
+struct ov5640 {
+	struct camera_common_power_rail	power;
+	int				numctrls;
+	struct v4l2_ctrl_handler	ctrl_handler;
+	struct camera_common_eeprom_data eeprom[OV5640_EEPROM_NUM_BLOCKS];
+	u8				eeprom_buf[OV5640_EEPROM_SIZE];
+	struct i2c_client		*i2c_client;
+	struct v4l2_subdev		*subdev;
+	struct media_pad		pad;
+
+	s32				group_hold_prev;
+	u32				frame_length;
+	bool				group_hold_en;
+	struct regmap			*regmap;
+	struct camera_common_data	*s_data;
+	struct camera_common_pdata	*pdata;
+	struct v4l2_ctrl		*ctrls[];
+};
+
+static struct regmap_config ov5640_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+};
+
+static int ov5640_g_volatile_ctrl(struct v4l2_ctrl *ctrl);
+static int ov5640_s_ctrl(struct v4l2_ctrl *ctrl);
+static void ov5640_update_ctrl_range(struct ov5640 *priv, s32 frame_length);
+
+static const struct v4l2_ctrl_ops ov5640_ctrl_ops = {
+	.g_volatile_ctrl = ov5640_g_volatile_ctrl,
+	.s_ctrl		= ov5640_s_ctrl,
+};
+
+static struct v4l2_ctrl_config ctrl_config_list[] = {
+/* Do not change the name field for the controls! */
+	{
+		.ops = &ov5640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GAIN,
+		.name = "Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = OV5640_MIN_GAIN,
+		.max = OV5640_MAX_GAIN,
+		.def = OV5640_DEFAULT_GAIN,
+		.step = 1,
+	},
+	{
+		.ops = &ov5640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_FRAME_LENGTH,
+		.name = "Frame Length",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = OV5640_MIN_FRAME_LENGTH,
+		.max = OV5640_MAX_FRAME_LENGTH,
+		.def = OV5640_DEFAULT_FRAME_LENGTH,
+		.step = 1,
+	},
+	{
+		.ops = &ov5640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_COARSE_TIME,
+		.name = "Coarse Time",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = OV5640_MIN_EXPOSURE_COARSE,
+		.max = OV5640_MAX_EXPOSURE_COARSE,
+		.def = OV5640_DEFAULT_EXPOSURE_COARSE,
+		.step = 1,
+	},
+	{
+		.ops = &ov5640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_COARSE_TIME_SHORT,
+		.name = "Coarse Time Short",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = OV5640_MIN_EXPOSURE_COARSE,
+		.max = OV5640_MAX_EXPOSURE_COARSE,
+		.def = OV5640_DEFAULT_EXPOSURE_COARSE,
+		.step = 1,
+	},
+	{
+		.ops = &ov5640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GROUP_HOLD,
+		.name = "Group Hold",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &ov5640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_HDR_EN,
+		.name = "HDR enable",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &ov5640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_EEPROM_DATA,
+		.name = "EEPROM Data",
+		.type = V4L2_CTRL_TYPE_STRING,
+		.flags = V4L2_CTRL_FLAG_VOLATILE,
+		.min = 0,
+		.max = OV5640_EEPROM_STR_SIZE,
+		.step = 2,
+	},
+	{
+		.ops = &ov5640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_OTP_DATA,
+		.name = "OTP Data",
+		.type = V4L2_CTRL_TYPE_STRING,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY,
+		.min = 0,
+		.max = OV5640_OTP_STR_SIZE,
+		.step = 2,
+	},
+	{
+		.ops = &ov5640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_FUSE_ID,
+		.name = "Fuse ID",
+		.type = V4L2_CTRL_TYPE_STRING,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY,
+		.min = 0,
+		.max = OV5640_FUSE_ID_STR_SIZE,
+		.step = 2,
+	},
+};
+
+static inline void ov5640_get_frame_length_regs(ov5640_reg *regs,
+				u32 frame_length)
+{
+	regs->addr = OV5640_FRAME_LENGTH_ADDR_MSB;
+	regs->val = (frame_length >> 8) & 0xff;
+	(regs + 1)->addr = OV5640_FRAME_LENGTH_ADDR_LSB;
+	(regs + 1)->val = (frame_length) & 0xff;
+}
+
+
+static inline void ov5640_get_coarse_time_regs(ov5640_reg *regs,
+				u32 coarse_time)
+{
+	regs->addr = OV5640_COARSE_TIME_ADDR_1;
+	regs->val = (coarse_time >> 12) & 0xff;
+	(regs + 1)->addr = OV5640_COARSE_TIME_ADDR_2;
+	(regs + 1)->val = (coarse_time >> 4) & 0xff;
+	(regs + 2)->addr = OV5640_COARSE_TIME_ADDR_3;
+	(regs + 2)->val = (coarse_time & 0xf) << 4;
+}
+
+static inline void ov5640_get_coarse_time_short_regs(ov5640_reg *regs,
+				u32 coarse_time)
+{
+	regs->addr = OV5640_COARSE_TIME_SHORT_ADDR_1;
+	regs->val = (coarse_time >> 12) & 0xff;
+	(regs + 1)->addr = OV5640_COARSE_TIME_SHORT_ADDR_2;
+	(regs + 1)->val = (coarse_time >> 4) & 0xff;
+	(regs + 2)->addr = OV5640_COARSE_TIME_SHORT_ADDR_3;
+	(regs + 2)->val = (coarse_time & 0xf) << 4;
+}
+
+static inline void ov5640_get_gain_regs(ov5640_reg *regs,
+				u16 gain)
+{
+	regs->addr = OV5640_GAIN_ADDR_MSB;
+	regs->val = (gain >> 8) & 0xff;
+
+	(regs + 1)->addr = OV5640_GAIN_ADDR_LSB;
+	(regs + 1)->val = (gain) & 0xff;
+}
+
+static int test_mode;
+module_param(test_mode, int, 0644);
+
+static inline int ov5640_read_reg(struct camera_common_data *s_data,
+				u16 addr, u8 *val)
+{
+	struct ov5640 *priv = (struct ov5640 *)s_data->priv;
+	int err = 0;
+	u32 reg_val = 0;
+
+	err = regmap_read(priv->regmap, addr, &reg_val);
+	*val = reg_val & 0xFF;
+
+	return err;
+}
+
+static int ov5640_write_reg(struct camera_common_data *s_data, u16 addr, u8 val)
+{
+	int err;
+	struct ov5640 *priv = (struct ov5640 *)s_data->priv;
+
+	err = regmap_write(priv->regmap, addr, val);
+	if (err)
+		pr_err("%s:i2c write failed, %x = %x\n",
+			__func__, addr, val);
+
+	return err;
+}
+
+static int ov5640_write_table(struct ov5640 *priv,
+			      const ov5640_reg table[])
+{
+	return regmap_util_write_table_8(priv->regmap,
+					 table,
+					 NULL, 0,
+					 OV5640_TABLE_WAIT_MS,
+					 OV5640_TABLE_END);
+}
+
+static void ov5640_gpio_set(struct ov5640 *priv,
+			    unsigned int gpio, int val)
+{
+	if (priv->pdata && priv->pdata->use_cam_gpio)
+		cam_gpio_ctrl(&priv->i2c_client->dev, gpio, val, 1);
+	else {
+		if (gpio_cansleep(gpio))
+			gpio_set_value_cansleep(gpio, val);
+		else
+			//gpiod_set_value(gpio, val);
+			gpio_set_value(gpio, val);
+	}
+}
+
+static int ov5640_power_on(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct ov5640 *priv = (struct ov5640 *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+	u32 frame_time;
+
+	dev_dbg(&priv->i2c_client->dev, "%s: power on\n", __func__);
+
+	if (priv->pdata && priv->pdata->power_on) {
+		err = priv->pdata->power_on(pw);
+		if (err)
+			pr_err("%s failed.\n", __func__);
+		else
+			pw->state = SWITCH_ON;
+		return err;
+	}
+
+	/* sleeps calls in the sequence below are for internal device
+	 * signal propagation as specified by sensor vendor */
+
+	if (pw->avdd) {
+		err = regulator_enable(pw->avdd);
+		dev_dbg(&priv->i2c_client->dev, "%s: power on - enable avdd\n", __func__);
+	}
+	if (err)
+		goto ov5640_avdd_fail;
+
+	if (pw->dvdd) {
+		err = regulator_enable(pw->dvdd);
+		dev_dbg(&priv->i2c_client->dev, "%s: power on - enable dvdd\n", __func__);
+	}
+	if (err)
+		goto ov5640_dvdd_fail;
+
+	usleep_range(1, 2);
+	if (pw->pwdn_gpio)
+		ov5640_gpio_set(priv, pw->pwdn_gpio, 0);
+		// ov5640_gpio_set(priv, pw->pwdn_gpio, 1);
+
+	/*
+	 * datasheet 2.9: reset requires ~2ms settling time
+	 * a power on reset is generated after core power becomes stable
+	 */
+	usleep_range(2000, 2010);
+
+	if (pw->reset_gpio)
+//		ov5640_gpio_set(priv, pw->reset_gpio, 0);
+		ov5640_gpio_set(priv, pw->reset_gpio, 1);
+
+	/* datasheet fig 2-9: t3 */
+	usleep_range(2000, 2010);
+
+	pw->state = SWITCH_ON;
+
+	/* need SW standby LP11 for mipical.
+	 * sensor default is LP00, this will transition to LP11 */
+	ov5640_write_reg(s_data, 0x3008, 0x02);
+	ov5640_write_reg(s_data, 0x3008, 0x42);
+	/*
+	 * Sleep to allow SW reset to settle into LP11. After writing
+	 * 0x1, according to the datasheet, it could take the remainder
+	 * of the frame time to settle.  Streaming too soon after this
+	 * may have unintended consequences.
+	 */
+	frame_time = OV5640_DEFAULT_FRAME_LENGTH *
+			OV5640_DEFAULT_LINE_LENGTH / OV5640_DEFAULT_PIXEL_CLOCK;
+	usleep_range(frame_time, frame_time + 1000);
+
+	return 0;
+
+ov5640_dvdd_fail:
+	regulator_disable(pw->avdd);
+
+ov5640_avdd_fail:
+	pr_err("%s failed.\n", __func__);
+	return -ENODEV;
+}
+
+static int ov5640_power_off(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct ov5640 *priv = (struct ov5640 *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+
+	dev_dbg(&priv->i2c_client->dev, "%s: power off\n", __func__);
+
+	if (priv->pdata && priv->pdata->power_off) {
+		err = priv->pdata->power_off(pw);
+		if (!err) {
+			goto power_off_done;
+		} else {
+			pr_err("%s failed.\n", __func__);
+			return err;
+		}
+	}
+
+	/* sleeps calls in the sequence below are for internal device
+	 * signal propagation as specified by sensor vendor */
+
+	usleep_range(21, 25);
+	if (pw->pwdn_gpio)
+		ov5640_gpio_set(priv, pw->pwdn_gpio, 1);
+		// ov5640_gpio_set(priv, pw->pwdn_gpio, 0);
+	usleep_range(1, 2);
+	if (pw->reset_gpio)
+//		ov5640_gpio_set(priv, pw->reset_gpio, 1);
+		ov5640_gpio_set(priv, pw->reset_gpio, 0);
+
+	/* datasheet 2.9: reset requires ~2ms settling time*/
+	usleep_range(2000, 2010);
+
+	if (pw->dvdd)
+		regulator_disable(pw->dvdd);
+	if (pw->avdd)
+		regulator_disable(pw->avdd);
+
+power_off_done:
+	pw->state = SWITCH_OFF;
+	return 0;
+}
+
+static int ov5640_power_put(struct ov5640 *priv)
+{
+	struct camera_common_power_rail *pw = &priv->power;
+
+	if (unlikely(!pw))
+		return -EFAULT;
+
+	if (likely(pw->avdd))
+		regulator_put(pw->avdd);
+
+	if (likely(pw->dvdd))
+		regulator_put(pw->dvdd);
+
+	pw->avdd = NULL;
+	pw->dvdd = NULL;
+
+	if (priv->pdata && priv->pdata->use_cam_gpio)
+		cam_gpio_deregister(&priv->i2c_client->dev, pw->pwdn_gpio);
+	else {
+		gpio_free(pw->pwdn_gpio);
+		gpio_free(pw->reset_gpio);
+	}
+
+	return 0;
+}
+
+static int ov5640_power_get(struct ov5640 *priv)
+{
+	struct camera_common_power_rail *pw = &priv->power;
+	struct camera_common_pdata *pdata = priv->pdata;
+	const char *mclk_name;
+	const char *parentclk_name;
+	struct clk *parent;
+	int err = 0, ret = 0;
+
+	if (!pdata) {
+		dev_err(&priv->i2c_client->dev, "pdata missing\n");
+		return -EFAULT;
+	}
+
+	mclk_name = pdata->mclk_name ?
+		    pdata->mclk_name : "cam_mclk1";
+	pw->mclk = devm_clk_get(&priv->i2c_client->dev, mclk_name);
+	if (IS_ERR(pw->mclk)) {
+		dev_err(&priv->i2c_client->dev,
+			"unable to get clock %s\n", mclk_name);
+		return PTR_ERR(pw->mclk);
+	}
+
+	parentclk_name = pdata->parentclk_name;
+	if (parentclk_name) {
+		parent = devm_clk_get(&priv->i2c_client->dev, parentclk_name);
+		if (IS_ERR(parent)) {
+			dev_err(&priv->i2c_client->dev,
+				"unable to get parent clcok %s",
+				parentclk_name);
+		} else
+			clk_set_parent(pw->mclk, parent);
+	}
+
+
+	/* analog 2.8v */
+	err |= camera_common_regulator_get(&priv->i2c_client->dev,
+			&pw->avdd, pdata->regulators.avdd);
+
+	/* DVDD 1.5v */
+	err |= camera_common_regulator_get(&priv->i2c_client->dev,
+			&pw->dvdd, pdata->regulators.dvdd);
+
+	if (!err) {
+		pw->reset_gpio = pdata->reset_gpio;
+		pw->pwdn_gpio = pdata->pwdn_gpio;
+	}
+
+	if (pdata->use_cam_gpio) {
+		err = cam_gpio_register(&priv->i2c_client->dev, pw->pwdn_gpio);
+		if (err)
+			dev_err(&priv->i2c_client->dev,
+				"%s ERR can't register cam gpio %u!\n",
+				 __func__, pw->pwdn_gpio);
+	} else {
+		ret = gpio_request(pw->pwdn_gpio, "cam_pwdn_gpio");
+		if (ret < 0)
+			dev_dbg(&priv->i2c_client->dev,
+				"%s can't request pwdn_gpio %d\n",
+				__func__, ret);
+		ret = gpio_request(pw->reset_gpio, "cam_reset_gpio");
+		if (ret < 0)
+			dev_dbg(&priv->i2c_client->dev,
+				"%s can't request reset_gpio %d\n",
+				__func__, ret);
+	}
+
+
+	pw->state = SWITCH_OFF;
+	return err;
+}
+
+static int ov5640_set_gain(struct ov5640 *priv, s32 val);
+static int ov5640_set_frame_length(struct ov5640 *priv, s32 val);
+static int ov5640_set_coarse_time(struct ov5640 *priv, s32 val);
+static int ov5640_set_coarse_time_short(struct ov5640 *priv, s32 val);
+
+static int ov5640_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct ov5640 *priv = (struct ov5640 *)s_data->priv;
+	struct v4l2_control control;
+	int err;
+	u32 frame_time;
+	u8 val;
+
+	dev_dbg(&client->dev, "%s++\n", __func__);
+
+	if (!enable) {
+		ov5640_update_ctrl_range(priv, OV5640_MAX_FRAME_LENGTH);
+
+		err = ov5640_write_table(priv,
+			mode_table[OV5640_MODE_STOP_STREAM]);
+		if (err)
+			return err;
+
+		/*
+		 * Wait for one frame to make sure sensor is set to
+		 * software standby in V-blank
+		 *
+		 * frame_time = frame length rows * Tline
+		 * Tline = line length / pixel clock (in MHz)
+		 */
+		frame_time = priv->frame_length *
+			OV5640_DEFAULT_LINE_LENGTH / OV5640_DEFAULT_PIXEL_CLOCK;
+
+		usleep_range(frame_time, frame_time + 1000);
+		return 0;
+	}
+
+	err = ov5640_write_table(priv, mode_table[s_data->mode]);
+	if (err)
+		goto exit;
+
+
+	if (s_data->override_enable) {
+		/*
+		 * write list of override regs for the asking frame length,
+		 * coarse integration time, and gain. Failures to write
+		 * overrides are non-fatal
+		 */
+		control.id = TEGRA_CAMERA_CID_GAIN;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		err |= ov5640_set_gain(priv, control.value);
+		if (err)
+			dev_dbg(&client->dev, "%s: warning gain override failed\n",
+				__func__);
+
+		control.id = TEGRA_CAMERA_CID_FRAME_LENGTH;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		err |= ov5640_set_frame_length(priv, control.value);
+		if (err)
+			dev_dbg(&client->dev,
+				"%s: warning frame length override failed\n",
+				__func__);
+
+		control.id = TEGRA_CAMERA_CID_COARSE_TIME;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		err |= ov5640_set_coarse_time(priv, control.value);
+		if (err)
+			dev_dbg(&client->dev,
+				"%s: warning coarse time override failed\n",
+				__func__);
+
+		control.id = TEGRA_CAMERA_CID_COARSE_TIME_SHORT;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		err |= ov5640_set_coarse_time_short(priv, control.value);
+		if (err)
+			dev_dbg(&client->dev,
+				"%s: warning coarse time short override failed\n",
+				__func__);
+	}
+
+	err = ov5640_write_table(priv, mode_table[OV5640_MODE_START_STREAM]);
+	if (err)
+		goto exit;
+	if (priv->pdata->v_flip) {
+		ov5640_read_reg(priv->s_data, OV5640_TIMING_REG20, &val);
+		ov5640_write_reg(priv->s_data, OV5640_TIMING_REG20,
+				 val | VERTICAL_FLIP);
+	}
+	if (priv->pdata->h_mirror) {
+		ov5640_read_reg(priv->s_data, OV5640_TIMING_REG21, &val);
+		ov5640_write_reg(priv->s_data, OV5640_TIMING_REG21,
+				 val | HORIZONTAL_MIRROR_MASK);
+	} else {
+		ov5640_read_reg(priv->s_data, OV5640_TIMING_REG21, &val);
+		ov5640_write_reg(priv->s_data, OV5640_TIMING_REG21,
+				 val & (~HORIZONTAL_MIRROR_MASK));
+	}
+	if (test_mode)
+		err = ov5640_write_table(priv,
+			mode_table[OV5640_MODE_TEST_PATTERN]);
+
+	dev_dbg(&client->dev, "%s--\n", __func__);
+	return 0;
+exit:
+	dev_dbg(&client->dev, "%s: error setting stream\n", __func__);
+	return err;
+}
+
+static int ov5640_g_input_status(struct v4l2_subdev *sd, u32 *status)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct ov5640 *priv = (struct ov5640 *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+
+	*status = pw->state == SWITCH_ON;
+	return 0;
+}
+
+static struct v4l2_subdev_video_ops ov5640_subdev_video_ops = {
+	.s_stream	= ov5640_s_stream,
+	.g_mbus_config	= camera_common_g_mbus_config,
+	.g_input_status = ov5640_g_input_status,
+};
+
+static struct v4l2_subdev_core_ops ov5640_subdev_core_ops = {
+	.s_power	= camera_common_s_power,
+};
+
+static int ov5640_get_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	return camera_common_g_fmt(sd, &format->format);
+}
+
+static int ov5640_set_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	int ret;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		ret = camera_common_try_fmt(sd, &format->format);
+	else
+		ret = camera_common_s_fmt(sd, &format->format);
+
+	return ret;
+}
+
+static struct v4l2_subdev_pad_ops ov5640_subdev_pad_ops = {
+	.set_fmt = ov5640_set_fmt,
+	.get_fmt = ov5640_get_fmt,
+	.enum_mbus_code = camera_common_enum_mbus_code,
+	.enum_frame_size	= camera_common_enum_framesizes,
+	.enum_frame_interval	= camera_common_enum_frameintervals,
+};
+
+static struct v4l2_subdev_ops ov5640_subdev_ops = {
+	.core	= &ov5640_subdev_core_ops,
+	.video	= &ov5640_subdev_video_ops,
+	.pad	= &ov5640_subdev_pad_ops,
+};
+
+static struct of_device_id ov5640_of_match[] = {
+	{ .compatible = "nvidia,ov5640", },
+	{ },
+};
+
+static struct camera_common_sensor_ops ov5640_common_ops = {
+	.power_on = ov5640_power_on,
+	.power_off = ov5640_power_off,
+	.write_reg = ov5640_write_reg,
+	.read_reg = ov5640_read_reg,
+};
+
+static int ov5640_set_group_hold(struct ov5640 *priv)
+{
+	int err;
+	int gh_prev = switch_ctrl_qmenu[priv->group_hold_prev];
+
+	if (priv->group_hold_en == true && gh_prev == SWITCH_OFF) {
+		/* enter group hold */
+		err = ov5640_write_reg(priv->s_data,
+				       OV5640_GROUP_HOLD_ADDR, 0x01);
+		if (err)
+			goto fail;
+
+		priv->group_hold_prev = 1;
+
+		dev_dbg(&priv->i2c_client->dev,
+			 "%s: enter group hold\n", __func__);
+	} else if (priv->group_hold_en == false && gh_prev == SWITCH_ON) {
+		/* leave group hold */
+		err = ov5640_write_reg(priv->s_data,
+				       OV5640_GROUP_HOLD_ADDR, 0x11);
+		if (err)
+			goto fail;
+
+		err = ov5640_write_reg(priv->s_data,
+				       OV5640_GROUP_HOLD_ADDR, 0x61);
+		if (err)
+			goto fail;
+
+		priv->group_hold_prev = 0;
+
+		dev_dbg(&priv->i2c_client->dev,
+			 "%s: leave group hold\n", __func__);
+	}
+
+	return 0;
+
+fail:
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: Group hold control error\n", __func__);
+	return err;
+}
+
+static u16 ov5640_to_real_gain(u32 rep, int shift)
+{
+	u16 gain;
+	int gain_int;
+	int gain_dec;
+	int min_int = (1 << shift);
+
+	if (rep < OV5640_MIN_GAIN)
+		rep = OV5640_MIN_GAIN;
+	else if (rep > OV5640_MAX_GAIN)
+		rep = OV5640_MAX_GAIN;
+
+	gain_int = (int)(rep >> shift);
+	gain_dec = (int)(rep & ~(0xffff << shift));
+
+	/* derived from formulat gain = (x * 16 + 0.5) */
+	gain = ((gain_int * min_int + gain_dec) * 32 + min_int) / (2 * min_int);
+
+	return gain;
+}
+
+static int ov5640_set_gain(struct ov5640 *priv, s32 val)
+{
+	ov5640_reg reg_list[2];
+	int err;
+	u16 gain;
+	int i;
+
+	if (!priv->group_hold_prev)
+		ov5640_set_group_hold(priv);
+
+	/* translate value */
+	gain = ov5640_to_real_gain((u32)val, OV5640_GAIN_SHIFT);
+
+	ov5640_get_gain_regs(reg_list, gain);
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: gain %04x val: %04x\n", __func__, val, gain);
+
+	for (i = 0; i < 2; i++) {
+		err = ov5640_write_reg(priv->s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: GAIN control error\n", __func__);
+	return err;
+}
+
+static void ov5640_update_ctrl_range(struct ov5640 *priv, s32 frame_length)
+{
+	struct v4l2_ctrl *ctrl = NULL;
+	int ctrl_ids[2] = {TEGRA_CAMERA_CID_COARSE_TIME,
+			TEGRA_CAMERA_CID_COARSE_TIME_SHORT};
+	s32 max, min, def;
+	int i, j;
+
+	for (i = 0; i < ARRAY_SIZE(ctrl_ids); i++) {
+		for (j = 0; j < priv->numctrls; j++) {
+			if (priv->ctrls[j]->id == ctrl_ids[i]) {
+				ctrl = priv->ctrls[j];
+				break;
+			}
+		}
+
+		if (j == priv->numctrls) {
+			dev_err(&priv->i2c_client->dev,
+				"could not find ctrl %x\n",
+				ctrl_ids[i]);
+			continue;
+		}
+
+		max = frame_length - OV5640_MAX_COARSE_DIFF;
+		/* clamp the value in case above is negative */
+		max = clamp_val(max, OV5640_MIN_EXPOSURE_COARSE,
+			OV5640_MAX_EXPOSURE_COARSE);
+		min = OV5640_MIN_EXPOSURE_COARSE;
+		def = clamp_val(OV5640_DEFAULT_EXPOSURE_COARSE, min, max);
+		if (__v4l2_ctrl_modify_range(ctrl, min, max, 1, def))
+			dev_err(&priv->i2c_client->dev,
+				"ctrl %x: range update failed\n",
+				ctrl_ids[i]);
+	}
+
+}
+
+static int ov5640_set_frame_length(struct ov5640 *priv, s32 val)
+{
+	ov5640_reg reg_list[2];
+	int err;
+	u32 frame_length;
+	int i;
+
+	if (!priv->group_hold_prev)
+		ov5640_set_group_hold(priv);
+
+	frame_length = (u32)val;
+
+	ov5640_get_frame_length_regs(reg_list, frame_length);
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: val: %d\n", __func__, frame_length);
+
+	for (i = 0; i < 2; i++) {
+		err = ov5640_write_reg(priv->s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+	priv->frame_length = frame_length;
+
+	ov5640_update_ctrl_range(priv, val);
+	return 0;
+
+fail:
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: FRAME_LENGTH control error\n", __func__);
+	return err;
+}
+
+static int ov5640_set_coarse_time(struct ov5640 *priv, s32 val)
+{
+	ov5640_reg reg_list[3];
+	int err;
+	u32 coarse_time;
+	int i;
+
+	if (!priv->group_hold_prev)
+		ov5640_set_group_hold(priv);
+
+	coarse_time = (u32)val;
+
+	ov5640_get_coarse_time_regs(reg_list, coarse_time);
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: val: %d\n", __func__, coarse_time);
+
+	for (i = 0; i < 3; i++) {
+		err = ov5640_write_reg(priv->s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: COARSE_TIME control error\n", __func__);
+	return err;
+}
+
+static int ov5640_set_coarse_time_short(struct ov5640 *priv, s32 val)
+{
+	ov5640_reg reg_list[3];
+	int err;
+	struct v4l2_control hdr_control;
+	int hdr_en;
+	u32 coarse_time_short;
+	int i;
+
+	if (!priv->group_hold_prev)
+		ov5640_set_group_hold(priv);
+
+	/* check hdr enable ctrl */
+	hdr_control.id = TEGRA_CAMERA_CID_HDR_EN;
+
+	err = camera_common_g_ctrl(priv->s_data, &hdr_control);
+	if (err < 0) {
+		dev_err(&priv->i2c_client->dev,
+			"could not find device ctrl.\n");
+		return err;
+	}
+
+	hdr_en = switch_ctrl_qmenu[hdr_control.value];
+	if (hdr_en == SWITCH_OFF)
+		return 0;
+
+	coarse_time_short = (u32)val;
+
+	ov5640_get_coarse_time_short_regs(reg_list, coarse_time_short);
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: val: %d\n", __func__, coarse_time_short);
+
+	for (i = 0; i < 3; i++) {
+		err = ov5640_write_reg(priv->s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: COARSE_TIME_SHORT control error\n", __func__);
+	return err;
+}
+
+static int ov5640_eeprom_device_release(struct ov5640 *priv)
+{
+	int i;
+
+	for (i = 0; i < OV5640_EEPROM_NUM_BLOCKS; i++) {
+		if (priv->eeprom[i].i2c_client != NULL) {
+			i2c_unregister_device(priv->eeprom[i].i2c_client);
+			priv->eeprom[i].i2c_client = NULL;
+		}
+	}
+
+	return 0;
+}
+
+static int ov5640_eeprom_device_init(struct ov5640 *priv)
+{
+	char *dev_name = "eeprom_ov5640";
+	static struct regmap_config eeprom_regmap_config = {
+		.reg_bits = 8,
+		.val_bits = 8,
+	};
+	int i;
+	int err;
+
+	if (!priv->pdata->has_eeprom)
+		return -EINVAL;
+
+	for (i = 0; i < OV5640_EEPROM_NUM_BLOCKS; i++) {
+		priv->eeprom[i].adap = i2c_get_adapter(
+				priv->i2c_client->adapter->nr);
+		memset(&priv->eeprom[i].brd, 0, sizeof(priv->eeprom[i].brd));
+		strncpy(priv->eeprom[i].brd.type, dev_name,
+				sizeof(priv->eeprom[i].brd.type));
+		priv->eeprom[i].brd.addr = OV5640_EEPROM_ADDRESS + i;
+		priv->eeprom[i].i2c_client = i2c_new_device(
+				priv->eeprom[i].adap, &priv->eeprom[i].brd);
+
+		priv->eeprom[i].regmap = devm_regmap_init_i2c(
+			priv->eeprom[i].i2c_client, &eeprom_regmap_config);
+		if (IS_ERR(priv->eeprom[i].regmap)) {
+			err = PTR_ERR(priv->eeprom[i].regmap);
+			ov5640_eeprom_device_release(priv);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static int ov5640_read_eeprom(struct ov5640 *priv,
+				struct v4l2_ctrl *ctrl)
+{
+	int err, i;
+
+	for (i = 0; i < OV5640_EEPROM_NUM_BLOCKS; i++) {
+		err = regmap_bulk_read(priv->eeprom[i].regmap, 0,
+			&priv->eeprom_buf[i * OV5640_EEPROM_BLOCK_SIZE],
+			OV5640_EEPROM_BLOCK_SIZE);
+		if (err)
+			return err;
+	}
+
+	for (i = 0; i < OV5640_EEPROM_SIZE; i++)
+		sprintf(&ctrl->p_new.p_char[i*2], "%02x",
+			priv->eeprom_buf[i]);
+	return 0;
+}
+
+static int ov5640_write_eeprom(struct ov5640 *priv,
+				char *string)
+{
+	int err;
+	int i;
+	u8 curr[3];
+	unsigned long data;
+
+	for (i = 0; i < OV5640_EEPROM_SIZE; i++) {
+		curr[0] = string[i*2];
+		curr[1] = string[i*2+1];
+		curr[2] = '\0';
+
+		err = kstrtol(curr, 16, &data);
+		if (err) {
+			dev_err(&priv->i2c_client->dev,
+				"invalid eeprom string\n");
+			return -EINVAL;
+		}
+
+		priv->eeprom_buf[i] = (u8)data;
+		err = regmap_write(priv->eeprom[i >> 8].regmap,
+				   i & 0xFF, (u8)data);
+		if (err)
+			return err;
+		msleep(20);
+	}
+	return 0;
+}
+
+static int ov5640_read_otp_bank(struct ov5640 *priv,
+				u8 *buf, int bank, u16 addr, int size)
+{
+	int err;
+
+	/* sleeps calls in the sequence below are for internal device
+	 * signal propagation as specified by sensor vendor */
+
+	usleep_range(10000, 11000);
+	err = ov5640_write_table(priv, mode_table[OV5640_MODE_START_STREAM]);
+	if (err)
+		return err;
+
+	err = ov5640_write_reg(priv->s_data, OV5640_OTP_BANK_SELECT_ADDR,
+			       0xC0 | bank);
+	if (err)
+		return err;
+
+	err = ov5640_write_reg(priv->s_data, OV5640_OTP_LOAD_CTRL_ADDR, 0x01);
+	if (err)
+		return err;
+
+	usleep_range(10000, 11000);
+	err = regmap_bulk_read(priv->regmap, addr, buf, size);
+	if (err)
+		return err;
+
+	err = ov5640_write_table(priv,
+			mode_table[OV5640_MODE_STOP_STREAM]);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int ov5640_otp_setup(struct ov5640 *priv)
+{
+	int err;
+	int i;
+	struct v4l2_ctrl *ctrl;
+	u8 otp_buf[OV5640_OTP_SIZE];
+
+	err = camera_common_s_power(priv->subdev, true);
+	if (err)
+		return -ENODEV;
+
+	for (i = 0; i < OV5640_OTP_NUM_BANKS; i++) {
+		err = ov5640_read_otp_bank(priv,
+					&otp_buf[i * OV5640_OTP_BANK_SIZE],
+					i,
+					OV5640_OTP_BANK_START_ADDR,
+					OV5640_OTP_BANK_SIZE);
+		if (err) {
+			dev_err(&priv->i2c_client->dev,
+				"could not read otp bank\n");
+			goto ret;
+		}
+	}
+
+	ctrl = v4l2_ctrl_find(&priv->ctrl_handler, TEGRA_CAMERA_CID_OTP_DATA);
+	if (!ctrl) {
+		dev_err(&priv->i2c_client->dev,
+			"could not find device ctrl.\n");
+		err = -EINVAL;
+		goto ret;
+	}
+
+	for (i = 0; i < OV5640_OTP_SIZE; i++)
+		sprintf(&ctrl->p_new.p_char[i*2], "%02x",
+			otp_buf[i]);
+	ctrl->p_cur.p_char = ctrl->p_new.p_char;
+
+ret:
+	camera_common_s_power(priv->subdev, false);
+
+	return err;
+}
+
+static int ov5640_fuse_id_setup(struct ov5640 *priv)
+{
+	int err;
+	int i;
+	struct v4l2_ctrl *ctrl;
+	u8 fuse_id[OV5640_FUSE_ID_SIZE];
+
+	err = camera_common_s_power(priv->subdev, true);
+	if (err)
+		return -ENODEV;
+
+	err = ov5640_read_otp_bank(priv,
+				&fuse_id[0],
+				OV5640_FUSE_ID_OTP_BANK,
+				OV5640_FUSE_ID_OTP_START_ADDR,
+				OV5640_FUSE_ID_SIZE);
+	if (err) {
+		dev_err(&priv->i2c_client->dev,
+			"could not read otp bank\n");
+		goto ret;
+	}
+
+	ctrl = v4l2_ctrl_find(&priv->ctrl_handler, TEGRA_CAMERA_CID_FUSE_ID);
+	if (!ctrl) {
+		dev_err(&priv->i2c_client->dev,
+			"could not find device ctrl.\n");
+		err = -EINVAL;
+		goto ret;
+	}
+
+	for (i = 0; i < OV5640_FUSE_ID_SIZE; i++)
+		sprintf(&ctrl->p_new.p_char[i*2], "%02x",
+			fuse_id[i]);
+	ctrl->p_cur.p_char = ctrl->p_new.p_char;
+
+ret:
+	camera_common_s_power(priv->subdev, false);
+
+	return err;
+}
+
+static int ov5640_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov5640 *priv =
+		container_of(ctrl->handler, struct ov5640, ctrl_handler);
+	int err = 0;
+
+	if (priv->power.state == SWITCH_OFF)
+		return 0;
+
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_EEPROM_DATA:
+		err = ov5640_read_eeprom(priv, ctrl);
+		if (err)
+			return err;
+		break;
+	default:
+			pr_err("%s: unknown ctrl id.\n", __func__);
+			return -EINVAL;
+	}
+
+	return err;
+}
+
+static int ov5640_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov5640 *priv =
+		container_of(ctrl->handler, struct ov5640, ctrl_handler);
+	int err = 0;
+
+	if (priv->power.state == SWITCH_OFF)
+		return 0;
+
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_GAIN:
+		err = ov5640_set_gain(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_FRAME_LENGTH:
+		err = ov5640_set_frame_length(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_COARSE_TIME:
+		err = ov5640_set_coarse_time(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_COARSE_TIME_SHORT:
+		err = ov5640_set_coarse_time_short(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_GROUP_HOLD:
+		if (switch_ctrl_qmenu[ctrl->val] == SWITCH_ON) {
+			priv->group_hold_en = true;
+		} else {
+			priv->group_hold_en = false;
+			err = ov5640_set_group_hold(priv);
+		}
+		break;
+	case TEGRA_CAMERA_CID_EEPROM_DATA:
+		if (!ctrl->p_new.p_char[0])
+			break;
+		err = ov5640_write_eeprom(priv, ctrl->p_new.p_char);
+		if (err)
+			return err;
+		break;
+	case TEGRA_CAMERA_CID_HDR_EN:
+		break;
+	default:
+		pr_err("%s: unknown ctrl id.\n", __func__);
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static int ov5640_ctrls_init(struct ov5640 *priv, bool eeprom_ctrl)
+{
+	struct i2c_client *client = priv->i2c_client;
+	struct camera_common_data *common_data = priv->s_data;
+	struct v4l2_ctrl *ctrl;
+	int numctrls;
+	int err;
+	int i;
+
+	dev_dbg(&client->dev, "%s++\n", __func__);
+
+	numctrls = ARRAY_SIZE(ctrl_config_list);
+	v4l2_ctrl_handler_init(&priv->ctrl_handler, numctrls);
+
+	for (i = 0; i < numctrls; i++) {
+		/*
+		 * Skip control 'TEGRA_CAMERA_CID_EEPROM_DATA'
+		 * if eeprom inint err
+		 */
+		if (ctrl_config_list[i].id == TEGRA_CAMERA_CID_EEPROM_DATA) {
+			if (!eeprom_ctrl) {
+				common_data->numctrls -= 1;
+				continue;
+			}
+		}
+
+		ctrl = v4l2_ctrl_new_custom(&priv->ctrl_handler,
+			&ctrl_config_list[i], NULL);
+		if (ctrl == NULL) {
+			dev_err(&client->dev, "Failed to init %s ctrl\n",
+				ctrl_config_list[i].name);
+			continue;
+		}
+
+		if (ctrl_config_list[i].type == V4L2_CTRL_TYPE_STRING &&
+			ctrl_config_list[i].flags & V4L2_CTRL_FLAG_READ_ONLY) {
+			ctrl->p_new.p_char = devm_kzalloc(&client->dev,
+				ctrl_config_list[i].max + 1, GFP_KERNEL);
+			if (!ctrl->p_new.p_char)
+				return -ENOMEM;
+		}
+		priv->ctrls[i] = ctrl;
+	}
+
+	priv->numctrls = numctrls;
+	priv->subdev->ctrl_handler = &priv->ctrl_handler;
+	if (priv->ctrl_handler.error) {
+		dev_err(&client->dev, "Error %d adding controls\n",
+			priv->ctrl_handler.error);
+		err = priv->ctrl_handler.error;
+		goto error;
+	}
+
+	err = v4l2_ctrl_handler_setup(&priv->ctrl_handler);
+	if (err) {
+		dev_err(&client->dev,
+			"Error %d setting default controls\n", err);
+		goto error;
+	}
+
+	err = ov5640_otp_setup(priv);
+	if (err) {
+		dev_err(&client->dev,
+			"Error %d reading otp data\n", err);
+		goto error;
+	}
+
+	err = ov5640_fuse_id_setup(priv);
+	if (err) {
+		dev_err(&client->dev,
+			"Error %d reading fuse id data\n", err);
+		goto error;
+	}
+
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	return err;
+}
+
+MODULE_DEVICE_TABLE(of, ov5640_of_match);
+
+static struct camera_common_pdata *ov5640_parse_dt(struct i2c_client *client)
+{
+	struct device_node *node = client->dev.of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	const struct of_device_id *match;
+	int gpio;
+	int err;
+	struct camera_common_pdata *ret = NULL;
+
+	if (!node)
+		return NULL;
+
+	match = of_match_device(ov5640_of_match, &client->dev);
+	if (!match) {
+		dev_err(&client->dev, "Failed to find matching dt id\n");
+		return NULL;
+	}
+
+	board_priv_pdata = devm_kzalloc(&client->dev,
+			   sizeof(*board_priv_pdata), GFP_KERNEL);
+	if (!board_priv_pdata)
+		return NULL;
+
+	err = camera_common_parse_clocks(&client->dev, board_priv_pdata);
+	if (err) {
+		dev_err(&client->dev, "Failed to find clocks\n");
+		goto error;
+	}
+
+	gpio = of_get_named_gpio(node, "pwdn-gpios", 0);
+	if (gpio < 0) {
+		if (gpio == -EPROBE_DEFER) {
+			ret = ERR_PTR(-EPROBE_DEFER);
+			goto error;
+		}
+		dev_err(&client->dev, "pwdn gpios not in DT\n");
+		goto error;
+	}
+	board_priv_pdata->pwdn_gpio = (unsigned int)gpio;
+
+	gpio = of_get_named_gpio(node, "reset-gpios", 0);
+	if (gpio < 0) {
+		/* reset-gpio is not absolutely needed */
+		if (gpio == -EPROBE_DEFER) {
+			ret = ERR_PTR(-EPROBE_DEFER);
+			goto error;
+		}
+		dev_dbg(&client->dev, "reset gpios not in DT\n");
+		gpio = 0;
+	}
+	board_priv_pdata->reset_gpio = (unsigned int)gpio;
+
+	board_priv_pdata->use_cam_gpio =
+		of_property_read_bool(node, "cam,use-cam-gpio");
+
+	err = of_property_read_string(node, "avdd-reg",
+			&board_priv_pdata->regulators.avdd);
+	if (err) {
+		dev_err(&client->dev, "avdd-reg not in DT\n");
+		goto error;
+	}
+
+	err = of_property_read_string(node, "dvdd-reg",
+			&board_priv_pdata->regulators.dvdd);
+	if (err) {
+		dev_err(&client->dev, "dvdd-reg not in DT\n");
+		goto error;
+	}
+
+	board_priv_pdata->has_eeprom =
+		of_property_read_bool(node, "has-eeprom");
+	board_priv_pdata->v_flip = of_property_read_bool(node, "vertical-flip");
+	board_priv_pdata->h_mirror = of_property_read_bool(node,
+							 "horizontal-mirror");
+	return board_priv_pdata;
+
+error:
+	devm_kfree(&client->dev, board_priv_pdata);
+	return ret;
+}
+
+static int ov5640_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev_dbg(&client->dev, "%s:\n", __func__);
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops ov5640_subdev_internal_ops = {
+	.open = ov5640_open,
+};
+
+static const struct media_entity_operations ov5640_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static int ov5640_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct camera_common_data *common_data;
+	struct device_node *node = client->dev.of_node;
+	struct ov5640 *priv;
+	int err;
+
+	pr_info("[OV5640]: probing v4l2 sensor.\n");
+
+	if (!IS_ENABLED(CONFIG_OF) || !node)
+		return -EINVAL;
+
+	common_data = devm_kzalloc(&client->dev,
+			    sizeof(struct camera_common_data), GFP_KERNEL);
+	if (!common_data)
+		return -ENOMEM;
+
+	priv = devm_kzalloc(&client->dev,
+			    sizeof(struct ov5640) + sizeof(struct v4l2_ctrl *) *
+			    ARRAY_SIZE(ctrl_config_list),
+			    GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->regmap = devm_regmap_init_i2c(client, &ov5640_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(&client->dev,
+			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
+		return -ENODEV;
+	}
+
+	priv->pdata = ov5640_parse_dt(client);
+	if (PTR_ERR(priv->pdata) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	if (!priv->pdata) {
+		dev_err(&client->dev, "unable to get platform data\n");
+		return -EFAULT;
+	}
+
+	common_data->ops		= &ov5640_common_ops;
+	common_data->ctrl_handler	= &priv->ctrl_handler;
+	common_data->dev		= &client->dev;
+	common_data->frmfmt		= ov5640_frmfmt;
+	common_data->colorfmt		= camera_common_find_datafmt(
+					  OV5640_DEFAULT_DATAFMT);
+	common_data->power		= &priv->power;
+	common_data->ctrls		= priv->ctrls;
+	common_data->priv		= (void *)priv;
+	common_data->numctrls		= ARRAY_SIZE(ctrl_config_list);
+	common_data->numfmts		= ARRAY_SIZE(ov5640_frmfmt);
+	common_data->def_mode		= OV5640_DEFAULT_MODE;
+	common_data->def_width		= OV5640_DEFAULT_WIDTH;
+	common_data->def_height		= OV5640_DEFAULT_HEIGHT;
+	common_data->fmt_width		= common_data->def_width;
+	common_data->fmt_height		= common_data->def_height;
+	common_data->def_clk_freq	= OV5640_DEFAULT_CLK_FREQ;
+
+	priv->i2c_client = client;
+	priv->s_data			= common_data;
+	priv->subdev			= &common_data->subdev;
+	priv->subdev->dev		= &client->dev;
+	priv->s_data->dev		= &client->dev;
+
+	err = ov5640_power_get(priv);
+	if (err)
+		return err;
+
+	err = camera_common_initialize(common_data, "ov5640");
+	if (err) {
+		dev_err(&client->dev, "Failed to initialize ov5640.\n");
+		return err;
+	}
+
+
+	v4l2_i2c_subdev_init(priv->subdev, client, &ov5640_subdev_ops);
+
+	/* eeprom interface */
+	err = ov5640_eeprom_device_init(priv);
+	if (err && priv->pdata->has_eeprom)
+		dev_err(&client->dev,
+			"Failed to allocate eeprom reg map: %d\n", err);
+
+	err = ov5640_ctrls_init(priv, !err);
+	if (err)
+		return err;
+
+	priv->subdev->internal_ops = &ov5640_subdev_internal_ops;
+	priv->subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+			       V4L2_SUBDEV_FL_HAS_EVENTS;
+
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	priv->subdev->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+	priv->subdev->entity.ops = &ov5640_media_ops;
+	err = media_entity_init(&priv->subdev->entity, 1, &priv->pad, 0);
+	if (err < 0) {
+		dev_err(&client->dev, "unable to init media entity\n");
+		return err;
+	}
+#endif
+
+	err = v4l2_async_register_subdev(priv->subdev);
+	if (err)
+		return err;
+
+	dev_dbg(&client->dev, "Detected ov5640 sensor\n");
+
+
+	return 0;
+}
+
+static int
+ov5640_remove(struct i2c_client *client)
+{
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct ov5640 *priv = (struct ov5640 *)s_data->priv;
+
+	v4l2_async_unregister_subdev(priv->subdev);
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	media_entity_cleanup(&priv->subdev->entity);
+#endif
+
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	ov5640_power_put(priv);
+	camera_common_cleanup(s_data);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov5640_id[] = {
+	{ "ov5640", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, ov5640_id);
+
+static struct i2c_driver ov5640_i2c_driver = {
+	.driver = {
+		.name = "ov5640",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(ov5640_of_match),
+	},
+	.probe = ov5640_probe,
+	.remove = ov5640_remove,
+	.id_table = ov5640_id,
+};
+
+module_i2c_driver(ov5640_i2c_driver);
+
+MODULE_DESCRIPTION("SoC Camera driver for OmniVision OV5640");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/media/i2c/ov5640_mode_tbls.h b/drivers/media/i2c/ov5640_mode_tbls.h
new file mode 100755
index 0000000..bec1acd
--- /dev/null
+++ b/drivers/media/i2c/ov5640_mode_tbls.h
@@ -0,0 +1,377 @@
+/*
+ * ov5640_mode_tbls.h - ov5640 sensor mode tables
+ *
+ * Copyright (c) 2015-2017, NVIDIA CORPORATION, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __OV5640_TABLES__
+#define __OV5640_TABLES__
+
+#include <media/camera_common.h>
+
+#define OV5640_TABLE_WAIT_MS	0
+#define OV5640_TABLE_END	1
+#define OV5640_MAX_RETRIES	3
+#define OV5640_WAIT_MS		10
+
+#define ov5640_reg struct reg_8
+
+static const ov5640_reg ov5640_start[] = {
+	{0x3008, 0x02}, /* mode select streaming on */
+	{OV5640_TABLE_END, 0x00}
+};
+
+static const ov5640_reg ov5640_stop[] = {
+	{0x3008, 0x42}, /* mode select streaming on */
+	{OV5640_TABLE_END, 0x00}
+};
+
+static const ov5640_reg tp_colorbars[] = {
+	{0x503d, 0x80},
+
+	{OV5640_TABLE_WAIT_MS, OV5640_WAIT_MS},
+	{OV5640_TABLE_END, 0x00}
+};
+
+static const ov5640_reg mode_1920x1080[] = {
+	{OV5640_TABLE_WAIT_MS, OV5640_WAIT_MS},
+
+	{0x3103, 0x11}, // global settings
+    {0x3103, 0x11},
+    {0x3008, 0x82}, // reset
+    {OV5640_TABLE_WAIT_MS, 0x1e},// delay here of 30ms
+    {0x3008, 0x42}, // power down
+    {0x3103, 0x03},
+    {0x3017, 0x00}, // disable oe
+    {0x3018, 0x00},
+
+    // PLL settings - RAW10, MIPISCLK = 420, SCLK = 84MHz, PCLK=84M
+    // {0x3034, 0x18}, // 8bit
+    {0x3034, 0x1a}, // 10bit - /2.5 of PLL
+    // {0x3035, 0x11},
+    {0x3035, 0x21}, // sys div /2, mipi  div /1 == MIPISCLK = 420MHz
+    // {0x3036, 0x54}, // 0x46 - 30fps,
+    {0x3036, 0x69}, // 0x69 = 105 mult - VCO = 840MHz
+    {0x3037, 0x03}, // div - pre div = /3 -> 8MHz, PLL root divider - /1
+    // {0x3037, 0x08},
+    // {0x3108, 0x01},
+    {0x3108, 0x11}, // PCLK root div /2, SCLK2x div /1, SCLK root div /2 -> PLL = 420MHz, 
+    {0x3824, 0x01},
+    {OV5640_TABLE_WAIT_MS,0x05}, // delay 5ms
+
+    {0x3630, 0x36},
+    {0x3631, 0x0e},
+    {0x3632, 0xe2},
+    {0x3633, 0x12},
+    {0x3621, 0xe0},
+    {0x3704, 0xa0},
+    {0x3703, 0x5a},
+    {0x3715, 0x78},
+    {0x3717, 0x01},
+    {0x370b, 0x60},
+    {0x3705, 0x1a},
+    {0x3905, 0x02},
+    {0x3906, 0x10},
+    {0x3901, 0x0a},
+    {0x3731, 0x12},
+    {0x3600, 0x08},
+    {0x3601, 0x33},
+    {0x302d, 0x60},
+    {0x3620, 0x52},
+    {0x371b, 0x20},
+    {0x471c, 0x50},
+    {0x3a13, 0x43},
+    {0x3a18, 0x00},
+    {0x3a19, 0xf8}, // AGC ceiling
+    {0x3635, 0x13},
+    {0x3636, 0x03},
+    {0x3634, 0x40},
+    {0x3622, 0x01},
+    {0x3c01, 0x34}, //Band manual enable
+    
+    {0x3c04, 0x28},
+    {0x3c05, 0x98},
+    {0x3c06, 0x00},
+    {0x3c07, 0x07}, // spec light meter threshold
+
+    {0x3c08, 0x00},
+    {0x3c09, 0x1c},
+    {0x3c0a, 0x9c},
+    {0x3c0b, 0x40},
+
+    {0x3820, 0x40}, // timing control
+    {0x3821, 0x06}, // timing control
+
+    {0x3814, 0x11},
+    {0x3815, 0x11},
+
+    {0x3800, 0x01}, // size setup
+    {0x3801, 0x50},
+    {0x3802, 0x01},
+    {0x3803, 0xb2},
+    {0x3804, 0x08},
+    {0x3805, 0xef},
+    {0x3806, 0x05},
+    {0x3807, 0xf1},
+    {0x3808, 0x07},
+    {0x3809, 0x80},
+    {0x380a, 0x04},
+    {0x380b, 0x38},
+    {0x380c, 0x09},
+    {0x380d, 0xc4},
+    {0x380e, 0x04},
+    {0x380f, 0x60},
+
+    {0x3810, 0x00},
+    {0x3811, 0x10},
+    {0x3812, 0x00},
+
+    {0x3813, 0x04},
+    {0x3618, 0x04},
+    {0x3612, 0x2b},
+    {0x3708, 0x64},
+    {0x3709, 0x12},
+    {0x370c, 0x00},
+    {0x3a02, 0x04},
+    {0x3a03, 0x60},
+    {0x3a08, 0x01},
+    {0x3a09, 0x50},
+    {0x3a0b, 0x18},
+    {0x3a0e, 0x03},
+    {0x3a0d, 0x04},
+    {0x3a14, 0x04},
+    {0x3a15, 0x60},
+
+    {0x3503, 0x03}, //AEC Manual mode
+
+    {0x4001, 0x02},
+    {0x4004, 0x06}, // black line control process
+
+    {0x3000, 0x00}, // no resets
+    {0x3002, 0x1c},
+    {0x3004, 0xff},
+    {0x3006, 0xc3},
+
+    {0x300e, 0x45},  //  2 lane MIPI, MIPI enable, DEBUG
+    {0x302e, 0x08},
+
+    // {0x4300, 0x32}, // UYVY
+    {0x4300, 0xf8}, // RAW BGGR
+    {0x501f, 0x03}, // ISP RAW (DPC)
+    {0x4713, 0x02},
+    {0x4407, 0x04},
+    {0x440e, 0x00},
+
+    {0x460c, 0x20},
+    {0x4837, 24},  // PCLK period = 1/PCLK in ns * 2 (depends on # of lanes)
+    {0x5000, 0x06}, //CHANGED ..Gamma enable = bad
+    {0x5001, 0x00},
+    {0x3a0f, 0x30},       
+    {0x3a10, 0x28},
+    {0x3a1b, 0x30},
+    {0x3a1e, 0x26},
+    {0x3a11, 0x60},
+    {0x3a1f, 0x14},
+    {0x3008, 0x02},
+
+
+	{OV5640_TABLE_END, 0x0000}
+};
+
+static const ov5640_reg mode_2592x1944[] = {
+    {OV5640_TABLE_WAIT_MS, OV5640_WAIT_MS},
+
+	{0x3103, 0x11}, // global settings
+    {0x3103, 0x11},
+    {0x3008, 0x82}, // reset
+    {OV5640_TABLE_WAIT_MS, 0x1e},// delay here of 30ms
+    {0x3008, 0x42}, // power down
+    {0x3103, 0x03},
+    {0x3017, 0x00}, // disable oe
+    {0x3018, 0x00},
+
+    // PLL settings - RAW10, MIPISCLK = 420, SCLK = 84MHz, PCLK=84M
+    //{0x3034, 0x18}, // 8bit
+    {0x3034, 0x1a}, // 10bit - /2.5 of PLL
+    {0x3035, 0x12},
+    // {0x3035, 0x21}, // sys div /2, mipi  div /1 == MIPISCLK = 420MHz
+    // {0x3036, 0x54}, // 0x46 - 30fps,
+    {0x3036, 0x69}, // 0x69 = 105 mult - VCO = 840MHz
+    {0x3037, 0x13}, // div - pre div = /3 -> 8MHz, PLL root divider - /2
+    // {0x3037, 0x03}, // div - pre div = /3 -> 8MHz, PLL root divider - /1
+
+    {0x3108, 0x11}, // PCLK root div /2, SCLK2x div /1, SCLK root div /2 -> PLL = 420MHz, 
+    {0x3824, 0x01},
+    {OV5640_TABLE_WAIT_MS,0x05}, // delay 5ms
+
+    {0x3630, 0x36},
+    {0x3631, 0x0e},
+    {0x3632, 0xe2},
+    {0x3633, 0x12},
+    {0x3621, 0xe0},
+    {0x3704, 0xa0},
+    {0x3703, 0x5a},
+    {0x3715, 0x78},
+    {0x3717, 0x01},
+    {0x370b, 0x60},
+    {0x3705, 0x1a},
+    {0x3905, 0x02},
+    {0x3906, 0x10},
+    {0x3901, 0x0a},
+    {0x3731, 0x12},
+    {0x3600, 0x08},
+    {0x3601, 0x33},
+    {0x302d, 0x60},
+    {0x3620, 0x52},
+    {0x371b, 0x20},
+    {0x471c, 0x50},
+    {0x3a13, 0x43},
+    {0x3a18, 0x00},
+    {0x3a19, 0xf8}, // AGC ceiling
+    {0x3635, 0x13},
+    {0x3636, 0x03},
+    {0x3634, 0x40},
+    {0x3622, 0x01},
+    {0x3c01, 0x34}, //Band manual enable
+    
+    {0x3c04, 0x28},
+    {0x3c05, 0x98},
+    {0x3c06, 0x00},
+    {0x3c07, 0x07}, // spec light meter threshold
+
+    {0x3c08, 0x00},
+    {0x3c09, 0x1c},
+    {0x3c0a, 0x9c},
+    {0x3c0b, 0x40},
+
+    {0x3820, 0x40}, // timing control
+    {0x3821, 0x00}, // timing control
+
+    {0x3814, 0x11},
+    {0x3815, 0x11},
+
+    {0x3800, 0x00}, // size setup
+    {0x3801, 0x00},
+    {0x3802, 0x00},
+    {0x3803, 0x00},
+    {0x3804, 0x0a},
+    {0x3805, 0x3f},
+    {0x3806, 0x07},
+    {0x3807, 0x9f},
+    {0x3808, 0x0a},
+    {0x3809, 0x20},
+    {0x380a, 0x07},
+    {0x380b, 0x98},
+    {0x380c, 0x0b},
+    {0x380d, 0x1c},
+    {0x380e, 0x07},
+    {0x380f, 0xb0},
+
+    {0x3810, 0x00},
+    {0x3811, 0x10},
+    {0x3812, 0x00},
+
+    {0x3813, 0x04},
+    {0x3618, 0x04},
+    {0x3612, 0x2b},
+    {0x3708, 0x63},
+    {0x3709, 0x12},
+    {0x370c, 0x00},
+    {0x3a02, 0x07},
+    {0x3a03, 0xb0},
+    {0x3a08, 0x01},
+    {0x3a09, 0x27},
+    {0x3a0a, 0x00},
+    {0x3a0b, 0xf6},
+    {0x3a0e, 0x06},
+    {0x3a0d, 0x08},
+    {0x3a14, 0x07},
+    {0x3a15, 0xb0},
+
+    {0x3503, 0x03}, //AEC Manual mode
+
+    {0x4001, 0x02},
+    {0x4004, 0x06}, // black line control process
+    {0x4050, 0x6e},
+    {0x4051, 0x8f},
+    {0x3000, 0x00}, // no resets
+    {0x3002, 0x1c},
+    {0x3004, 0xff},
+    {0x3006, 0xc3},
+
+    {0x300e, 0x45},  //  2 lane MIPI, MIPI enable, DEBUG
+    {0x302e, 0x08},
+
+    // {0x4300, 0x32}, // UYVY
+    {0x4300, 0xf8}, // RAW BGGR
+    {0x501f, 0x03}, // ISP RAW (DPC)
+    {0x5684, 0x0a},
+    {0x5685, 0x20},
+    {0x5686, 0x07},
+    {0x5687, 0x98},
+    {0x440e, 0x00},
+
+    
+    {0x4837, 24},  // PCLK period = 1/PCLK in ns * 2 (depends on # of lanes)
+    {0x5000, 0x06}, //CHANGED ..Gamma enable = bad
+    {0x5001, 0x00},
+    {0x3a0f, 0x36},       
+    {0x3a10, 0x2e},
+    {0x3a1b, 0x38},
+    {0x3a1e, 0x2c},
+    {0x3a11, 0x70},
+    {0x3a1f, 0x18},
+    {0x3008, 0x02},
+
+
+	{OV5640_TABLE_END, 0x0000}
+    
+};
+
+enum {
+	OV5640_MODE_1920X1080,
+	OV5640_MODE_START_STREAM,
+	OV5640_MODE_STOP_STREAM,
+	OV5640_MODE_TEST_PATTERN
+};
+
+static const ov5640_reg *mode_table[] = {
+	[OV5640_MODE_1920X1080]			= mode_1920x1080,
+    [OV5640_MODE_START_STREAM]		= ov5640_start,
+	[OV5640_MODE_STOP_STREAM]		= ov5640_stop,
+	[OV5640_MODE_TEST_PATTERN]		= tp_colorbars,
+};
+
+static const int ov5640_15fps[] = {
+	15,
+};
+
+static const int ov5640_24fps[] = {
+	24,
+};
+
+static const int ov5640_30fps[] = {
+	30,
+};
+
+static const int ov5640_120fps[] = {
+	120,
+};
+
+static const struct camera_common_frmfmt ov5640_frmfmt[] = {
+	{{1920, 1080},	ov5640_30fps,	1, 0,	OV5640_MODE_1920X1080},
+};
+#endif  /* __OV5640_TABLES__ */
+
diff --git a/drivers/media/i2c/ov5670.c b/drivers/media/i2c/ov5670.c
new file mode 100755
index 0000000..f21a316
--- /dev/null
+++ b/drivers/media/i2c/ov5670.c
@@ -0,0 +1,1499 @@
+/*
+ * ov5670_v4l2.c - ov5670 sensor driver
+ *
+ * Copyright (c) 2013-2017, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#define DEBUG
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+
+#include <linux/seq_file.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+
+#include <media/tegra-v4l2-camera.h>
+#include <media/camera_common.h>
+#include <media/ov5670.h>
+
+#include "../platform/tegra/camera/camera_gpio.h"
+
+#include "ov5670_mode_tbls.h"
+
+#define OV5670_MAX_COARSE_DIFF		6
+
+#define OV5670_GAIN_SHIFT		8
+#define OV5670_MIN_GAIN		(1 << OV5670_GAIN_SHIFT)
+#define OV5670_MAX_GAIN		(16 << OV5670_GAIN_SHIFT)
+#define OV5670_MAX_UNREAL_GAIN	(0x0F80)
+#define OV5670_MIN_FRAME_LENGTH	(0x0)
+#define OV5670_MAX_FRAME_LENGTH	(0x7fff)
+#define OV5670_MIN_EXPOSURE_COARSE	(0x0002)
+#define OV5670_MAX_EXPOSURE_COARSE	\
+	(OV5670_MAX_FRAME_LENGTH-OV5670_MAX_COARSE_DIFF)
+#define OV5670_DEFAULT_LINE_LENGTH	(0xA80) //2688
+// #define OV5670_DEFAULT_PIXEL_CLOCK	(160)
+#define OV5670_DEFAULT_PIXEL_CLOCK	(240)
+
+#define OV5670_DEFAULT_GAIN		OV5670_MIN_GAIN
+#define OV5670_DEFAULT_FRAME_LENGTH	(0x07C0) //1984
+#define OV5670_DEFAULT_EXPOSURE_COARSE	\
+	(OV5670_DEFAULT_FRAME_LENGTH-OV5670_MAX_COARSE_DIFF)
+
+// #define OV5670_DEFAULT_MODE	OV5670_MODE_2592X1944
+#define OV5670_DEFAULT_MODE	OV5670_MODE_1920X1080
+//#define OV5670_DEFAULT_HDR_MODE	OV5670_MODE_2592X1944_HDR
+// #define OV5670_DEFAULT_WIDTH	2592
+// #define OV5670_DEFAULT_HEIGHT	1944
+#define OV5670_DEFAULT_WIDTH	1920
+#define OV5670_DEFAULT_HEIGHT	1080
+
+// #define OV5670_DEFAULT_DATAFMT	MEDIA_BUS_FMT_SBGGR10_1X10
+#define OV5670_DEFAULT_DATAFMT	MEDIA_BUS_FMT_SGBRG10_1X10
+#define OV5670_DEFAULT_CLK_FREQ	24000000
+
+struct ov5670 {
+	struct camera_common_power_rail	power;
+	int				numctrls;
+	struct v4l2_ctrl_handler	ctrl_handler;
+	struct camera_common_eeprom_data eeprom[OV5670_EEPROM_NUM_BLOCKS];
+	u8				eeprom_buf[OV5670_EEPROM_SIZE];
+	struct i2c_client		*i2c_client;
+	struct v4l2_subdev		*subdev;
+	struct media_pad		pad;
+
+	s32				group_hold_prev;
+	u32				frame_length;
+	bool				group_hold_en;
+	struct regmap			*regmap;
+	struct camera_common_data	*s_data;
+	struct camera_common_pdata	*pdata;
+	struct v4l2_ctrl		*ctrls[];
+};
+
+static struct regmap_config ov5670_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+};
+
+static int ov5670_g_volatile_ctrl(struct v4l2_ctrl *ctrl);
+static int ov5670_s_ctrl(struct v4l2_ctrl *ctrl);
+static void ov5670_update_ctrl_range(struct ov5670 *priv, s32 frame_length);
+
+static const struct v4l2_ctrl_ops ov5670_ctrl_ops = {
+	.g_volatile_ctrl = ov5670_g_volatile_ctrl,
+	.s_ctrl		= ov5670_s_ctrl,
+};
+
+static struct v4l2_ctrl_config ctrl_config_list[] = {
+/* Do not change the name field for the controls! */
+	{
+		.ops = &ov5670_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GAIN,
+		.name = "Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = OV5670_MIN_GAIN,
+		.max = OV5670_MAX_GAIN,
+		.def = OV5670_DEFAULT_GAIN,
+		.step = 1,
+	},
+	{
+		.ops = &ov5670_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_FRAME_LENGTH,
+		.name = "Frame Length",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = OV5670_MIN_FRAME_LENGTH,
+		.max = OV5670_MAX_FRAME_LENGTH,
+		.def = OV5670_DEFAULT_FRAME_LENGTH,
+		.step = 1,
+	},
+	{
+		.ops = &ov5670_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_COARSE_TIME,
+		.name = "Coarse Time",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = OV5670_MIN_EXPOSURE_COARSE,
+		.max = OV5670_MAX_EXPOSURE_COARSE,
+		.def = OV5670_DEFAULT_EXPOSURE_COARSE,
+		.step = 1,
+	},
+	{
+		.ops = &ov5670_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_COARSE_TIME_SHORT,
+		.name = "Coarse Time Short",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = OV5670_MIN_EXPOSURE_COARSE,
+		.max = OV5670_MAX_EXPOSURE_COARSE,
+		.def = OV5670_DEFAULT_EXPOSURE_COARSE,
+		.step = 1,
+	},
+	{
+		.ops = &ov5670_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GROUP_HOLD,
+		.name = "Group Hold",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &ov5670_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_HDR_EN,
+		.name = "HDR enable",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &ov5670_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_EEPROM_DATA,
+		.name = "EEPROM Data",
+		.type = V4L2_CTRL_TYPE_STRING,
+		.flags = V4L2_CTRL_FLAG_VOLATILE,
+		.min = 0,
+		.max = OV5670_EEPROM_STR_SIZE,
+		.step = 2,
+	},
+	{
+		.ops = &ov5670_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_OTP_DATA,
+		.name = "OTP Data",
+		.type = V4L2_CTRL_TYPE_STRING,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY,
+		.min = 0,
+		.max = OV5670_OTP_STR_SIZE,
+		.step = 2,
+	},
+};
+
+static inline void ov5670_get_frame_length_regs(ov5670_reg *regs,
+				u32 frame_length)
+{
+	regs->addr = OV5670_FRAME_LENGTH_ADDR_MSB;
+	regs->val = (frame_length >> 8) & 0xff;
+	(regs + 1)->addr = OV5670_FRAME_LENGTH_ADDR_LSB;
+	(regs + 1)->val = (frame_length) & 0xff;
+}
+
+
+static inline void ov5670_get_coarse_time_regs(ov5670_reg *regs,
+				u32 coarse_time)
+{
+	regs->addr = OV5670_COARSE_TIME_ADDR_1;
+	regs->val = (coarse_time >> 12) & 0xff;
+	(regs + 1)->addr = OV5670_COARSE_TIME_ADDR_2;
+	(regs + 1)->val = (coarse_time >> 4) & 0xff;
+	(regs + 2)->addr = OV5670_COARSE_TIME_ADDR_3;
+	(regs + 2)->val = (coarse_time & 0xf) << 4;
+}
+
+static inline void ov5670_get_coarse_time_short_regs(ov5670_reg *regs,
+				u32 coarse_time)
+{
+	regs->addr = OV5670_COARSE_TIME_SHORT_ADDR_1;
+	regs->val = (coarse_time >> 12) & 0xff;
+	(regs + 1)->addr = OV5670_COARSE_TIME_SHORT_ADDR_2;
+	(regs + 1)->val = (coarse_time >> 4) & 0xff;
+	(regs + 2)->addr = OV5670_COARSE_TIME_SHORT_ADDR_3;
+	(regs + 2)->val = (coarse_time & 0xf) << 4;
+}
+
+static inline void ov5670_get_gain_regs(ov5670_reg *regs,
+				u16 gain)
+{
+	regs->addr = OV5670_GAIN_ADDR_MSB;
+	regs->val = (gain >> 8) & 0xff;
+
+	(regs + 1)->addr = OV5670_GAIN_ADDR_LSB;
+	(regs + 1)->val = (gain) & 0xff;
+}
+
+static int test_mode;
+module_param(test_mode, int, 0644);
+
+static inline int ov5670_read_reg(struct camera_common_data *s_data,
+				u16 addr, u8 *val)
+{
+	struct ov5670 *priv = (struct ov5670 *)s_data->priv;
+	int err = 0;
+	u32 reg_val = 0;
+
+	err = regmap_read(priv->regmap, addr, &reg_val);
+	*val = reg_val & 0xFF;
+
+	return err;
+}
+
+static int ov5670_write_reg(struct camera_common_data *s_data, u16 addr, u8 val)
+{
+	int err;
+	struct ov5670 *priv = (struct ov5670 *)s_data->priv;
+
+	err = regmap_write(priv->regmap, addr, val);
+	if (err)
+		pr_err("%s:i2c write failed, %x = %x\n",
+			__func__, addr, val);
+
+	return err;
+}
+
+static int ov5670_write_table(struct ov5670 *priv,
+			      const ov5670_reg table[])
+{
+	return regmap_util_write_table_8(priv->regmap,
+					 table,
+					 NULL, 0,
+					 OV5670_TABLE_WAIT_MS,
+					 OV5670_TABLE_END);
+}
+
+static void ov5670_gpio_set(struct ov5670 *priv,
+			    unsigned int gpio, int val)
+{
+	if (priv->pdata && priv->pdata->use_cam_gpio)
+		cam_gpio_ctrl(&priv->i2c_client->dev, gpio, val, 1);
+	else {
+		if (gpio_cansleep(gpio))
+			gpio_set_value_cansleep(gpio, val);
+		else
+			gpio_set_value(gpio, val);
+	}
+}
+
+static int ov5670_power_on(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct ov5670 *priv = (struct ov5670 *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+	u32 frame_time;
+
+	dev_dbg(&priv->i2c_client->dev, "%s: power on\n", __func__);
+
+	if (priv->pdata && priv->pdata->power_on) {
+		err = priv->pdata->power_on(pw);
+		if (err)
+			pr_err("%s failed.\n", __func__);
+		else
+			pw->state = SWITCH_ON;
+		return err;
+	}
+
+	/* sleeps calls in the sequence below are for internal device
+	 * signal propagation as specified by sensor vendor */
+
+	if (pw->avdd)
+		err = regulator_enable(pw->avdd);
+	if (err)
+		goto ov5670_avdd_fail;
+
+	if (pw->dvdd) {
+		err = regulator_enable(pw->dvdd);
+		dev_dbg(&priv->i2c_client->dev, "%s: power on - enable dvdd\n", __func__);
+	}
+	if (err)
+		goto ov5670_dvdd_fail;
+
+	usleep_range(1, 2);
+	if (pw->pwdn_gpio)
+		ov5670_gpio_set(priv, pw->pwdn_gpio, 1);
+
+	/*
+	 * datasheet 2.9: reset requires ~2ms settling time
+	 * a power on reset is generated after core power becomes stable
+	 */
+	usleep_range(2000, 2010);
+
+	if (pw->reset_gpio)
+		ov5670_gpio_set(priv, pw->reset_gpio, 1);
+
+	/* datasheet fig 2-9: t3 */
+	usleep_range(2000, 2010);
+
+	pw->state = SWITCH_ON;
+
+	/* need SW standby LP11 for mipical.
+	 * sensor default is LP00, this will transition to LP11 */
+	ov5670_write_reg(s_data, 0x0100, 0x1);
+	ov5670_write_reg(s_data, 0x0100, 0x0);
+	/*
+	 * Sleep to allow SW reset to settle into LP11. After writing
+	 * 0x1, according to the datasheet, it could take the remainder
+	 * of the frame time to settle.  Streaming too soon after this
+	 * may have unintended consequences.
+	 */
+	frame_time = OV5670_DEFAULT_FRAME_LENGTH *
+			OV5670_DEFAULT_LINE_LENGTH / OV5670_DEFAULT_PIXEL_CLOCK;
+	usleep_range(frame_time, frame_time + 1000);
+
+	return 0;
+
+ov5670_dvdd_fail:
+	regulator_disable(pw->avdd);
+
+ov5670_avdd_fail:
+	pr_err("%s failed.\n", __func__);
+	return -ENODEV;
+}
+
+static int ov5670_power_off(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct ov5670 *priv = (struct ov5670 *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+
+	dev_dbg(&priv->i2c_client->dev, "%s: power off\n", __func__);
+
+	if (priv->pdata && priv->pdata->power_off) {
+		err = priv->pdata->power_off(pw);
+		if (!err) {
+			goto power_off_done;
+		} else {
+			pr_err("%s failed.\n", __func__);
+			return err;
+		}
+	}
+
+	/* sleeps calls in the sequence below are for internal device
+	 * signal propagation as specified by sensor vendor */
+
+	usleep_range(21, 25);
+	if (pw->pwdn_gpio)
+		ov5670_gpio_set(priv, pw->pwdn_gpio, 0);
+	usleep_range(1, 2);
+	if (pw->reset_gpio)
+		ov5670_gpio_set(priv, pw->reset_gpio, 0);
+
+	/* datasheet 2.9: reset requires ~2ms settling time*/
+	usleep_range(2000, 2010);
+
+	if (pw->dvdd)
+		regulator_disable(pw->dvdd);
+	if (pw->avdd)
+		regulator_disable(pw->avdd);
+
+power_off_done:
+	pw->state = SWITCH_OFF;
+	return 0;
+}
+
+static int ov5670_power_put(struct ov5670 *priv)
+{
+	struct camera_common_power_rail *pw = &priv->power;
+
+	if (unlikely(!pw))
+		return -EFAULT;
+
+	if (likely(pw->avdd))
+		regulator_put(pw->avdd);
+
+	if (likely(pw->dvdd))
+		regulator_put(pw->dvdd);
+
+	pw->avdd = NULL;
+	pw->dvdd = NULL;
+
+	if (priv->pdata && priv->pdata->use_cam_gpio)
+		cam_gpio_deregister(&priv->i2c_client->dev, pw->pwdn_gpio);
+	else {
+		gpio_free(pw->pwdn_gpio);
+		gpio_free(pw->reset_gpio);
+	}
+
+	return 0;
+}
+
+static int ov5670_power_get(struct ov5670 *priv)
+{
+	struct camera_common_power_rail *pw = &priv->power;
+	struct camera_common_pdata *pdata = priv->pdata;
+	const char *mclk_name;
+	const char *parentclk_name;
+	struct clk *parent;
+	int err = 0, ret = 0;
+
+	if (!pdata) {
+		dev_err(&priv->i2c_client->dev, "pdata missing\n");
+		return -EFAULT;
+	}
+
+	mclk_name = pdata->mclk_name ?
+		    pdata->mclk_name : "cam_mclk1";
+	pw->mclk = devm_clk_get(&priv->i2c_client->dev, mclk_name);
+	if (IS_ERR(pw->mclk)) {
+		dev_err(&priv->i2c_client->dev,
+			"unable to get clock %s\n", mclk_name);
+		return PTR_ERR(pw->mclk);
+	}
+
+	parentclk_name = pdata->parentclk_name;
+	if (parentclk_name) {
+		parent = devm_clk_get(&priv->i2c_client->dev, parentclk_name);
+		if (IS_ERR(parent)) {
+			dev_err(&priv->i2c_client->dev,
+				"unable to get parent clcok %s",
+				parentclk_name);
+		} else
+			clk_set_parent(pw->mclk, parent);
+	}
+
+
+	/* analog 2.8v */
+	err |= camera_common_regulator_get(&priv->i2c_client->dev,
+			&pw->avdd, pdata->regulators.avdd);
+	/* IO 1.2v */
+	err |= camera_common_regulator_get(&priv->i2c_client->dev,
+			&pw->dvdd, pdata->regulators.dvdd);
+
+	if (!err) {
+		pw->reset_gpio = pdata->reset_gpio;
+		pw->pwdn_gpio = pdata->pwdn_gpio;
+	}
+
+	if (pdata->use_cam_gpio) {
+		err = cam_gpio_register(&priv->i2c_client->dev, pw->pwdn_gpio);
+		if (err)
+			dev_err(&priv->i2c_client->dev,
+				"%s ERR can't register cam gpio %u!\n",
+				 __func__, pw->pwdn_gpio);
+	} else {
+		ret = gpio_request(pw->pwdn_gpio, "cam_pwdn_gpio");
+		if (ret < 0)
+			dev_dbg(&priv->i2c_client->dev,
+				"%s can't request pwdn_gpio %d\n",
+				__func__, ret);
+		ret = gpio_request(pw->reset_gpio, "cam_reset_gpio");
+		if (ret < 0)
+			dev_dbg(&priv->i2c_client->dev,
+				"%s can't request reset_gpio %d\n",
+				__func__, ret);
+	}
+
+
+	pw->state = SWITCH_OFF;
+	return err;
+}
+
+static int ov5670_set_gain(struct ov5670 *priv, s32 val);
+static int ov5670_set_frame_length(struct ov5670 *priv, s32 val);
+static int ov5670_set_coarse_time(struct ov5670 *priv, s32 val);
+static int ov5670_set_coarse_time_short(struct ov5670 *priv, s32 val);
+
+static int ov5670_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct ov5670 *priv = (struct ov5670 *)s_data->priv;
+	struct v4l2_control control;
+	int err;
+	u32 frame_time;
+	u8 val;
+
+	dev_dbg(&client->dev, "%s++\n", __func__);
+
+	if (!enable) {
+		ov5670_update_ctrl_range(priv, OV5670_MAX_FRAME_LENGTH);
+
+		err = ov5670_write_table(priv,
+			mode_table[OV5670_MODE_STOP_STREAM]);
+		if (err)
+			return err;
+
+		/*
+		 * Wait for one frame to make sure sensor is set to
+		 * software standby in V-blank
+		 *
+		 * frame_time = frame length rows * Tline
+		 * Tline = line length / pixel clock (in MHz)
+		 */
+		frame_time = priv->frame_length *
+			OV5670_DEFAULT_LINE_LENGTH / OV5670_DEFAULT_PIXEL_CLOCK;
+
+		usleep_range(frame_time, frame_time + 1000);
+		return 0;
+	}
+
+	// setup pll
+	err = ov5670_write_table(priv, ov5670_pll_840mbps);
+	if (err)
+		goto exit;
+
+	err = ov5670_write_table(priv, mode_table[s_data->mode]);
+	if (err)
+		goto exit;
+
+
+	if (s_data->override_enable) {
+		/*
+		 * write list of override regs for the asking frame length,
+		 * coarse integration time, and gain. Failures to write
+		 * overrides are non-fatal
+		 */
+		control.id = TEGRA_CAMERA_CID_GAIN;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		err |= ov5670_set_gain(priv, control.value);
+		if (err)
+			dev_dbg(&client->dev, "%s: warning gain override failed\n",
+				__func__);
+
+		control.id = TEGRA_CAMERA_CID_FRAME_LENGTH;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		err |= ov5670_set_frame_length(priv, control.value);
+		if (err)
+			dev_dbg(&client->dev,
+				"%s: warning frame length override failed\n",
+				__func__);
+
+		control.id = TEGRA_CAMERA_CID_COARSE_TIME;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		err |= ov5670_set_coarse_time(priv, control.value);
+		if (err)
+			dev_dbg(&client->dev,
+				"%s: warning coarse time override failed\n",
+				__func__);
+
+		control.id = TEGRA_CAMERA_CID_COARSE_TIME_SHORT;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		err |= ov5670_set_coarse_time_short(priv, control.value);
+		if (err)
+			dev_dbg(&client->dev,
+				"%s: warning coarse time short override failed\n",
+				__func__);
+	}
+
+	err = ov5670_write_table(priv, mode_table[OV5670_MODE_START_STREAM]);
+	if (err)
+		goto exit;
+	if (priv->pdata->v_flip) {
+		ov5670_read_reg(priv->s_data, OV5670_TIMING_REG20, &val);
+		ov5670_write_reg(priv->s_data, OV5670_TIMING_REG20,
+				 val | VERTICAL_FLIP);
+	}
+	if (priv->pdata->h_mirror) {
+		ov5670_read_reg(priv->s_data, OV5670_TIMING_REG21, &val);
+		ov5670_write_reg(priv->s_data, OV5670_TIMING_REG21,
+				 val | HORIZONTAL_MIRROR_MASK);
+	} else {
+		ov5670_read_reg(priv->s_data, OV5670_TIMING_REG21, &val);
+		ov5670_write_reg(priv->s_data, OV5670_TIMING_REG21,
+				 val & (~HORIZONTAL_MIRROR_MASK));
+	}
+	if (test_mode)
+		err = ov5670_write_table(priv,
+			mode_table[OV5670_MODE_TEST_PATTERN]);
+
+	dev_dbg(&client->dev, "%s--\n", __func__);
+	return 0;
+exit:
+	dev_dbg(&client->dev, "%s: error setting stream\n", __func__);
+	return err;
+}
+
+static int ov5670_g_input_status(struct v4l2_subdev *sd, u32 *status)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct ov5670 *priv = (struct ov5670 *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+
+	*status = pw->state == SWITCH_ON;
+	return 0;
+}
+
+static struct v4l2_subdev_video_ops ov5670_subdev_video_ops = {
+	.s_stream	= ov5670_s_stream,
+	.g_mbus_config	= camera_common_g_mbus_config,
+	.g_input_status = ov5670_g_input_status,
+};
+
+static struct v4l2_subdev_core_ops ov5670_subdev_core_ops = {
+	.s_power	= camera_common_s_power,
+};
+
+static int ov5670_get_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	return camera_common_g_fmt(sd, &format->format);
+}
+
+static int ov5670_set_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	int ret;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		ret = camera_common_try_fmt(sd, &format->format);
+	else
+		ret = camera_common_s_fmt(sd, &format->format);
+
+	return ret;
+}
+
+static struct v4l2_subdev_pad_ops ov5670_subdev_pad_ops = {
+	.set_fmt = ov5670_set_fmt,
+	.get_fmt = ov5670_get_fmt,
+	.enum_mbus_code = camera_common_enum_mbus_code,
+	.enum_frame_size	= camera_common_enum_framesizes,
+	.enum_frame_interval	= camera_common_enum_frameintervals,
+};
+
+static struct v4l2_subdev_ops ov5670_subdev_ops = {
+	.core	= &ov5670_subdev_core_ops,
+	.video	= &ov5670_subdev_video_ops,
+	.pad	= &ov5670_subdev_pad_ops,
+};
+
+static struct of_device_id ov5670_of_match[] = {
+	{ .compatible = "nvidia,ov5670", },
+	{ },
+};
+
+static struct camera_common_sensor_ops ov5670_common_ops = {
+	.power_on = ov5670_power_on,
+	.power_off = ov5670_power_off,
+	.write_reg = ov5670_write_reg,
+	.read_reg = ov5670_read_reg,
+};
+
+static int ov5670_set_group_hold(struct ov5670 *priv)
+{
+	int err;
+	int gh_prev = switch_ctrl_qmenu[priv->group_hold_prev];
+
+	if (priv->group_hold_en == true && gh_prev == SWITCH_OFF) {
+		/* enter group hold */
+		err = ov5670_write_reg(priv->s_data,
+				       OV5670_GROUP_HOLD_ADDR, 0x01);
+		if (err)
+			goto fail;
+
+		priv->group_hold_prev = 1;
+
+		dev_dbg(&priv->i2c_client->dev,
+			 "%s: enter group hold\n", __func__);
+	} else if (priv->group_hold_en == false && gh_prev == SWITCH_ON) {
+		/* leave group hold */
+		err = ov5670_write_reg(priv->s_data,
+				       OV5670_GROUP_HOLD_ADDR, 0x11);
+		if (err)
+			goto fail;
+
+		err = ov5670_write_reg(priv->s_data,
+				       OV5670_GROUP_HOLD_ADDR, 0x61);
+		if (err)
+			goto fail;
+
+		priv->group_hold_prev = 0;
+
+		dev_dbg(&priv->i2c_client->dev,
+			 "%s: leave group hold\n", __func__);
+	}
+
+	return 0;
+
+fail:
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: Group hold control error\n", __func__);
+	return err;
+}
+
+static u16 ov5670_to_real_gain(u32 rep, int shift)
+{
+	u16 gain;
+	int gain_int;
+	int gain_dec;
+	int min_int = (1 << shift);
+
+	if (rep < OV5670_MIN_GAIN)
+		rep = OV5670_MIN_GAIN;
+	else if (rep > OV5670_MAX_GAIN)
+		rep = OV5670_MAX_GAIN;
+
+	gain_int = (int)(rep >> shift);
+	gain_dec = (int)(rep & ~(0xffff << shift));
+
+	/* derived from formulat gain = (x * 16 + 0.5) */
+	gain = ((gain_int * min_int + gain_dec) * 32 + min_int) / (2 * min_int);
+
+	return gain;
+}
+
+static int ov5670_set_gain(struct ov5670 *priv, s32 val)
+{
+	ov5670_reg reg_list[2];
+	int err;
+	u16 gain;
+	int i;
+
+	if (!priv->group_hold_prev)
+		ov5670_set_group_hold(priv);
+
+	/* translate value */
+	gain = ov5670_to_real_gain((u32)val, OV5670_GAIN_SHIFT);
+
+	ov5670_get_gain_regs(reg_list, gain);
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: gain %04x val: %04x\n", __func__, val, gain);
+
+	for (i = 0; i < 2; i++) {
+		err = ov5670_write_reg(priv->s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: GAIN control error\n", __func__);
+	return err;
+}
+
+static void ov5670_update_ctrl_range(struct ov5670 *priv, s32 frame_length)
+{
+	struct v4l2_ctrl *ctrl = NULL;
+	int ctrl_ids[2] = {TEGRA_CAMERA_CID_COARSE_TIME,
+			TEGRA_CAMERA_CID_COARSE_TIME_SHORT};
+	s32 max, min, def;
+	int i, j;
+
+	for (i = 0; i < ARRAY_SIZE(ctrl_ids); i++) {
+		for (j = 0; j < priv->numctrls; j++) {
+			if (priv->ctrls[j]->id == ctrl_ids[i]) {
+				ctrl = priv->ctrls[j];
+				break;
+			}
+		}
+
+		if (j == priv->numctrls) {
+			dev_err(&priv->i2c_client->dev,
+				"could not find ctrl %x\n",
+				ctrl_ids[i]);
+			continue;
+		}
+
+		max = frame_length - OV5670_MAX_COARSE_DIFF;
+		/* clamp the value in case above is negative */
+		max = clamp_val(max, OV5670_MIN_EXPOSURE_COARSE,
+			OV5670_MAX_EXPOSURE_COARSE);
+		min = OV5670_MIN_EXPOSURE_COARSE;
+		def = clamp_val(OV5670_DEFAULT_EXPOSURE_COARSE, min, max);
+		if (__v4l2_ctrl_modify_range(ctrl, min, max, 1, def))
+			dev_err(&priv->i2c_client->dev,
+				"ctrl %x: range update failed\n",
+				ctrl_ids[i]);
+	}
+
+}
+
+static int ov5670_set_frame_length(struct ov5670 *priv, s32 val)
+{
+	ov5670_reg reg_list[2];
+	int err;
+	u32 frame_length;
+	int i;
+
+	if (!priv->group_hold_prev)
+		ov5670_set_group_hold(priv);
+
+	frame_length = (u32)val;
+
+	ov5670_get_frame_length_regs(reg_list, frame_length);
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: val: %d\n", __func__, frame_length);
+
+	for (i = 0; i < 2; i++) {
+		err = ov5670_write_reg(priv->s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+	priv->frame_length = frame_length;
+
+	ov5670_update_ctrl_range(priv, val);
+	return 0;
+
+fail:
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: FRAME_LENGTH control error\n", __func__);
+	return err;
+}
+
+static int ov5670_set_coarse_time(struct ov5670 *priv, s32 val)
+{
+	ov5670_reg reg_list[3];
+	int err;
+	u32 coarse_time;
+	int i;
+
+	if (!priv->group_hold_prev)
+		ov5670_set_group_hold(priv);
+
+	coarse_time = (u32)val;
+
+	ov5670_get_coarse_time_regs(reg_list, coarse_time);
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: val: %d\n", __func__, coarse_time);
+
+	for (i = 0; i < 3; i++) {
+		err = ov5670_write_reg(priv->s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: COARSE_TIME control error\n", __func__);
+	return err;
+}
+
+static int ov5670_set_coarse_time_short(struct ov5670 *priv, s32 val)
+{
+	ov5670_reg reg_list[3];
+	int err;
+	struct v4l2_control hdr_control;
+	int hdr_en;
+	u32 coarse_time_short;
+	int i;
+
+	if (!priv->group_hold_prev)
+		ov5670_set_group_hold(priv);
+
+	/* check hdr enable ctrl */
+	hdr_control.id = TEGRA_CAMERA_CID_HDR_EN;
+
+	err = camera_common_g_ctrl(priv->s_data, &hdr_control);
+	if (err < 0) {
+		dev_err(&priv->i2c_client->dev,
+			"could not find device ctrl.\n");
+		return err;
+	}
+
+	hdr_en = switch_ctrl_qmenu[hdr_control.value];
+	if (hdr_en == SWITCH_OFF)
+		return 0;
+
+	coarse_time_short = (u32)val;
+
+	ov5670_get_coarse_time_short_regs(reg_list, coarse_time_short);
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: val: %d\n", __func__, coarse_time_short);
+
+	for (i = 0; i < 3; i++) {
+		err = ov5670_write_reg(priv->s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: COARSE_TIME_SHORT control error\n", __func__);
+	return err;
+}
+
+static int ov5670_eeprom_device_release(struct ov5670 *priv)
+{
+	int i;
+
+	for (i = 0; i < OV5670_EEPROM_NUM_BLOCKS; i++) {
+		if (priv->eeprom[i].i2c_client != NULL) {
+			i2c_unregister_device(priv->eeprom[i].i2c_client);
+			priv->eeprom[i].i2c_client = NULL;
+		}
+	}
+
+	return 0;
+}
+
+static int ov5670_eeprom_device_init(struct ov5670 *priv)
+{
+	char *dev_name = "eeprom_ov5670";
+	static struct regmap_config eeprom_regmap_config = {
+		.reg_bits = 8,
+		.val_bits = 8,
+	};
+	int i;
+	int err;
+
+	if (!priv->pdata->has_eeprom)
+		return -EINVAL;
+
+	for (i = 0; i < OV5670_EEPROM_NUM_BLOCKS; i++) {
+		priv->eeprom[i].adap = i2c_get_adapter(
+				priv->i2c_client->adapter->nr);
+		memset(&priv->eeprom[i].brd, 0, sizeof(priv->eeprom[i].brd));
+		strncpy(priv->eeprom[i].brd.type, dev_name,
+				sizeof(priv->eeprom[i].brd.type));
+		priv->eeprom[i].brd.addr = OV5670_EEPROM_ADDRESS + i;
+		priv->eeprom[i].i2c_client = i2c_new_device(
+				priv->eeprom[i].adap, &priv->eeprom[i].brd);
+
+		priv->eeprom[i].regmap = devm_regmap_init_i2c(
+			priv->eeprom[i].i2c_client, &eeprom_regmap_config);
+		if (IS_ERR(priv->eeprom[i].regmap)) {
+			err = PTR_ERR(priv->eeprom[i].regmap);
+			ov5670_eeprom_device_release(priv);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static int ov5670_read_eeprom(struct ov5670 *priv,
+				struct v4l2_ctrl *ctrl)
+{
+	int err, i;
+
+	for (i = 0; i < OV5670_EEPROM_NUM_BLOCKS; i++) {
+		err = regmap_bulk_read(priv->eeprom[i].regmap, 0,
+			&priv->eeprom_buf[i * OV5670_EEPROM_BLOCK_SIZE],
+			OV5670_EEPROM_BLOCK_SIZE);
+		if (err)
+			return err;
+	}
+
+	for (i = 0; i < OV5670_EEPROM_SIZE; i++)
+		sprintf(&ctrl->p_new.p_char[i*2], "%02x",
+			priv->eeprom_buf[i]);
+	return 0;
+}
+
+static int ov5670_write_eeprom(struct ov5670 *priv,
+				char *string)
+{
+	int err;
+	int i;
+	u8 curr[3];
+	unsigned long data;
+
+	for (i = 0; i < OV5670_EEPROM_SIZE; i++) {
+		curr[0] = string[i*2];
+		curr[1] = string[i*2+1];
+		curr[2] = '\0';
+
+		err = kstrtol(curr, 16, &data);
+		if (err) {
+			dev_err(&priv->i2c_client->dev,
+				"invalid eeprom string\n");
+			return -EINVAL;
+		}
+
+		priv->eeprom_buf[i] = (u8)data;
+		err = regmap_write(priv->eeprom[i >> 8].regmap,
+				   i & 0xFF, (u8)data);
+		if (err)
+			return err;
+		msleep(20);
+	}
+	return 0;
+}
+
+static int ov5670_read_otp_bank(struct ov5670 *priv,
+				u8 *buf, int bank, u16 addr, int size)
+{
+	int err;
+
+	/* sleeps calls in the sequence below are for internal device
+	 * signal propagation as specified by sensor vendor */
+
+	usleep_range(10000, 11000);
+	err = ov5670_write_table(priv, mode_table[OV5670_MODE_START_STREAM]);
+	if (err)
+		return err;
+
+	err = ov5670_write_reg(priv->s_data, OV5670_OTP_BANK_SELECT_ADDR,
+			       0xC0 | bank);
+	if (err)
+		return err;
+
+	err = ov5670_write_reg(priv->s_data, OV5670_OTP_LOAD_CTRL_ADDR, 0x01);
+	if (err)
+		return err;
+
+	usleep_range(10000, 11000);
+	err = regmap_bulk_read(priv->regmap, addr, buf, size);
+	if (err)
+		return err;
+
+	err = ov5670_write_table(priv,
+			mode_table[OV5670_MODE_STOP_STREAM]);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int ov5670_otp_setup(struct ov5670 *priv)
+{
+	int err;
+	int i;
+	struct v4l2_ctrl *ctrl;
+	u8 otp_buf[OV5670_OTP_SIZE];
+
+	err = camera_common_s_power(priv->subdev, true);
+	if (err)
+		return -ENODEV;
+
+	for (i = 0; i < OV5670_OTP_NUM_BANKS; i++) {
+		err = ov5670_read_otp_bank(priv,
+					&otp_buf[i * OV5670_OTP_BANK_SIZE],
+					i,
+					OV5670_OTP_BANK_START_ADDR,
+					OV5670_OTP_BANK_SIZE);
+		if (err) {
+			dev_err(&priv->i2c_client->dev,
+				"could not read otp bank\n");
+			goto ret;
+		}
+	}
+
+	ctrl = v4l2_ctrl_find(&priv->ctrl_handler, TEGRA_CAMERA_CID_OTP_DATA);
+	if (!ctrl) {
+		dev_err(&priv->i2c_client->dev,
+			"could not find device ctrl.\n");
+		err = -EINVAL;
+		goto ret;
+	}
+
+	for (i = 0; i < OV5670_OTP_SIZE; i++)
+		sprintf(&ctrl->p_new.p_char[i*2], "%02x",
+			otp_buf[i]);
+	ctrl->p_cur.p_char = ctrl->p_new.p_char;
+
+ret:
+	camera_common_s_power(priv->subdev, false);
+
+	return err;
+}
+
+static int ov5670_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov5670 *priv =
+		container_of(ctrl->handler, struct ov5670, ctrl_handler);
+	int err = 0;
+
+	if (priv->power.state == SWITCH_OFF)
+		return 0;
+
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_EEPROM_DATA:
+		err = ov5670_read_eeprom(priv, ctrl);
+		if (err)
+			return err;
+		break;
+	default:
+			pr_err("%s: unknown ctrl id.\n", __func__);
+			return -EINVAL;
+	}
+
+	return err;
+}
+
+static int ov5670_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov5670 *priv =
+		container_of(ctrl->handler, struct ov5670, ctrl_handler);
+	int err = 0;
+
+	if (priv->power.state == SWITCH_OFF)
+		return 0;
+
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_GAIN:
+		err = ov5670_set_gain(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_FRAME_LENGTH:
+		err = ov5670_set_frame_length(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_COARSE_TIME:
+		err = ov5670_set_coarse_time(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_COARSE_TIME_SHORT:
+		err = ov5670_set_coarse_time_short(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_GROUP_HOLD:
+		if (switch_ctrl_qmenu[ctrl->val] == SWITCH_ON) {
+			priv->group_hold_en = true;
+		} else {
+			priv->group_hold_en = false;
+			err = ov5670_set_group_hold(priv);
+		}
+		break;
+	case TEGRA_CAMERA_CID_EEPROM_DATA:
+		if (!ctrl->p_new.p_char[0])
+			break;
+		err = ov5670_write_eeprom(priv, ctrl->p_new.p_char);
+		if (err)
+			return err;
+		break;
+	case TEGRA_CAMERA_CID_HDR_EN:
+		break;
+	default:
+		pr_err("%s: unknown ctrl id.\n", __func__);
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static int ov5670_ctrls_init(struct ov5670 *priv, bool eeprom_ctrl)
+{
+	struct i2c_client *client = priv->i2c_client;
+	struct camera_common_data *common_data = priv->s_data;
+	struct v4l2_ctrl *ctrl;
+	int numctrls;
+	int err;
+	int i;
+
+	dev_dbg(&client->dev, "%s++\n", __func__);
+
+	numctrls = ARRAY_SIZE(ctrl_config_list);
+	v4l2_ctrl_handler_init(&priv->ctrl_handler, numctrls);
+
+	for (i = 0; i < numctrls; i++) {
+		/*
+		 * Skip control 'TEGRA_CAMERA_CID_EEPROM_DATA'
+		 * if eeprom inint err
+		 */
+		if (ctrl_config_list[i].id == TEGRA_CAMERA_CID_EEPROM_DATA) {
+			if (!eeprom_ctrl) {
+				common_data->numctrls -= 1;
+				continue;
+			}
+		}
+
+		ctrl = v4l2_ctrl_new_custom(&priv->ctrl_handler,
+			&ctrl_config_list[i], NULL);
+		if (ctrl == NULL) {
+			dev_err(&client->dev, "Failed to init %s ctrl\n",
+				ctrl_config_list[i].name);
+			continue;
+		}
+
+		if (ctrl_config_list[i].type == V4L2_CTRL_TYPE_STRING &&
+			ctrl_config_list[i].flags & V4L2_CTRL_FLAG_READ_ONLY) {
+			ctrl->p_new.p_char = devm_kzalloc(&client->dev,
+				ctrl_config_list[i].max + 1, GFP_KERNEL);
+			if (!ctrl->p_new.p_char)
+				return -ENOMEM;
+		}
+		priv->ctrls[i] = ctrl;
+	}
+
+	priv->numctrls = numctrls;
+	priv->subdev->ctrl_handler = &priv->ctrl_handler;
+	if (priv->ctrl_handler.error) {
+		dev_err(&client->dev, "Error %d adding controls\n",
+			priv->ctrl_handler.error);
+		err = priv->ctrl_handler.error;
+		goto error;
+	}
+
+	err = v4l2_ctrl_handler_setup(&priv->ctrl_handler);
+	if (err) {
+		dev_err(&client->dev,
+			"Error %d setting default controls\n", err);
+		goto error;
+	}
+
+	err = ov5670_otp_setup(priv);
+	if (err) {
+		dev_err(&client->dev,
+			"Error %d reading otp data\n", err);
+		goto error;
+	}
+
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	return err;
+}
+
+MODULE_DEVICE_TABLE(of, ov5670_of_match);
+
+static struct camera_common_pdata *ov5670_parse_dt(struct i2c_client *client)
+{
+	struct device_node *node = client->dev.of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	const struct of_device_id *match;
+	int gpio;
+	int err;
+	struct camera_common_pdata *ret = NULL;
+
+	if (!node)
+		return NULL;
+
+	match = of_match_device(ov5670_of_match, &client->dev);
+	if (!match) {
+		dev_err(&client->dev, "Failed to find matching dt id\n");
+		return NULL;
+	}
+
+	board_priv_pdata = devm_kzalloc(&client->dev,
+			   sizeof(*board_priv_pdata), GFP_KERNEL);
+	if (!board_priv_pdata)
+		return NULL;
+
+	err = camera_common_parse_clocks(&client->dev, board_priv_pdata);
+	if (err) {
+		dev_err(&client->dev, "Failed to find clocks\n");
+		goto error;
+	}
+
+	gpio = of_get_named_gpio(node, "pwdn-gpios", 0);
+	if (gpio < 0) {
+		if (gpio == -EPROBE_DEFER) {
+			ret = ERR_PTR(-EPROBE_DEFER);
+			goto error;
+		}
+		dev_err(&client->dev, "pwdn gpios not in DT\n");
+		goto error;
+	}
+	board_priv_pdata->pwdn_gpio = (unsigned int)gpio;
+
+	gpio = of_get_named_gpio(node, "reset-gpios", 0);
+	if (gpio < 0) {
+		/* reset-gpio is not absolutely needed */
+		if (gpio == -EPROBE_DEFER) {
+			ret = ERR_PTR(-EPROBE_DEFER);
+			goto error;
+		}
+		dev_dbg(&client->dev, "reset gpios not in DT\n");
+		gpio = 0;
+	}
+	board_priv_pdata->reset_gpio = (unsigned int)gpio;
+
+	board_priv_pdata->use_cam_gpio =
+		of_property_read_bool(node, "cam,use-cam-gpio");
+
+	err = of_property_read_string(node, "avdd-reg",
+			&board_priv_pdata->regulators.avdd);
+	if (err) {
+		dev_err(&client->dev, "avdd-reg not in DT\n");
+		goto error;
+	}
+	err = of_property_read_string(node, "dvdd-reg",
+			&board_priv_pdata->regulators.dvdd);
+	if (err) {
+		dev_err(&client->dev, "dvdd-reg not in DT\n");
+		goto error;
+	}
+
+	board_priv_pdata->has_eeprom =
+		of_property_read_bool(node, "has-eeprom");
+	board_priv_pdata->v_flip = of_property_read_bool(node, "vertical-flip");
+	board_priv_pdata->h_mirror = of_property_read_bool(node,
+							 "horizontal-mirror");
+	return board_priv_pdata;
+
+error:
+	devm_kfree(&client->dev, board_priv_pdata);
+	return ret;
+}
+
+static int ov5670_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev_dbg(&client->dev, "%s:\n", __func__);
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops ov5670_subdev_internal_ops = {
+	.open = ov5670_open,
+};
+
+static const struct media_entity_operations ov5670_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static int ov5670_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct camera_common_data *common_data;
+	struct device_node *node = client->dev.of_node;
+	struct ov5670 *priv;
+	int err;
+
+	pr_info("[OV5670]: probing v4l2 sensor.\n");
+
+	if (!IS_ENABLED(CONFIG_OF) || !node)
+		return -EINVAL;
+
+	common_data = devm_kzalloc(&client->dev,
+			    sizeof(struct camera_common_data), GFP_KERNEL);
+	if (!common_data)
+		return -ENOMEM;
+
+	priv = devm_kzalloc(&client->dev,
+			    sizeof(struct ov5670) + sizeof(struct v4l2_ctrl *) *
+			    ARRAY_SIZE(ctrl_config_list),
+			    GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->regmap = devm_regmap_init_i2c(client, &ov5670_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(&client->dev,
+			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
+		return -ENODEV;
+	}
+
+	priv->pdata = ov5670_parse_dt(client);
+	if (PTR_ERR(priv->pdata) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	if (!priv->pdata) {
+		dev_err(&client->dev, "unable to get platform data\n");
+		return -EFAULT;
+	}
+
+	common_data->ops		= &ov5670_common_ops;
+	common_data->ctrl_handler	= &priv->ctrl_handler;
+	common_data->dev		= &client->dev;
+	common_data->frmfmt		= ov5670_frmfmt;
+	common_data->colorfmt		= camera_common_find_datafmt(
+					  OV5670_DEFAULT_DATAFMT);
+	common_data->power		= &priv->power;
+	common_data->ctrls		= priv->ctrls;
+	common_data->priv		= (void *)priv;
+	common_data->numctrls		= ARRAY_SIZE(ctrl_config_list);
+	common_data->numfmts		= ARRAY_SIZE(ov5670_frmfmt);
+	common_data->def_mode		= OV5670_DEFAULT_MODE;
+	common_data->def_width		= OV5670_DEFAULT_WIDTH;
+	common_data->def_height		= OV5670_DEFAULT_HEIGHT;
+	common_data->fmt_width		= common_data->def_width;
+	common_data->fmt_height		= common_data->def_height;
+	common_data->def_clk_freq	= OV5670_DEFAULT_CLK_FREQ;
+
+	priv->i2c_client = client;
+	priv->s_data			= common_data;
+	priv->subdev			= &common_data->subdev;
+	priv->subdev->dev		= &client->dev;
+	priv->s_data->dev		= &client->dev;
+
+	err = ov5670_power_get(priv);
+	if (err)
+		return err;
+
+	err = camera_common_initialize(common_data, "ov5670");
+	if (err) {
+		dev_err(&client->dev, "Failed to initialize ov5670.\n");
+		return err;
+	}
+
+
+	v4l2_i2c_subdev_init(priv->subdev, client, &ov5670_subdev_ops);
+
+	/* eeprom interface */
+	err = ov5670_eeprom_device_init(priv);
+	if (err && priv->pdata->has_eeprom)
+		dev_err(&client->dev,
+			"Failed to allocate eeprom reg map: %d\n", err);
+
+	err = ov5670_ctrls_init(priv, !err);
+	if (err)
+		return err;
+
+	priv->subdev->internal_ops = &ov5670_subdev_internal_ops;
+	priv->subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+			       V4L2_SUBDEV_FL_HAS_EVENTS;
+
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	priv->subdev->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+	priv->subdev->entity.ops = &ov5670_media_ops;
+	err = media_entity_init(&priv->subdev->entity, 1, &priv->pad, 0);
+	if (err < 0) {
+		dev_err(&client->dev, "unable to init media entity\n");
+		return err;
+	}
+#endif
+
+	err = v4l2_async_register_subdev(priv->subdev);
+	if (err)
+		return err;
+
+	dev_dbg(&client->dev, "Detected OV5670 sensor\n");
+
+
+	return 0;
+}
+
+static int
+ov5670_remove(struct i2c_client *client)
+{
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct ov5670 *priv = (struct ov5670 *)s_data->priv;
+
+	v4l2_async_unregister_subdev(priv->subdev);
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	media_entity_cleanup(&priv->subdev->entity);
+#endif
+
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	ov5670_power_put(priv);
+	camera_common_cleanup(s_data);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov5670_id[] = {
+	{ "ov5670", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, ov5670_id);
+
+static struct i2c_driver ov5670_i2c_driver = {
+	.driver = {
+		.name = "ov5670",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(ov5670_of_match),
+	},
+	.probe = ov5670_probe,
+	.remove = ov5670_remove,
+	.id_table = ov5670_id,
+};
+
+module_i2c_driver(ov5670_i2c_driver);
+
+MODULE_DESCRIPTION("SoC Camera driver for Sony OV5670");
+MODULE_AUTHOR("David Wang <davidw@nvidia.com>");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/media/i2c/ov5670_mode_tbls.h b/drivers/media/i2c/ov5670_mode_tbls.h
new file mode 100755
index 0000000..ec1fd91
--- /dev/null
+++ b/drivers/media/i2c/ov5670_mode_tbls.h
@@ -0,0 +1,2955 @@
+/*
+ * ov5670_mode_tbls.h - ov5670 sensor mode tables
+ *
+ * Copyright (c) 2015-2017, NVIDIA CORPORATION, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __OV5670_TABLES__
+#define __OV5670_TABLES__
+
+#include <media/camera_common.h>
+
+#define OV5670_TABLE_WAIT_MS	0
+#define OV5670_TABLE_END	1
+#define OV5670_MAX_RETRIES	3
+#define OV5670_WAIT_MS		10
+
+#define ov5670_reg struct reg_8
+
+static const ov5670_reg ov5670_start[] = {
+	{0x0100, 0x01}, /* mode select streaming on */
+	{OV5670_TABLE_END, 0x00}
+};
+
+static const ov5670_reg ov5670_stop[] = {
+	{0x0100, 0x00}, /* mode select streaming on */
+	{OV5670_TABLE_END, 0x00}
+};
+
+static const ov5670_reg tp_colorbars[] = {
+	{0x4303, 0x08},
+	{0x4320, 0x80},
+
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{OV5670_TABLE_END, 0x00}
+};
+
+static const ov5670_reg ov5670_pll_840mbps[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{ 0x030a, 0x00 },
+	{ 0x0300, 0x04 },
+	{ 0x0301, 0x00 },
+	{ 0x0302, 0x78 },
+	{ 0x0304, 0x03 },
+	{ 0x0303, 0x00 },
+	{ 0x0305, 0x01 },
+	{ 0x0306, 0x01 },
+	{ 0x0312, 0x01 },
+	{ 0x030b, 0x00 },
+	{ 0x030c, 0x00 },
+	{ 0x030d, 0x1e },
+	{ 0x030f, 0x06 },
+	{ 0x030e, 0x00 },
+	{OV5670_TABLE_END, 0x00}
+};
+
+static const ov5670_reg mode_2592x1944_regs[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x3000, 0x00},
+	{0x3002, 0x21},
+	{0x3005, 0xf0},
+	{0x3007, 0x00},
+	{0x3015, 0x0f},
+	{0x3018, 0x32},
+	{0x301a, 0xf0},
+	{0x301b, 0xf0},
+	{0x301c, 0xf0},
+	{0x301d, 0xf0},
+	{0x301e, 0xf0},
+	{0x3030, 0x00},
+	{0x3031, 0x0a},
+	{0x303c, 0xff},
+	{0x303e, 0xff},
+	{0x3040, 0xf0},
+	{0x3041, 0x00},
+	{0x3042, 0xf0},
+	{0x3106, 0x11},
+	{0x3500, 0x00},
+	{0x3501, 0x80},
+	{0x3502, 0x00},
+	{0x3503, 0x04},
+	{0x3504, 0x03},
+	{0x3505, 0x83},
+	{0x3508, 0x04},
+	{0x3509, 0x00},
+	{0x350e, 0x04},
+	{0x350f, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3601, 0xc8},
+	{0x3610, 0x88},
+	{0x3612, 0x48},
+	{0x3614, 0x5b},
+	{0x3615, 0x96},
+	{0x3621, 0xd0},
+	{0x3622, 0x00},
+	{0x3623, 0x00},
+	{0x3633, 0x13},
+	{0x3634, 0x13},
+	{0x3635, 0x13},
+	{0x3636, 0x13},
+	{0x3645, 0x13},
+	{0x3646, 0x82},
+	{0x3650, 0x00},
+	{0x3652, 0xff},
+	{0x3655, 0x20},
+	{0x3656, 0xff},
+	{0x365a, 0xff},
+	{0x365e, 0xff},
+	{0x3668, 0x00},
+	{0x366a, 0x07},
+	{0x366e, 0x10},
+	{0x366d, 0x00},
+	{0x366f, 0x80},
+	{0x3700, 0x28},
+	{0x3701, 0x10},
+	{0x3702, 0x3a},
+	{0x3703, 0x19},
+	{0x3704, 0x10},
+	{0x3705, 0x00},
+	{0x3706, 0x66},
+	{0x3707, 0x08},
+	{0x3708, 0x34},
+	{0x3709, 0x40},
+	{0x370a, 0x01},
+	{0x370b, 0x1b},
+	{0x3714, 0x24},
+	{0x371a, 0x3e},
+	{0x3733, 0x00},
+	{0x3734, 0x00},
+	{0x373a, 0x05},
+	{0x373b, 0x06},
+	{0x373c, 0x0a},
+	{0x373f, 0xa0},
+	{0x3755, 0x00},
+	{0x3758, 0x00},
+	{0x375b, 0x0e},
+	{0x3766, 0x5f},
+	{0x3768, 0x00},
+	{0x3769, 0x22},
+	{0x3773, 0x08},
+	{0x3774, 0x1f},
+	{0x3776, 0x06},
+	{0x37a0, 0x88},
+	{0x37a1, 0x5c},
+	{0x37a7, 0x88},
+	{0x37a8, 0x70},
+	{0x37aa, 0x88},
+	{0x37ab, 0x48},
+	{0x37b3, 0x66},
+	{0x37c2, 0x04},
+	{0x37c5, 0x00},
+	{0x37c8, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x0c},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3804, 0x0a},
+	{0x3805, 0x33},
+	{0x3806, 0x07},
+	{0x3807, 0xa3},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x07},
+	{0x380b, 0x98},
+	{0x380c, 0x06},
+	{0x380d, 0x90},
+	{0x380e, 0x08},
+	{0x380f, 0x08},
+	{0x3811, 0x04},
+	{0x3813, 0x02},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x00},
+	{0x3817, 0x00},
+	{0x3818, 0x00},
+	{0x3819, 0x00},
+	{0x3820, 0x02},
+	{0x3821, 0x46},
+	{0x3822, 0x48},
+	{0x3826, 0x00},
+	{0x3827, 0x08},
+	{0x382a, 0x01},
+	{0x382b, 0x01},
+	{0x3830, 0x08},
+	{0x3836, 0x02},
+	{0x3837, 0x00},
+	{0x3838, 0x10},
+	{0x3841, 0xff},
+	{0x3846, 0x48},
+	{0x3861, 0x00},
+	{0x3862, 0x04},
+	{0x3863, 0x06},
+	{0x3a11, 0x01},
+	{0x3a12, 0x78},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3c00, 0x89},
+	{0x3c01, 0xab},
+	{0x3c02, 0x01},
+	{0x3c03, 0x00},
+	{0x3c04, 0x00},
+	{0x3c05, 0x03},
+	{0x3c06, 0x00},
+	{0x3c07, 0x05},
+	{0x3c0c, 0x00},
+	{0x3c0d, 0x00},
+	{0x3c0e, 0x00},
+	{0x3c0f, 0x00},
+	{0x3c40, 0x00},
+	{0x3c41, 0xa3},
+	{0x3c43, 0x7d},
+	{0x3c45, 0xd7},
+	{0x3c47, 0xfc},
+	{0x3c50, 0x05},
+	{0x3c52, 0xaa},
+	{0x3c54, 0x71},
+	{0x3c56, 0x80},
+	{0x3d85, 0x17},
+	{0x3f03, 0x00},
+	{0x3f0a, 0x00},
+	{0x3f0b, 0x00},
+	{0x4001, 0x60},
+	{0x4009, 0x0d},
+	{0x4020, 0x00},
+	{0x4021, 0x00},
+	{0x4022, 0x00},
+	{0x4023, 0x00},
+	{0x4024, 0x00},
+	{0x4025, 0x00},
+	{0x4026, 0x00},
+	{0x4027, 0x00},
+	{0x4028, 0x00},
+	{0x4029, 0x00},
+	{0x402a, 0x00},
+	{0x402b, 0x00},
+	{0x402c, 0x00},
+	{0x402d, 0x00},
+	{0x402e, 0x00},
+	{0x402f, 0x00},
+	{0x4040, 0x00},
+	{0x4041, 0x03},
+	{0x4042, 0x00},
+	{0x4043, 0x7A},
+	{0x4044, 0x00},
+	{0x4045, 0x7A},
+	{0x4046, 0x00},
+	{0x4047, 0x7A},
+	{0x4048, 0x00},
+	{0x4049, 0x7A},
+	{0x4307, 0x30},
+	{0x4500, 0x58},
+	{0x4501, 0x04},
+	{0x4502, 0x40},
+	{0x4503, 0x10},
+	{0x4508, 0xaa},
+	{0x4509, 0xaa},
+	{0x450a, 0x00},
+	{0x450b, 0x00},
+	{0x4600, 0x01},
+	{0x4601, 0x03},
+	{0x4700, 0xa4},
+	{0x4800, 0x4c},
+	{0x4816, 0x53},
+	{0x481f, 0x40},
+	{0x4837, 0x13},
+	{0x5000, 0x56},
+	{0x5001, 0x01},
+	{0x5002, 0x28},
+	{0x5004, 0x0c},
+	{0x5006, 0x0c},
+	{0x5007, 0xe0},
+	{0x5008, 0x01},
+	{0x5009, 0xb0},
+	{0x5901, 0x00},
+	{0x5a01, 0x00},
+	{0x5a03, 0x00},
+	{0x5a04, 0x0c},
+	{0x5a05, 0xe0},
+	{0x5a06, 0x09},
+	{0x5a07, 0xb0},
+	{0x5a08, 0x06},
+	{0x5e00, 0x00},
+	{0x3734, 0x40},
+	{0x5b00, 0x01},
+	{0x5b01, 0x10},
+	{0x5b02, 0x01},
+	{0x5b03, 0xdb},
+	{0x3d8c, 0x71},
+	{0x3d8d, 0xea},
+	{0x4017, 0x08},
+	{0x3618, 0x2a},
+	{0x5780, 0x3e},
+	{0x5781, 0x0f},
+	{0x5782, 0x44},
+	{0x5783, 0x02},
+	{0x5784, 0x01},
+	{0x5785, 0x01},
+	{0x5786, 0x00},
+	{0x5787, 0x04},
+	{0x5788, 0x02},
+	{0x5789, 0x0f},
+	{0x578a, 0xfd},
+	{0x578b, 0xf5},
+	{0x578c, 0xf5},
+	{0x578d, 0x03},
+	{0x578e, 0x08},
+	{0x578f, 0x0c},
+	{0x5790, 0x08},
+	{0x5791, 0x06},
+	{0x5792, 0x00},
+	{0x5793, 0x52},
+	{0x5794, 0xa3},
+	{0x3503, 0x00},
+	{0x5045, 0x05},
+	{0x4003, 0x40},
+	{0x5048, 0x40},
+	{OV5670_TABLE_END, 0x0000}
+};
+static const ov5670_reg mode_2592x1944[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3090, 0x02},
+	{0x3091, 0x0e},
+	{0x3092, 0x00},
+	{0x3093, 0x00},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x18},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x02},
+	{0x3802, 0x00},
+	{0x3803, 0x02},
+	{0x3804, 0x0a},
+	{0x3805, 0x41},
+	{0x3806, 0x07},
+	{0x3807, 0xa5},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x07},
+	{0x380b, 0x98},
+	{0x380c, 0x0a},
+	{0x380d, 0x80},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x02},
+	{0x3821, 0x1e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3d00, 0x00},
+	{0x3d01, 0x00},
+	{0x3d02, 0x00},
+	{0x3d03, 0x00},
+	{0x3d04, 0x00},
+	{0x3d05, 0x00},
+	{0x3d06, 0x00},
+	{0x3d07, 0x00},
+	{0x3d08, 0x00},
+	{0x3d09, 0x00},
+	{0x3d0a, 0x00},
+	{0x3d0b, 0x00},
+	{0x3d0c, 0x00},
+	{0x3d0d, 0x00},
+	{0x3d0e, 0x00},
+	{0x3d0f, 0x00},
+	{0x3d80, 0x00},
+	{0x3d81, 0x00},
+	{0x3d84, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_2560x1440_regs[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x3000, 0x00},
+	{0x3002, 0x21},
+	{0x3005, 0xf0},
+	{0x3007, 0x00},
+	{0x3015, 0x0f},
+	{0x3018, 0x32},
+	{0x301a, 0xf0},
+	{0x301b, 0xf0},
+	{0x301c, 0xf0},
+	{0x301d, 0xf0},
+	{0x301e, 0xf0},
+	{0x3030, 0x00},
+	{0x3031, 0x0a},
+	{0x303c, 0xff},
+	{0x303e, 0xff},
+	{0x3040, 0xf0},
+	{0x3041, 0x00},
+	{0x3042, 0xf0},
+	{0x3106, 0x11},
+	{0x3500, 0x00},
+	{0x3501, 0x80},
+	{0x3502, 0x00},
+	{0x3503, 0x04},
+	{0x3504, 0x03},
+	{0x3505, 0x83},
+	{0x3508, 0x04},
+	{0x3509, 0x00},
+	{0x350e, 0x04},
+	{0x350f, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3601, 0xc8},
+	{0x3610, 0x88},
+	{0x3612, 0x48},
+	{0x3614, 0x5b},
+	{0x3615, 0x96},
+	{0x3621, 0xd0},
+	{0x3622, 0x00},
+	{0x3623, 0x00},
+	{0x3633, 0x13},
+	{0x3634, 0x13},
+	{0x3635, 0x13},
+	{0x3636, 0x13},
+	{0x3645, 0x13},
+	{0x3646, 0x82},
+	{0x3650, 0x00},
+	{0x3652, 0xff},
+	{0x3655, 0x20},
+	{0x3656, 0xff},
+	{0x365a, 0xff},
+	{0x365e, 0xff},
+	{0x3668, 0x00},
+	{0x366a, 0x07},
+	{0x366e, 0x10},
+	{0x366d, 0x00},
+	{0x366f, 0x80},
+	{0x3700, 0x28},
+	{0x3701, 0x10},
+	{0x3702, 0x3a},
+	{0x3703, 0x19},
+	{0x3704, 0x10},
+	{0x3705, 0x00},
+	{0x3706, 0x66},
+	{0x3707, 0x08},
+	{0x3708, 0x34},
+	{0x3709, 0x40},
+	{0x370a, 0x01},
+	{0x370b, 0x1b},
+	{0x3714, 0x24},
+	{0x371a, 0x3e},
+	{0x3733, 0x00},
+	{0x3734, 0x00},
+	{0x373a, 0x05},
+	{0x373b, 0x06},
+	{0x373c, 0x0a},
+	{0x373f, 0xa0},
+	{0x3755, 0x00},
+	{0x3758, 0x00},
+	{0x375b, 0x0e},
+	{0x3766, 0x5f},
+	{0x3768, 0x00},
+	{0x3769, 0x22},
+	{0x3773, 0x08},
+	{0x3774, 0x1f},
+	{0x3776, 0x06},
+	{0x37a0, 0x88},
+	{0x37a1, 0x5c},
+	{0x37a7, 0x88},
+	{0x37a8, 0x70},
+	{0x37aa, 0x88},
+	{0x37ab, 0x48},
+	{0x37b3, 0x66},
+	{0x37c2, 0x04},
+	{0x37c5, 0x00},
+	{0x37c8, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x0c},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3804, 0x0a},
+	{0x3805, 0x33},
+	{0x3806, 0x07},
+	{0x3807, 0xa3},
+	{0x3808, 0x0a},
+	{0x3809, 0x00},
+	{0x380a, 0x05},
+	{0x380b, 0xa0},
+	{0x380c, 0x06},
+	{0x380d, 0x90},
+	{0x380e, 0x08},
+	{0x380f, 0x08},
+	{0x3811, 0x04},
+	{0x3813, 0x02},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x00},
+	{0x3817, 0x00},
+	{0x3818, 0x00},
+	{0x3819, 0x00},
+	{0x3820, 0x84},
+	{0x3821, 0x46},
+	{0x3822, 0x48},
+	{0x3826, 0x00},
+	{0x3827, 0x08},
+	{0x382a, 0x01},
+	{0x382b, 0x01},
+	{0x3830, 0x08},
+	{0x3836, 0x02},
+	{0x3837, 0x00},
+	{0x3838, 0x10},
+	{0x3841, 0xff},
+	{0x3846, 0x48},
+	{0x3861, 0x00},
+	{0x3862, 0x04},
+	{0x3863, 0x06},
+	{0x3a11, 0x01},
+	{0x3a12, 0x78},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3c00, 0x89},
+	{0x3c01, 0xab},
+	{0x3c02, 0x01},
+	{0x3c03, 0x00},
+	{0x3c04, 0x00},
+	{0x3c05, 0x03},
+	{0x3c06, 0x00},
+	{0x3c07, 0x05},
+	{0x3c0c, 0x00},
+	{0x3c0d, 0x00},
+	{0x3c0e, 0x00},
+	{0x3c0f, 0x00},
+	{0x3c40, 0x00},
+	{0x3c41, 0xa3},
+	{0x3c43, 0x7d},
+	{0x3c45, 0xd7},
+	{0x3c47, 0xfc},
+	{0x3c50, 0x05},
+	{0x3c52, 0xaa},
+	{0x3c54, 0x71},
+	{0x3c56, 0x80},
+	{0x3d85, 0x17},
+	{0x3f03, 0x00},
+	{0x3f0a, 0x00},
+	{0x3f0b, 0x00},
+	{0x4001, 0x60},
+	{0x4009, 0x0d},
+	{0x4020, 0x00},
+	{0x4021, 0x00},
+	{0x4022, 0x00},
+	{0x4023, 0x00},
+	{0x4024, 0x00},
+	{0x4025, 0x00},
+	{0x4026, 0x00},
+	{0x4027, 0x00},
+	{0x4028, 0x00},
+	{0x4029, 0x00},
+	{0x402a, 0x00},
+	{0x402b, 0x00},
+	{0x402c, 0x00},
+	{0x402d, 0x00},
+	{0x402e, 0x00},
+	{0x402f, 0x00},
+	{0x4040, 0x00},
+	{0x4041, 0x03},
+	{0x4042, 0x00},
+	{0x4043, 0x7A},
+	{0x4044, 0x00},
+	{0x4045, 0x7A},
+	{0x4046, 0x00},
+	{0x4047, 0x7A},
+	{0x4048, 0x00},
+	{0x4049, 0x7A},
+	{0x4307, 0x30},
+	{0x4500, 0x58},
+	{0x4501, 0x04},
+	{0x4502, 0x40},
+	{0x4503, 0x10},
+	{0x4508, 0xaa},
+	{0x4509, 0xaa},
+	{0x450a, 0x00},
+	{0x450b, 0x00},
+	{0x4600, 0x01},
+	{0x4601, 0x00},
+	{0x4700, 0xa4},
+	{0x4800, 0x4c},
+	{0x4816, 0x53},
+	{0x481f, 0x40},
+	{0x4837, 0x13},
+	{0x5000, 0x56},
+	{0x5001, 0x01},
+	{0x5002, 0x28},
+	{0x5004, 0x0c},
+	{0x5006, 0x0c},
+	{0x5007, 0xe0},
+	{0x5008, 0x01},
+	{0x5009, 0xb0},
+	{0x5901, 0x00},
+	{0x5a01, 0x00},
+	{0x5a03, 0x00},
+	{0x5a04, 0x0c},
+	{0x5a05, 0xe0},
+	{0x5a06, 0x09},
+	{0x5a07, 0xb0},
+	{0x5a08, 0x06},
+	{0x5e00, 0x00},
+	{0x3734, 0x40},
+	{0x5b00, 0x01},
+	{0x5b01, 0x10},
+	{0x5b02, 0x01},
+	{0x5b03, 0xdb},
+	{0x3d8c, 0x71},
+	{0x3d8d, 0xea},
+	{0x4017, 0x08},
+	{0x3618, 0x2a},
+	{0x5780, 0x3e},
+	{0x5781, 0x0f},
+	{0x5782, 0x44},
+	{0x5783, 0x02},
+	{0x5784, 0x01},
+	{0x5785, 0x01},
+	{0x5786, 0x00},
+	{0x5787, 0x04},
+	{0x5788, 0x02},
+	{0x5789, 0x0f},
+	{0x578a, 0xfd},
+	{0x578b, 0xf5},
+	{0x578c, 0xf5},
+	{0x578d, 0x03},
+	{0x578e, 0x08},
+	{0x578f, 0x0c},
+	{0x5790, 0x08},
+	{0x5791, 0x06},
+	{0x5792, 0x00},
+	{0x5793, 0x52},
+	{0x5794, 0xa3},
+	{0x5045, 0x05},
+	{0x4003, 0x40},
+	{0x5048, 0x40},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_2592x1458[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3400, 0x04},
+	{0x3401, 0x00},
+	{0x3402, 0x04},
+	{0x3403, 0x00},
+	{0x3404, 0x04},
+	{0x3405, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3600, 0xbc},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x44},
+	{0x3621, 0xb5},
+	{0x3622, 0x0c},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0xf4},
+	{0x3804, 0x0a},
+	{0x3805, 0x3f},
+	{0x3806, 0x06},
+	{0x3807, 0xb1},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x05},
+	{0x380b, 0xb2},
+	{0x380c, 0x0a},
+	{0x380d, 0x80},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x10},
+	{0x3812, 0x00},
+	{0x3813, 0x06},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x02},
+	{0x3821, 0x1e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0xfc},
+	{0x5781, 0x13},
+	{0x5782, 0x03},
+	{0x5786, 0x20},
+	{0x5787, 0x40},
+	{0x5788, 0x08},
+	{0x5789, 0x08},
+	{0x578a, 0x02},
+	{0x578b, 0x01},
+	{0x578c, 0x01},
+	{0x578d, 0x0c},
+	{0x578e, 0x02},
+	{0x578f, 0x01},
+	{0x5790, 0x01},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_1920x1080_regs[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},
+	{0x3000, 0x00},
+	{0x3002, 0x21},
+	{0x3005, 0xf0},
+	{0x3007, 0x00},
+	{0x3015, 0x0f},
+	{0x3018, 0x32},
+	{0x301a, 0xf0},
+	{0x301b, 0xf0},
+	{0x301c, 0xf0},
+	{0x301d, 0xf0},
+	{0x301e, 0xf0},
+	{0x3021, 0x03},
+	{0x3030, 0x00},
+	{0x3031, 0x0a},
+	{0x303c, 0xff},
+	{0x303e, 0xff},
+	{0x3040, 0xf0},
+	{0x3041, 0x00},
+	{0x3042, 0xf0},
+	{0x3106, 0x11},
+	{0x3500, 0x00},
+	{0x3502, 0x00},
+	{0x3503, 0x04},
+	{0x3504, 0x03},
+	{0x3505, 0x83},
+	{0x3508, 0x04},
+	{0x3509, 0x00},
+	{0x350e, 0x04},
+	{0x350f, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3601, 0xc8},
+	{0x3610, 0x88},
+	{0x3612, 0x48},
+	{0x3614, 0x5b},
+	{0x3615, 0x96},
+	{0x3621, 0xd0},
+	{0x3622, 0x00},
+	{0x3623, 0x00},
+	{0x3633, 0x13},
+	{0x3634, 0x13},
+	{0x3635, 0x13},
+	{0x3636, 0x13},
+	{0x3645, 0x13},
+	{0x3646, 0x82},
+	{0x3650, 0x00},
+	{0x3652, 0xff},
+	{0x3655, 0x20},
+	{0x3656, 0xff},
+	{0x365a, 0xff},
+	{0x365e, 0xff},
+	{0x3668, 0x00},
+	{0x366a, 0x07},
+	{0x366e, 0x10},
+	{0x366d, 0x00},
+	{0x366f, 0x80},
+	{0x3700, 0x28},
+	{0x3701, 0x10},
+	{0x3702, 0x3a},
+	{0x3703, 0x19},
+	{0x3704, 0x10},
+	{0x3705, 0x00},
+	{0x3706, 0x66},
+	{0x3707, 0x08},
+	{0x3708, 0x34},
+	{0x3709, 0x40},
+	{0x370a, 0x01},
+	{0x370b, 0x1b},
+	{0x3714, 0x24},
+	{0x371a, 0x3e},
+	{0x3733, 0x00},
+	{0x3734, 0x00},
+	{0x373a, 0x05},
+	{0x373b, 0x06},
+	{0x373c, 0x0a},
+	{0x373f, 0xa0},
+	{0x3755, 0x00},
+	{0x3758, 0x00},
+	{0x375b, 0x0e},
+	{0x3766, 0x5f},
+	{0x3768, 0x00},
+	{0x3769, 0x22},
+	{0x3773, 0x08},
+	{0x3774, 0x1f},
+	{0x3776, 0x06},
+	{0x37a0, 0x88},
+	{0x37a1, 0x5c},
+	{0x37a7, 0x88},
+	{0x37a8, 0x70},
+	{0x37aa, 0x88},
+	{0x37ab, 0x48},
+	{0x37b3, 0x66},
+	{0x37c2, 0x04},
+	{0x37c5, 0x00},
+	{0x37c8, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x0c},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3804, 0x0a},
+	{0x3805, 0x33},
+	{0x3806, 0x07},
+	{0x3807, 0xa3},
+	{0x3811, 0x04},
+	{0x3813, 0x02},
+	{0x3815, 0x01},
+	{0x3816, 0x00},
+	{0x3817, 0x00},
+	{0x3818, 0x00},
+	{0x3819, 0x00},
+	{0x3820, 0x00},
+	{0x3821, 0x06},
+	{0x3822, 0x48},
+	{0x3826, 0x00},
+	{0x3827, 0x08},
+	{0x3830, 0x08},
+	{0x3836, 0x02},
+	{0x3837, 0x00},
+	{0x3838, 0x10},
+	{0x3841, 0xff}, /* Auto size function enabled */
+	{0x3846, 0x48},
+	{0x3861, 0x00},
+	{0x3862, 0x04},
+	{0x3863, 0x06},
+	{0x3a11, 0x01},
+	{0x3a12, 0x78},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3c00, 0x89},
+	{0x3c01, 0xab},
+	{0x3c02, 0x01},
+	{0x3c03, 0x00},
+	{0x3c04, 0x00},
+	{0x3c05, 0x03},
+	{0x3c06, 0x00},
+	{0x3c07, 0x05},
+	{0x3c0c, 0x00},
+	{0x3c0d, 0x00},
+	{0x3c0e, 0x00},
+	{0x3c0f, 0x00},
+	{0x3c40, 0x00},
+	{0x3c41, 0xa3},
+	{0x3c43, 0x7d},
+	{0x3c45, 0xd7},
+	{0x3c47, 0xfc},
+	{0x3c50, 0x05},
+	{0x3c52, 0xaa},
+	{0x3c54, 0x71},
+	{0x3c56, 0x80},
+	{0x3d85, 0x17},
+	{0x3d8d, 0xea},
+	{0x3f03, 0x00},
+	{0x3f0a, 0x00},
+	{0x3f0b, 0x00},
+	{0x4001, 0x60},
+	{0x4009, 0x0d},
+	{0x4017, 0x08},
+	{0x4020, 0x00},
+	{0x4021, 0x00},
+	{0x4022, 0x00},
+	{0x4023, 0x00},
+	{0x4024, 0x00},
+	{0x4025, 0x00},
+	{0x4026, 0x00},
+	{0x4027, 0x00},
+	{0x4028, 0x00},
+	{0x4029, 0x00},
+	{0x402a, 0x00},
+	{0x402b, 0x00},
+	{0x402c, 0x00},
+	{0x402d, 0x00},
+	{0x402e, 0x00},
+	{0x402f, 0x00},
+	{0x4040, 0x00},
+	{0x4041, 0x03},
+	{0x4042, 0x00},
+	{0x4043, 0x7A},
+	{0x4044, 0x00},
+	{0x4045, 0x7A},
+	{0x4046, 0x00},
+	{0x4047, 0x7A},
+	{0x4048, 0x00},
+	{0x4049, 0x7A},
+	{0x4303, 0x00},
+	{0x4307, 0x30},
+	{0x4320, 0x80},
+	{0x4500, 0x58},
+	{0x4501, 0x04},
+	{0x4502, 0x40},
+	{0x4503, 0x10},
+	{0x4508, 0xaa},
+	{0x4509, 0xaa},
+	{0x450a, 0x00},
+	{0x450b, 0x00},
+	{0x4700, 0xa4},
+	{0x4800, 0x4c},
+	{0x4816, 0x53},
+	{0x481f, 0x40},
+	{0x4837, 0x13},
+	{0x5000, 0x56},
+	{0x5001, 0x01},
+	{0x5002, 0x28},
+	{0x5004, 0x0c},
+	{0x5006, 0x0c},
+	{0x5007, 0xe0},
+	{0x5008, 0x01},
+	{0x5009, 0xb0},
+	{0x5901, 0x00},
+	{0x5a01, 0x00},
+	{0x5a03, 0x00},
+	{0x5a04, 0x0c},
+	{0x5a05, 0xe0},
+	{0x5a06, 0x09},
+	{0x5a07, 0xb0},
+	{0x5a08, 0x06},
+	{0x5e00, 0x00},
+	{0x3734, 0x40},
+	{0x5b00, 0x01},
+	{0x5b01, 0x10},
+	{0x5b02, 0x01},
+	{0x5b03, 0xdb},
+	{0x3d8c, 0x71},
+	{0x370b, 0x05},
+	{0x3618, 0x2a},
+	{0x5780, 0x3e},
+	{0x5781, 0x0f},
+	{0x5782, 0x44},
+	{0x5783, 0x02},
+	{0x5784, 0x01},
+	{0x5785, 0x01},
+	{0x5786, 0x00},
+	{0x5787, 0x04},
+	{0x5788, 0x02},
+	{0x5789, 0x0f},
+	{0x578a, 0xfd},
+	{0x578b, 0xf5},
+	{0x578c, 0xf5},
+	{0x578d, 0x03},
+	{0x578e, 0x08},
+	{0x578f, 0x0c},
+	{0x5790, 0x08},
+	{0x5791, 0x06},
+	{0x5792, 0x00},
+	{0x5793, 0x52},
+	{0x5794, 0xa3},
+	{0x3503, 0x00},
+	{0x380e, 0x04},
+	{0x380f, 0x60},
+	{0x3002, 0x61},
+	{0x3010, 0x40},
+	{0x300D, 0x00},
+	{0x5045, 0x05},
+	{0x5048, 0x10},
+	{0x3610, 0xa8},
+	{0x3733, 0x10},
+	{0x3734, 0x40},
+	{0x3808, 0x07},
+	{0x3809, 0x80},
+	{0x380a, 0x04},
+	{0x380b, 0x38},
+	{0x3821, 0x06},
+	{0x4600, 0x00},
+	{0x4601, 0xc0},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_1920x1080[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/*, 0xIncluding, 0xsw, 0xreset, 0x*/
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0xf8},
+	{0x3804, 0x0a},
+	{0x3805, 0x3f},
+	{0x3806, 0x06},
+	{0x3807, 0xab},
+	{0x3808, 0x07},
+	{0x3809, 0x80},
+	{0x380a, 0x04},
+	{0x380b, 0x38},
+	{0x380c, 0x0a},
+	{0x380d, 0x80},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x02},
+	{0x3821, 0x1e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x80},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_1280x720_120fps[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x2e},
+	{0x3502, 0x80},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe6},
+	{0x3709, 0xc7},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0xf4},
+	{0x3804, 0x0a},
+	{0x3805, 0x3f},
+	{0x3806, 0x06},
+	{0x3807, 0xab},
+	{0x3808, 0x05},
+	{0x3809, 0x00},
+	{0x380a, 0x02},
+	{0x380b, 0xd0},
+	{0x380c, 0x06},
+	{0x380d, 0xd8},
+	{0x380e, 0x02},
+	{0x380f, 0xf8},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x31},
+	{0x3815, 0x31},
+	{0x3820, 0x02},
+	{0x3821, 0x1f},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x00},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_2592x1944_HDR_24fps[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x0103, 0x01},
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x02},
+	{0x3099, 0x16},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30b2, 0x00},
+	{0x30b3, 0x6e},
+	{0x30b4, 0x03},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x80},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x01},
+	{0x3508, 0x80},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x05},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xa8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x0c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x02},
+	{0x3802, 0x00},
+	{0x3803, 0x06},
+	{0x3804, 0x0a},
+	{0x3805, 0x41},
+	{0x3806, 0x07},
+	{0x3807, 0xa1},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x07},
+	{0x380b, 0x98},
+	{0x380c, 0x0e},
+	{0x380d, 0x70},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x10},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x02},
+	{0x3821, 0x9e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x09},
+	{0x3a05, 0xa9},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_1920x1080_HDR_30fps[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x0103, 0x01},
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x72},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x01},
+	{0x3508, 0x80},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x01},
+	{0x3801, 0x70},
+	{0x3802, 0x01},
+	{0x3803, 0xbc},
+	{0x3804, 0x09},
+	{0x3805, 0x0f},
+	{0x3806, 0x05},
+	{0x3807, 0xff},
+	{0x3808, 0x07},
+	{0x3809, 0x80},
+	{0x380a, 0x04},
+	{0x380b, 0x38},
+	{0x380c, 0x0b},
+	{0x380d, 0x40},
+	{0x380e, 0x07},
+	{0x380f, 0x3a},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x02},
+	{0x3821, 0x9e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x09},
+	{0x3a05, 0xa9},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_1280x720_HDR_60fps[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x0103, 0x01},
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x39},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x01},
+	{0x3508, 0x80},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x02},
+	{0x3801, 0xa8},
+	{0x3802, 0x02},
+	{0x3803, 0x68},
+	{0x3804, 0x07},
+	{0x3805, 0xb7},
+	{0x3806, 0x05},
+	{0x3807, 0x3b},
+	{0x3808, 0x05},
+	{0x3809, 0x00},
+	{0x380a, 0x02},
+	{0x380b, 0xd0},
+	{0x380c, 0x0b},
+	{0x380d, 0x40},
+	{0x380e, 0x03},
+	{0x380f, 0x9e},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x02},
+	{0x3821, 0x9e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x09},
+	{0x3a05, 0xa9},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_2592x1944_one_lane_15fps[] = {
+	{0x0100, 0x00},/* Including sw reset */
+	{0x0103, 0x01},
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x11},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x28},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x05},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x64},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3400, 0x04},
+	{0x3401, 0x00},
+	{0x3402, 0x04},
+	{0x3403, 0x00},
+	{0x3404, 0x04},
+	{0x3405, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x20},
+	{0x3600, 0xbc},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x44},
+	{0x3621, 0xb5},
+	{0x3622, 0x0c},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x0a},
+	{0x3805, 0x3f},
+	{0x3806, 0x07},
+	{0x3807, 0xa3},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x07},
+	{0x380b, 0x98},
+	{0x380c, 0x0a},
+	{0x380d, 0x80},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x02},
+	{0x3821, 0x1e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x2c},
+	{0x4831, 0x64},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0xfc},
+	{0x5781, 0x13},
+	{0x5782, 0x03},
+	{0x5786, 0x20},
+	{0x5787, 0x40},
+	{0x5788, 0x08},
+	{0x5789, 0x08},
+	{0x578a, 0x02},
+	{0x578b, 0x01},
+	{0x578c, 0x01},
+	{0x578d, 0x0c},
+	{0x578e, 0x02},
+	{0x578f, 0x01},
+	{0x5790, 0x01},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{0x0100, 0x01},
+	{0x3810, 0x00},
+	{0x3811, 0x10},
+	{0x3812, 0x00},
+	{0x3813, 0x06},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+enum {
+	OV5670_MODE_2592X1944,
+	OV5670_MODE_2560X1440,
+	OV5670_MODE_1920X1080,
+
+	OV5670_MODE_START_STREAM,
+	OV5670_MODE_STOP_STREAM,
+	OV5670_MODE_TEST_PATTERN
+};
+
+static const ov5670_reg *mode_table[] = {
+	[OV5670_MODE_2592X1944]			= mode_2592x1944_regs,
+	[OV5670_MODE_2560X1440]			= mode_2560x1440_regs,
+	[OV5670_MODE_1920X1080]			= mode_1920x1080_regs,
+
+	[OV5670_MODE_START_STREAM]		= ov5670_start,
+	[OV5670_MODE_STOP_STREAM]		= ov5670_stop,
+	[OV5670_MODE_TEST_PATTERN]		= tp_colorbars,
+};
+
+static const int ov5670_15fps[] = {
+	15,
+};
+
+static const int ov5670_24fps[] = {
+	24,
+};
+
+static const int ov5670_30fps[] = {
+	30,
+};
+
+static const int ov5670_60fps[] = {
+	60,
+};
+
+static const int ov5670_120fps[] = {
+	120,
+};
+
+static const struct camera_common_frmfmt ov5670_frmfmt[] = {
+	{{2592, 1944},	ov5670_30fps,	1, 0,	OV5670_MODE_2592X1944},
+	{{2560, 1440},	ov5670_30fps,	1, 0,	OV5670_MODE_2560X1440},
+	{{1920, 1080},	ov5670_60fps,	1, 0,	OV5670_MODE_1920X1080},
+};
+#endif  /* __OV5670_TABLES__ */
+
diff --git a/drivers/media/platform/tegra/camera/camera_common.c b/drivers/media/platform/tegra/camera/camera_common.c
index 625fa06..8906b30 100644
--- a/drivers/media/platform/tegra/camera/camera_common.c
+++ b/drivers/media/platform/tegra/camera/camera_common.c
@@ -70,6 +70,25 @@ static const struct camera_common_colorfmt camera_common_color_fmts[] = {
 		V4L2_COLORSPACE_SRGB,
 		V4L2_PIX_FMT_XRGGB10P,
 	},
+	/*
+	* new yuv formats
+	*/
+	{
+		MEDIA_BUS_FMT_UYVY8_2X8,
+		V4L2_COLORSPACE_DEFAULT,
+		V4L2_PIX_FMT_UYVY,
+	},
+	{
+		MEDIA_BUS_FMT_SGRBG10_1X10,
+		V4L2_COLORSPACE_SRGB,
+		V4L2_PIX_FMT_SGRBG10,
+	},
+	{
+		MEDIA_BUS_FMT_SGBRG10_1X10,
+		V4L2_COLORSPACE_SRGB,
+		V4L2_PIX_FMT_SGBRG10,
+	},
+	
 };
 
 static const char *camera_common_csi_io_pads[] = {
diff --git a/drivers/media/platform/tegra/camera/sensor_common.c b/drivers/media/platform/tegra/camera/sensor_common.c
index 4e8063f..c5e60d2 100644
--- a/drivers/media/platform/tegra/camera/sensor_common.c
+++ b/drivers/media/platform/tegra/camera/sensor_common.c
@@ -135,6 +135,12 @@ static int extract_pixel_format(
 		*format = V4L2_PIX_FMT_XBGGR10P;
 	else if (strncmp(pixel_t, "bayer_xrggb10p", size) == 0)
 		*format = V4L2_PIX_FMT_XRGGB10P;
+	else if (strncmp(pixel_t, "yuv_uyvy8", size) == 0)
+		*format = V4L2_PIX_FMT_UYVY;
+	else if (strncmp(pixel_t, "bayer_grbg", size) == 0)
+		*format = V4L2_PIX_FMT_SGRBG10;
+	else if (strncmp(pixel_t, "bayer_gbrg", size) == 0)
+		*format = V4L2_PIX_FMT_SGBRG10;
 	else {
 		pr_err("%s: Need to extend format%s\n", __func__, pixel_t);
 		return -EINVAL;
@@ -210,6 +216,7 @@ static int sensor_common_parse_image_props(
 		}
 		sprintf(pix_format, "%s_%s%d", mode_str, phase_str, depth);
 		temp_str = pix_format;
+		dev_err(dev, "pixel_format = %s_%s%d", mode_str, phase_str, depth);
 	}
 
 	err = extract_pixel_format(temp_str, &image->pixel_format);
diff --git a/include/media/imx214.h b/include/media/imx214.h
new file mode 100755
index 0000000..e9294e9
--- /dev/null
+++ b/include/media/imx214.h
@@ -0,0 +1,174 @@
+/*
+ * Copyright (c) 2013-2017, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __IMX214_H__
+#define __IMX214_H__
+
+#include <media/nvc.h>
+#include <media/nvc_image.h>
+
+#define IMX214_IOCTL_SET_MODE               _IOW('o', 1, struct imx214_mode)
+#define IMX214_IOCTL_SET_FRAME_LENGTH       _IOW('o', 2, __u32)
+#define IMX214_IOCTL_SET_COARSE_TIME        _IOW('o', 3, __u32)
+#define IMX214_IOCTL_SET_GAIN               _IOW('o', 4, __u16)
+#define IMX214_IOCTL_GET_STATUS             _IOR('o', 5, __u8)
+#define IMX214_IOCTL_SET_BINNING            _IOW('o', 6, __u8)
+#define IMX214_IOCTL_TEST_PATTERN           _IOW('o', 7, \
+						 enum imx214_test_pattern)
+#define IMX214_IOCTL_SET_GROUP_HOLD         _IOW('o', 8, struct imx214_ae)
+/* IOCTL to set the operating mode of camera.
+ * This can be either stereo , leftOnly or rightOnly */
+#define IMX214_IOCTL_SET_CAMERA_MODE        _IOW('o', 10, __u32)
+#define IMX214_IOCTL_SYNC_SENSORS           _IOW('o', 11, __u32)
+#define IMX214_IOCTL_GET_FUSEID             _IOR('o', 12, struct nvc_fuseid)
+#define IMX214_IOCTL_SET_HDR_COARSE_TIME    _IOW('o', 13, struct imx214_hdr)
+#define IMX214_IOCTL_READ_OTP_BANK          _IOWR('o', 14, \
+						struct imx214_otp_bank)
+#define IMX214_IOCTL_SET_CAL_DATA           _IOW('o', 15, \
+						struct imx214_cal_data)
+#define IMX214_IOCTL_GET_EEPROM_DATA        _IOR('o', 20, __u8 *)
+#define IMX214_IOCTL_SET_EEPROM_DATA        _IOW('o', 21, __u8 *)
+#define IMX214_IOCTL_GET_CAPS               _IOR('o', 22, struct nvc_imager_cap)
+#define IMX214_IOCTL_SET_POWER              _IOW('o', 23, __u32)
+
+#define IMX214_INVALID_COARSE_TIME  -1
+
+#define IMX214_EEPROM_ADDRESS		0x50
+#define IMX214_EEPROM_SIZE		1024
+#define IMX214_EEPROM_STR_SIZE		(IMX214_EEPROM_SIZE * 2)
+#define IMX214_EEPROM_BLOCK_SIZE	(1 << 8)
+#define IMX214_EEPROM_NUM_BLOCKS \
+	(IMX214_EEPROM_SIZE / IMX214_EEPROM_BLOCK_SIZE)
+
+#define IMX214_OTP_LOAD_CTRL_ADDR	0x0A00
+#define IMX214_OTP_BANK_SELECT_ADDR	0x0A02
+#define IMX214_OTP_BANK_START_ADDR	0x0A04
+#define IMX214_OTP_BANK_END_ADDR	0x0A43
+#define IMX214_OTP_NUM_BANKS		(15)
+#define IMX214_OTP_BANK_SIZE \
+	 (IMX214_OTP_BANK_END_ADDR - IMX214_OTP_BANK_START_ADDR + 1)
+#define IMX214_OTP_SIZE \
+	 (IMX214_OTP_BANK_SIZE * IMX214_OTP_NUM_BANKS)
+#define IMX214_OTP_STR_SIZE (IMX214_OTP_SIZE * 2)
+
+//#define IMX214_FUSE_ID_OTP_START_ADDR	0x3D00
+//#define IMX214_FUSE_ID_OTP_BANK	0
+//#define IMX214_FUSE_ID_SIZE		8
+//#define IMX214_FUSE_ID_STR_SIZE	(IMX214_FUSE_ID_SIZE * 2)
+
+#define IMX214_FRAME_LENGTH_ADDR_MSB		0x0340
+#define IMX214_FRAME_LENGTH_ADDR_LSB		0x0341
+#define IMX214_COARSE_TIME_ADDR_1		0x0202
+#define IMX214_COARSE_TIME_ADDR_2		0x0203
+#define IMX214_COARSE_TIME_SHORT_ADDR_1	0x0200
+#define IMX214_COARSE_TIME_SHORT_ADDR_2	0x0201
+#define IMX214_GAIN_ADDR_MSB			0x0204
+#define IMX214_GAIN_ADDR_LSB			0x0205
+#define IMX214_GROUP_HOLD_ADDR			0x0104
+#define IMX214_TIMING_REG20			0x0101
+#define VERTICAL_FLIP				(0x1 << 1)
+#define IMX214_TIMING_REG21			0x0101
+#define HORIZONTAL_MIRROR_MASK			(0x1)
+
+struct imx214_mode {
+	int res_x;
+	int res_y;
+	int fps;
+	__u32 frame_length;
+	__u32 coarse_time;
+	__u32 coarse_time_short;
+	__u16 gain;
+	__u8 hdr_en;
+};
+
+struct imx214_ae {
+	__u32 frame_length;
+	__u8  frame_length_enable;
+	__u32 coarse_time;
+	__u32 coarse_time_short;
+	__u8  coarse_time_enable;
+	__s32 gain;
+	__u8  gain_enable;
+};
+
+struct imx214_fuseid {
+	__u32 size;
+	__u8  id[16];
+};
+
+struct imx214_hdr {
+	__u32 coarse_time_long;
+	__u32 coarse_time_short;
+};
+
+struct imx214_otp_bank {
+	__u32 id;
+	__u8  buf[16];
+};
+
+struct imx214_cal_data {
+	int loaded;
+	int rg_ratio;
+	int bg_ratio;
+	int rg_ratio_typical;
+	int bg_ratio_typical;
+	__u8 lenc[62];
+};
+
+/* See notes in the nvc.h file on the GPIO usage */
+enum imx214_gpio_type {
+	IMX214_GPIO_TYPE_PWRDN = 0,
+	IMX214_GPIO_TYPE_RESET,
+};
+
+struct imx214_eeprom_data {
+	struct i2c_client *i2c_client;
+	struct i2c_adapter *adap;
+	struct i2c_board_info brd;
+	struct regmap *regmap;
+};
+
+struct imx214_power_rail {
+	struct regulator *dvdd;
+	struct regulator *avdd;
+	struct regulator *dovdd;
+};
+
+struct imx214_regulators {
+	const char *avdd;
+	const char *dvdd;
+	const char *dovdd;
+};
+
+struct imx214_platform_data {
+	unsigned cfg;
+	unsigned num;
+	const char *dev_name;
+	unsigned gpio_count; /* see nvc.h GPIO notes */
+	struct nvc_gpio_pdata *gpio; /* see nvc.h GPIO notes */
+	struct nvc_imager_static_nvc *static_info;
+	bool use_vcm_vdd;
+	int (*probe_clock)(unsigned long);
+	int (*power_on)(struct imx214_power_rail *);
+	int (*power_off)(struct imx214_power_rail *);
+	const char *mclk_name;
+	struct nvc_imager_cap *cap;
+	struct imx214_regulators regulators;
+	bool has_eeprom;
+	bool use_cam_gpio;
+};
+
+#endif  /* __IMX214_H__ */
diff --git a/include/media/ov5640.h b/include/media/ov5640.h
new file mode 100755
index 0000000..e39d00e
--- /dev/null
+++ b/include/media/ov5640.h
@@ -0,0 +1,176 @@
+/*
+ * Copyright (c) 2013-2017, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __OV5640_H__
+#define __OV5640_H__
+
+#include <media/nvc.h>
+#include <media/nvc_image.h>
+
+#define OV5640_IOCTL_SET_MODE               _IOW('o', 1, struct ov5640_mode)
+#define OV5640_IOCTL_SET_FRAME_LENGTH       _IOW('o', 2, __u32)
+#define OV5640_IOCTL_SET_COARSE_TIME        _IOW('o', 3, __u32)
+#define OV5640_IOCTL_SET_GAIN               _IOW('o', 4, __u16)
+#define OV5640_IOCTL_GET_STATUS             _IOR('o', 5, __u8)
+#define OV5640_IOCTL_SET_BINNING            _IOW('o', 6, __u8)
+#define OV5640_IOCTL_TEST_PATTERN           _IOW('o', 7, \
+						 enum ov5640_test_pattern)
+#define OV5640_IOCTL_SET_GROUP_HOLD         _IOW('o', 8, struct ov5640_ae)
+/* IOCTL to set the operating mode of camera.
+ * This can be either stereo , leftOnly or rightOnly */
+#define OV5640_IOCTL_SET_CAMERA_MODE        _IOW('o', 10, __u32)
+#define OV5640_IOCTL_SYNC_SENSORS           _IOW('o', 11, __u32)
+#define OV5640_IOCTL_GET_FUSEID             _IOR('o', 12, struct nvc_fuseid)
+#define OV5640_IOCTL_SET_HDR_COARSE_TIME    _IOW('o', 13, struct ov5640_hdr)
+#define OV5640_IOCTL_READ_OTP_BANK          _IOWR('o', 14, \
+						struct ov5640_otp_bank)
+#define OV5640_IOCTL_SET_CAL_DATA           _IOW('o', 15, \
+						struct ov5640_cal_data)
+#define OV5640_IOCTL_GET_EEPROM_DATA        _IOR('o', 20, __u8 *)
+#define OV5640_IOCTL_SET_EEPROM_DATA        _IOW('o', 21, __u8 *)
+#define OV5640_IOCTL_GET_CAPS               _IOR('o', 22, struct nvc_imager_cap)
+#define OV5640_IOCTL_SET_POWER              _IOW('o', 23, __u32)
+
+#define OV5640_INVALID_COARSE_TIME  -1
+
+#define OV5640_EEPROM_ADDRESS		0x50
+#define OV5640_EEPROM_SIZE		1024
+#define OV5640_EEPROM_STR_SIZE		(OV5640_EEPROM_SIZE * 2)
+#define OV5640_EEPROM_BLOCK_SIZE	(1 << 8)
+#define OV5640_EEPROM_NUM_BLOCKS \
+	(OV5640_EEPROM_SIZE / OV5640_EEPROM_BLOCK_SIZE)
+
+#define OV5640_OTP_LOAD_CTRL_ADDR	0x3D81
+#define OV5640_OTP_BANK_SELECT_ADDR	0x3D84
+#define OV5640_OTP_BANK_START_ADDR	0x3D00
+#define OV5640_OTP_BANK_END_ADDR	0x3D0F
+#define OV5640_OTP_NUM_BANKS		(32)
+#define OV5640_OTP_BANK_SIZE \
+	 (OV5640_OTP_BANK_END_ADDR - OV5640_OTP_BANK_START_ADDR + 1)
+#define OV5640_OTP_SIZE \
+	 (OV5640_OTP_BANK_SIZE * OV5640_OTP_NUM_BANKS)
+#define OV5640_OTP_STR_SIZE (OV5640_OTP_SIZE * 2)
+
+#define OV5640_FUSE_ID_OTP_START_ADDR	0x3D00
+#define OV5640_FUSE_ID_OTP_BANK	0
+#define OV5640_FUSE_ID_SIZE		8
+#define OV5640_FUSE_ID_STR_SIZE	(OV5640_FUSE_ID_SIZE * 2)
+
+#define OV5640_FRAME_LENGTH_ADDR_MSB		0x380E
+#define OV5640_FRAME_LENGTH_ADDR_LSB		0x380F
+#define OV5640_COARSE_TIME_ADDR_1		0x3500
+#define OV5640_COARSE_TIME_ADDR_2		0x3501
+#define OV5640_COARSE_TIME_ADDR_3		0x3502
+#define OV5640_COARSE_TIME_SHORT_ADDR_1	0x3506
+#define OV5640_COARSE_TIME_SHORT_ADDR_2	0x3507
+#define OV5640_COARSE_TIME_SHORT_ADDR_3	0x3508
+#define OV5640_GAIN_ADDR_MSB			0x350A
+#define OV5640_GAIN_ADDR_LSB			0x350B
+#define OV5640_GROUP_HOLD_ADDR			0x3208
+#define OV5640_TIMING_REG20			0x3820
+#define VERTICAL_FLIP				((0x1 << 1) | (0x1 << 6))
+#define OV5640_TIMING_REG21			0x3821
+#define HORIZONTAL_MIRROR_MASK			(0x3 << 1)
+
+struct ov5640_mode {
+	int res_x;
+	int res_y;
+	int fps;
+	__u32 frame_length;
+	__u32 coarse_time;
+	__u32 coarse_time_short;
+	__u16 gain;
+	__u8 hdr_en;
+};
+
+struct ov5640_ae {
+	__u32 frame_length;
+	__u8  frame_length_enable;
+	__u32 coarse_time;
+	__u32 coarse_time_short;
+	__u8  coarse_time_enable;
+	__s32 gain;
+	__u8  gain_enable;
+};
+
+struct ov5640_fuseid {
+	__u32 size;
+	__u8  id[16];
+};
+
+struct ov5640_hdr {
+	__u32 coarse_time_long;
+	__u32 coarse_time_short;
+};
+
+struct ov5640_otp_bank {
+	__u32 id;
+	__u8  buf[16];
+};
+
+struct ov5640_cal_data {
+	int loaded;
+	int rg_ratio;
+	int bg_ratio;
+	int rg_ratio_typical;
+	int bg_ratio_typical;
+	__u8 lenc[62];
+};
+
+/* See notes in the nvc.h file on the GPIO usage */
+enum ov5640_gpio_type {
+	OV5640_GPIO_TYPE_PWRDN = 0,
+	OV5640_GPIO_TYPE_RESET,
+};
+
+struct ov5640_eeprom_data {
+	struct i2c_client *i2c_client;
+	struct i2c_adapter *adap;
+	struct i2c_board_info brd;
+	struct regmap *regmap;
+};
+
+struct ov5640_power_rail {
+	struct regulator *dvdd;
+	struct regulator *avdd;
+	struct regulator *dovdd;
+};
+
+struct ov5640_regulators {
+	const char *avdd;
+	const char *dvdd;
+	const char *dovdd;
+};
+
+struct ov5640_platform_data {
+	unsigned cfg;
+	unsigned num;
+	const char *dev_name;
+	unsigned gpio_count; /* see nvc.h GPIO notes */
+	struct nvc_gpio_pdata *gpio; /* see nvc.h GPIO notes */
+	struct nvc_imager_static_nvc *static_info;
+	bool use_vcm_vdd;
+	int (*probe_clock)(unsigned long);
+	int (*power_on)(struct ov5640_power_rail *);
+	int (*power_off)(struct ov5640_power_rail *);
+	const char *mclk_name;
+	struct nvc_imager_cap *cap;
+	struct ov5640_regulators regulators;
+	bool has_eeprom;
+	bool use_cam_gpio;
+};
+
+#endif  /* __OV5640_H__ */
diff --git a/include/media/ov5670.h b/include/media/ov5670.h
new file mode 100755
index 0000000..6d10e47
--- /dev/null
+++ b/include/media/ov5670.h
@@ -0,0 +1,185 @@
+/*
+ * Copyright (c) 2013-2017, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __OV5670_H__
+#define __OV5670_H__
+
+#include <media/nvc.h>
+#include <media/nvc_image.h>
+
+#define OV5670_IOCTL_SET_MODE               _IOW('o', 1, struct ov5670_mode)
+#define OV5670_IOCTL_SET_FRAME_LENGTH       _IOW('o', 2, __u32)
+#define OV5670_IOCTL_SET_COARSE_TIME        _IOW('o', 3, __u32)
+#define OV5670_IOCTL_SET_GAIN               _IOW('o', 4, __u16)
+#define OV5670_IOCTL_GET_STATUS             _IOR('o', 5, __u8)
+#define OV5670_IOCTL_SET_BINNING            _IOW('o', 6, __u8)
+#define OV5670_IOCTL_TEST_PATTERN           _IOW('o', 7, \
+						 enum ov5670_test_pattern)
+#define OV5670_IOCTL_SET_GROUP_HOLD         _IOW('o', 8, struct ov5670_ae)
+/* IOCTL to set the operating mode of camera.
+ * This can be either stereo , leftOnly or rightOnly */
+#define OV5670_IOCTL_SET_CAMERA_MODE        _IOW('o', 10, __u32)
+#define OV5670_IOCTL_SYNC_SENSORS           _IOW('o', 11, __u32)
+#define OV5670_IOCTL_GET_FUSEID             _IOR('o', 12, struct nvc_fuseid)
+#define OV5670_IOCTL_SET_HDR_COARSE_TIME    _IOW('o', 13, struct ov5670_hdr)
+#define OV5670_IOCTL_READ_OTP_BANK          _IOWR('o', 14, \
+						struct ov5670_otp_bank)
+#define OV5670_IOCTL_SET_CAL_DATA           _IOW('o', 15, \
+						struct ov5670_cal_data)
+#define OV5670_IOCTL_GET_EEPROM_DATA        _IOR('o', 20, __u8 *)
+#define OV5670_IOCTL_SET_EEPROM_DATA        _IOW('o', 21, __u8 *)
+#define OV5670_IOCTL_GET_CAPS               _IOR('o', 22, struct nvc_imager_cap)
+#define OV5670_IOCTL_SET_POWER              _IOW('o', 23, __u32)
+
+#define OV5670_INVALID_COARSE_TIME  -1
+
+#define OV5670_EEPROM_ADDRESS		0x50
+#define OV5670_EEPROM_SIZE		1024
+#define OV5670_EEPROM_STR_SIZE		(OV5670_EEPROM_SIZE * 2)
+#define OV5670_EEPROM_BLOCK_SIZE	(1 << 8)
+#define OV5670_EEPROM_NUM_BLOCKS \
+	(OV5670_EEPROM_SIZE / OV5670_EEPROM_BLOCK_SIZE)
+
+#define OV5670_OTP_LOAD_CTRL_ADDR	0x3D81
+#define OV5670_OTP_LOAD_CTRL_ADDR_START	0x3D88
+#define OV5670_OTP_LOAD_CTRL_ADDR_END	0x3D8A
+#define OV5670_OTP_BANK_SELECT_ADDR	0x3D84
+#define OV5670_OTP_BANK_START_ADDR	0x7010
+#define OV5670_OTP_BANK_END_ADDR	0x7063
+//#define OV5670_OTP_NUM_BANKS		(3)
+#define OV5670_OTP_NUM_BANKS		(1)
+//#define OV5670_OTP_BANK_SIZE		0x20
+#define OV5670_OTP_BANK_SIZE		(OV5670_OTP_BANK_END_ADDR - OV5670_OTP_BANK_START_ADDR + 1)
+#define OV5670_OTP_SIZE			(OV5670_OTP_BANK_END_ADDR - OV5670_OTP_BANK_START_ADDR + 1)
+#define OV5670_OTP_STR_SIZE (OV5670_OTP_SIZE * 2)
+/*
+//#define OV5670_OTP_BANK_SIZE \
+//	 (OV5670_OTP_BANK_END_ADDR - OV5670_OTP_BANK_START_ADDR + 1)
+//#define OV5670_OTP_SIZE \
+//	 (OV5670_OTP_BANK_SIZE * OV5670_OTP_NUM_BANKS)
+//#define OV5670_OTP_STR_SIZE (OV5670_OTP_SIZE * 2)
+
+//#define OV5670_FUSE_ID_OTP_START_ADDR	0x7100
+//#define OV5670_FUSE_ID_OTP_BANK	0
+//#define OV5670_FUSE_ID_SIZE		8
+//#define OV5670_FUSE_ID_STR_SIZE	(OV5670_FUSE_ID_SIZE * 2)
+*/
+
+#define OV5670_FRAME_LENGTH_ADDR_MSB		0x380E
+#define OV5670_FRAME_LENGTH_ADDR_LSB		0x380F
+#define OV5670_COARSE_TIME_ADDR_1		0x3500
+#define OV5670_COARSE_TIME_ADDR_2		0x3501
+#define OV5670_COARSE_TIME_ADDR_3		0x3502
+#define OV5670_COARSE_TIME_SHORT_ADDR_1		0x3510
+#define OV5670_COARSE_TIME_SHORT_ADDR_2		0x3511
+#define OV5670_COARSE_TIME_SHORT_ADDR_3		0x3512
+#define OV5670_GAIN_ADDR_MSB			0x3508
+#define OV5670_GAIN_ADDR_LSB			0x3509
+#define OV5670_GROUP_HOLD_ADDR			0x3208
+#define OV5670_TIMING_REG20			0x3820
+#define VERTICAL_FLIP				((0x1 << 1) | (0x1 << 2) | (0x1 << 6))
+#define OV5670_TIMING_REG21			0x3821
+#define HORIZONTAL_MIRROR_MASK			(0x3 << 1)
+
+struct ov5670_mode {
+	int res_x;
+	int res_y;
+	int fps;
+	__u32 frame_length;
+	__u32 coarse_time;
+	__u32 coarse_time_short;
+	__u16 gain;
+	__u8 hdr_en;
+};
+
+struct ov5670_ae {
+	__u32 frame_length;
+	__u8  frame_length_enable;
+	__u32 coarse_time;
+	__u32 coarse_time_short;
+	__u8  coarse_time_enable;
+	__s32 gain;
+	__u8  gain_enable;
+};
+
+struct ov5670_fuseid {
+	__u32 size;
+	__u8  id[16];
+};
+
+struct ov5670_hdr {
+	__u32 coarse_time_long;
+	__u32 coarse_time_short;
+};
+
+struct ov5670_otp_bank {
+	__u32 id;
+	__u8  buf[16];
+};
+
+struct ov5670_cal_data {
+	int loaded;
+	int rg_ratio;
+	int bg_ratio;
+	int rg_ratio_typical;
+	int bg_ratio_typical;
+	__u8 lenc[62];
+};
+
+/* See notes in the nvc.h file on the GPIO usage */
+enum ov5670_gpio_type {
+	OV5670_GPIO_TYPE_PWRDN = 0,
+	OV5670_GPIO_TYPE_RESET,
+};
+
+struct ov5670_eeprom_data {
+	struct i2c_client *i2c_client;
+	struct i2c_adapter *adap;
+	struct i2c_board_info brd;
+	struct regmap *regmap;
+};
+
+struct ov5670_power_rail {
+	struct regulator *dvdd;
+	struct regulator *avdd;
+	struct regulator *dovdd;
+};
+
+struct ov5670_regulators {
+	const char *avdd;
+	const char *dvdd;
+	const char *dovdd;
+};
+
+struct ov5670_platform_data {
+	unsigned cfg;
+	unsigned num;
+	const char *dev_name;
+	unsigned gpio_count; /* see nvc.h GPIO notes */
+	struct nvc_gpio_pdata *gpio; /* see nvc.h GPIO notes */
+	struct nvc_imager_static_nvc *static_info;
+	bool use_vcm_vdd;
+	int (*probe_clock)(unsigned long);
+	int (*power_on)(struct ov5670_power_rail *);
+	int (*power_off)(struct ov5670_power_rail *);
+	const char *mclk_name;
+	struct nvc_imager_cap *cap;
+	struct ov5670_regulators regulators;
+	bool has_eeprom;
+	bool use_cam_gpio;
+};
+
+#endif  /* __OV5670_H__ */
